;(function(){
  const CSS_CLASS_PAKKET_BAD = 'bad';
  const CSS_CLASS_PAKKET_FINE = 'ok';
  const CSS_CLASS_PAKKET_MISSING = 'missing';
  const CSS_CLASS_PAKKET_LATEST = 'latest';
  const CSS_CLASS_PAKKET_NOT_LATEST = 'not-latest';
  const FLAG_GET_ONLY_BROKEN = 'broken=1';
  const RENDER_ONLY_BROKEN = location.href.indexOf(FLAG_GET_ONLY_BROKEN) > -1 ? true : false;
  // extendable via the payload
  const desiredColumnsOrder = ['spec', 'source'];
  const urlPieces = location.href.split('s=');
  const $onlyBrokenEl = $('#only-problematic');
  const $searchEl = $('#s_pakket');
  const $tbodyEl = $('#tbody');
  let OSmetadata;
  // parcels list we fetch from localSorage / BE once
  // and do all further manipulations
  let parcels;

  // changing 'only broken' checkbox ASAP
  if (RENDER_ONLY_BROKEN) {
    $onlyBrokenEl.attr('checked', 'checked');
  }
  // same thing with query string
  if (urlPieces.length === 2) {
    $searchEl.attr('value', urlPieces[1]);
  }

  // actual rendering packages call
  renderPackages();
  fetchVersion();

  function renderPackages() {

    const URL_FETCH_PAKKETS = '/all_packages';
    const localStorageKey = 'pakkets';
    // first checking if data is available at localStorage
    let pakketsInLocalStorage = localStorage.getItem(localStorageKey);
    if (pakketsInLocalStorage) {
      _renderUI(JSON.parse(pakketsInLocalStorage));
    }

    // updating cache if required
    $.ajax(URL_FETCH_PAKKETS).done(function(data) {
      const cachedPakketObject = JSON.stringify(data);
      if (pakketsInLocalStorage !== cachedPakketObject) {
        localStorage.setItem(localStorageKey, cachedPakketObject);
        // re-rendering UI
        _renderUI(data);
      }
    });

  }

  function fetchVersion() {

    const URL_FETCH_VERSION = '/info';
    const localStorageKey = 'pakket-version';
    // first checking if data is available at localStorage
    let pakketVersion = localStorage.getItem(localStorageKey);
    if (pakketVersion) {
      _renderVersion(pakketVersion);
    }

    // updating cache if required
    $.ajax(URL_FETCH_VERSION).done(function(data) {
      if (!data.version) return;
      const version = String(data.version);
      if (version !== pakketVersion) {
        localStorage.setItem(localStorageKey, version);
        // re-rendering UI
        _renderVersion(version);
      }
    });

  }

  /*
   * Helper functions
   **/

  function _renderVersion(version) {
    $('#pakket-uwsgi-version').text(version);
    $('.pakket-uwsgi-version').show();
  }

  function _renderTableBody() {
    // by default rendering whole list of parcels
    let payload = parcels;
    const onlyBroken = location.href.indexOf(FLAG_GET_ONLY_BROKEN) > -1 ? true : false;;
    let searchQuery = $searchEl.val();
    searchQuery = searchQuery ? searchQuery.trim() : '';
    searchQuery = searchQuery.toLowerCase();
    searchQuery = searchQuery.replace(/::/g,'-');

    // filtering out only broken if it's a case
    if (onlyBroken) {
      payload = [];
      parcels.forEach((pakket) => {
        // skipping pakket based on flag onlyBroken
        let isBroken = false;
        Object.values(pakket[1]).forEach((value) => {
          if (typeof value !== 'object') {
            if (value === 0) {
              isBroken = true;
              return;
            }
          } else {
            if (Object.values(value).filter(val => val === 0).length > 0) {
              isBroken = true;
            }
          }
        });

        if (isBroken) {
          payload.push(pakket);
        }
      });
    }

    // filtering by name
    if (searchQuery.length) {
      // cloning payload
      const lookup = payload.slice();
      payload = [];
      lookup.forEach((pakket) => {
        if (pakket[0].toLowerCase().indexOf(searchQuery) > -1) {
          payload.push(pakket);
        }
      });
    }

    // calculating and rendering body
    let tableBody = '';
    const pakketsMap = new Map();

    // calculating pakketsMap - no rendering yet
    payload.forEach((pakket) => {
      const nameFull = pakket[0];
      const namePieces = nameFull.split('=');
      const nameShort = namePieces[0];
      const version = namePieces[1];
      let mapVersions = pakketsMap.get(nameShort);
      mapVersions = mapVersions || [];
      if (mapVersions) {
        mapVersions.push(version);
      }
      pakketsMap.set(nameShort, mapVersions);
    });
    // actual rendering to a string
    payload.forEach((pakket) => {
      const namePieces = pakket[0].split('=');
      tableBody += columnRenderer({
        name: namePieces[0],
        version: namePieces[1],
        order: desiredColumnsOrder,
        os_meta: OSmetadata,
        data: pakket,
        versions_all: pakketsMap.get(namePieces[0])
      });
    });

    // required on re-render
    $tbodyEl.empty();
    $tbodyEl.append(`${tableBody}`);
  }

  function _renderUI(data) {
    // taking pakket #1 and getting columns metadata from it
    const keys = Object.keys(data[0][1]);
    let finalOrder = desiredColumnsOrder;
    keys.forEach((key) => {
      if (desiredColumnsOrder.indexOf(key) === -1) {
        finalOrder.push(key);
      }
      // getting OS metadata from first perl version prop
      if (strIsPerlVersion(key)){
        OSmetadata = Object.keys(data[0][1][key]).sort();
      }
    });

    let tableHead = '<tr>';
    tableHead += '<td class="name" rowspan="2" colspan="2">module name</td>';
    desiredColumnsOrder.forEach((column) => {
      // calculating colspan and rowspan
      let colspan = 1;
      let rowspan = 1;
      if (strIsPerlVersion(column)){
        colspan = 2;
      } else {
        rowspan = 2;
      }
      tableHead += `<td colspan="${colspan}" rowspan="${rowspan}">${column}</td>`;
    });
    tableHead += '</tr><tr>';
    desiredColumnsOrder.forEach((column) => {
      if (!strIsPerlVersion(column)) return;
      OSmetadata.forEach((os) => {
        tableHead += `<td>${os}</td>`;
      });
    });
    tableHead += '</tr>';
    // showing page title
    $('.hidden').removeClass('hidden');
    // required on re-render
    $('#thead').empty();
    $('#thead').append(tableHead);

    // making payload available globally
    parcels = data;
    _renderTableBody();

  }

  // helper functions
  // Is the string containing Perl version?
  function strIsPerlVersion(str) {
    return !isNaN(parseInt(str));
  }

  // GET query creator
  function composeGetQuery() {
    const search = $searchEl.val().toLowerCase();
    const params = [];
    if ($onlyBrokenEl.is(':checked')) {
      params.push(FLAG_GET_ONLY_BROKEN);
    }
    if (search.length) {
      params.push(`s=${search}`);
    }
    let getQuery = '/status';
    params.forEach((param, index) => {
      const separator = index === 0 ? '?' : '&';
      getQuery += `${separator}${param}`;
    });
    return getQuery;
  }

  // Pakket table column renderer
  function columnRenderer(config) {
    const renderQueue = [];
    let problematicPakket = false;
    let versionsUI = '';
    const versionsArr = config.versions_all;
    versionsArr.forEach((version) => {
      versionsUI += `<option value="${version}" ${(version === config.version) ? 'selected' : ''}>${version}</option>`;
    });
    let tableRow = `<td class="name">${config.name}</td>
      <td class="version">${(versionsArr.length === 1 ? versionsArr[0] : ('<select data-name="' + config.name.replace(/[\/\.\:]/g,'') + '">' + versionsUI + '</select>'))}</td>`;
    config.order.forEach((column) => {
      if (strIsPerlVersion(column)){
        config.os_meta.forEach((os) => {
          renderQueue.push(config.data[1][column][os] ? '+' : '-');
        });
      } else {
        renderQueue.push(config.data[1][column] ? '+' : '-');
      }
    });
    // rendering queue
    renderQueue.forEach((val) => {
      tableRow += `<td ${(val === '+' ? '' : ('class="' + CSS_CLASS_PAKKET_MISSING + '"'))}>${val}</td>`;
    });
    // figuring out if pakket is problematic + reflecting in <tr> css class
    problematicPakket = !!renderQueue.filter(val => val === '-').length;
    const latestVersion = config.versions_all[config.versions_all.length - 1];
    return `<tr ${config.version !== latestVersion ? 'style="display: none;"' : ''}
      id="pak--${config.name.replace(/[\/\.\:]/g,'')}-${config.version.replace(/[\/\.\:]/g,'')}"
      class="${problematicPakket ? CSS_CLASS_PAKKET_BAD : CSS_CLASS_PAKKET_FINE}
            ${config.version === latestVersion ? CSS_CLASS_PAKKET_LATEST : CSS_CLASS_PAKKET_NOT_LATEST}">${tableRow}</tr>`;
  }

  // search helper
  function search() {
    window.history.pushState('', '', composeGetQuery());
    const search = $searchEl.val().toLowerCase();
    _renderTableBody();
  }

  $tbodyEl.on('change', '.version select', function(e){
    const $target = $(e.target);
    const value = $target.val();
    const pakketName = $target.data('name');
    const $currRow = $target.parents('tr');
    const $select = $currRow.find('select');
    // hiding current row
    $currRow.hide();
    // re-shaking select UI
    const selectOptions = $select.html();
    $select.html(selectOptions);
    // showing new one
    $(`#pak--${pakketName}-${value.replace(/[\/\.\:]/g,'')}`).show();
  });

  $onlyBrokenEl.on('change', function(){
    if ($(this).is(':checked')) {
      // reflecting change in URL
      window.history.pushState('', '', composeGetQuery());
    } else {
      // reflecting change in URL
      window.history.replaceState('', '', composeGetQuery());
    }
    _renderTableBody();
  });

  // search DOM handler
  let timeout;
  $searchEl.on('input', function(){
    const TIMEOUT = 200;
    if ((new Date().getTime() - timeout) < TIMEOUT) clearTimeout(timeout);
    timeout = setTimeout(search, TIMEOUT);
  });

})();

// vim:ft=javascript
