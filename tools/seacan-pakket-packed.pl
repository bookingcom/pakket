#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Dancer2/Plugin/Pakket/ParamTypes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DANCER2_PLUGIN_PAKKET_PARAMTYPES';
  package Dancer2::Plugin::Pakket::ParamTypes;
  # ABSTRACT: Parameter types for the Dancer2 Pakket app
  
  use strict;
  use warnings;
  use constant { 'HTTP_USER_ERROR' => 400 };
  use Dancer2::Plugin;
  
  extends('Dancer2::Plugin::ParamTypes');
  plugin_keywords('with_types');
  
  sub with_types {
      my $self = shift;
      return $self->SUPER::with_types(@_);
  }
  
  sub BUILD {
      my $self = shift;
  
      $self->register_type_check(
          'Str' => sub { defined $_[0] && length $_[0] },
      );
  
      $self->register_type_action(
          'MissingID' => sub {
              send_error( 'Missing or incorrect ID', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingName' => sub {
              send_error( 'Missing or incorrect Name', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingCategory' => sub {
              send_error( 'Missing or incorrect Category', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingContent' => sub {
              send_error( 'Missing or incorrect content', HTTP_USER_ERROR() );
          },
      );
  
      $self->register_type_action(
          'MissingFilename' => sub {
              send_error( 'Missing or incorrect filename', HTTP_USER_ERROR() );
          },
      );
  }
  
  1;
DANCER2_PLUGIN_PAKKET_PARAMTYPES

$fatpacked{"Pakket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET';
  package Pakket;
  # ABSTRACT: An Unopinionated Meta-Packaging System
  
  use strict;
  use warnings;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  Pakket is a meta-packaging system that allows you to manage
  dependencies. It works by trying to avoid work.
  
  =head2 What can you do with Pakket?
  
  The main purpose of Pakket is simple: Package applications and
  libraries. That is all.
  
  Pakket provides a lot of flexibility in how this is done. Here is a list
  of specific things you can do with Pakket.
  
  =over 4
  
  =item * You can generate spec files automatically
  
  Given an existing API for a language (Perl, Ruby, Python, Rust), Pakket
  can generate the entire tree of configurations and all the dependencies
  for a given language.
  
  If you are looking to convert all your Perl modules, Pakket will simply
  generate the appropriate specs and requirements.
  
  =item * You can represent packages closer to their true nature
  
  Arbitrary packaging systems (e.g., RPM, Deb, etc.) attempt to produce
  the same packages as other more language-specific packaging systems
  (Perl's CPAN, Ruby's Gem, Python's Pypi) by reducing the level of
  detail each package provides.
  
  Pakket doesn't do that. Pakket attempts to maintain as much information
  from the source as it can in order to handle more complicated corner
  cases.
  
  An example of this is the way different systems compare versions. CPAN
  and Gem and Pypi handle versions differently, but they are all reduces
  for the general purpose that RPM or Deb provide.
  
  =item * You can connect different packages
  
  Package systems designed specifically for, say Node.js, cannot connect
  their packages with C dependencies or with Perl dependencies. C programs
  do not have a packaging system, so C "packages" cannot be connected with
  anything.
  
  Because Pakket knows these packages, it can connect them together, even
  if their own systems can't.
  
  If you have a Perl binding to a C++ library, you can represent that
  relationship in Pakket. Pakket will then know how to build the C++
  library and build your Perl module binding to that C++ library.
  
  =item * You can build packages for deployment
  
  Pakket builds simple package files that can then be delivered to a
  different machine and used there.
  
  I mean, why else would we do this?
  
  =item * You can install packages
  
  The Pakket installer allows installing a package and its dependencies
  recursively, from disk or mirrors, and to manage your installation tree.
  
  Again, this is pretty mandatory.
  
  =item * Atomic installations
  
  Did we mention all installations in Pakket are atomic? This means that
  if you're installing 20 or 20,000 packages and it fails, everything
  still works. Pakket only activates the new installation once it finished
  everything successfully.
  
  =item * Reverts are also atomic
  
  The Pakket installer allows, by default, to retain multiple
  installation directories. This means any revert can be simply a single
  atomic operation of pointing to an older installation.
  
  =item * Multiple instances
  
  Most packaging systems can only work with a single installation of a
  package for the entire system. If you need another copy of a package
  (same version or a different version), you either can't do it, or the
  packaging system must create a new package with a name that contains the
  version (python27, python3, etc.).
  
  Pakket considers any installation as a single installation instance. You
  can have as many installations of a package as you want. There can be a
  global one, a per-user one, a local directory one, a project-specific
  one, etc.; your pick. You can use one or more than one.
  
  =back
  
  =head2 Pakket elements
  
  Pakket has several key elements:
  
  =head3 Packages
  
  Everything you wish to build and install is a package. A package
  can be a program in your favorite language, a library of a language,
  or anything at all. It will go through a build process you pick and
  it will get bundled into a parcel.
  
  =head3 Categories
  
  All packages have a category. Unlike other systems, Pakket doesn't
  have a flat structure of packages. They're split into categories.
  
  The category of a package tells Pakket what kind of build system it
  needs, how to retrieve metadata from the sources, and what to do
  with it.
  
  For example, packages in the B<perl> category tell Pakket that the
  builder will need to use one of the available build systems for
  a Perl module (such as C<ExtUtils::MakeMaker> or C<Module::Build>).
  It will also use the versioning scheme that Perl has in order to
  decide which is a newer version and which is older.
  
  =head3 Requirements
  
  Pakket makes a difference between a package and a requirement. A package
  is an existing instance; a requirement is a description. The requirement
  can have a range of allowed versions for a package, for example.
  
  =head3 Spec files
  
  Similar to RPM spec files, Pakket has spec files. You can create them
  yourself or you can use the L<generate|Pakket::CLI::Command::manage>
  command to create them for you.
  
  The basic spec file in Pakket contain a package's C<category>,
  C<name>, and C<version>. It usually contains C<prereqs> as well,
  keyed by the B<category> and the B<phase>. The phases can be
  B<configure> (for build-time), B<test> (for when testing the build),
  and B<runtime> (for using it).
  
  An example of a spec in Pakket in JSON:
  
      {
         "Package" : {
            "category" : "perl",
            "name" : "HTML-Tidy",
            "version" : "1.56"
         },
         "Prereqs" : {
            "native" : {
               "configure" : {
                  "tidyp" : {
                     "version" : "1.04"
                  }
               }
            },
            "perl" : {
               "configure" : {
                  "ExtUtils-MakeMaker" : {
                     "version" : "7.24"
                  }
               },
               "runtime" : {
                  "Test-Simple" : {
                     "version" : "1.302031"
                  }
               }
            }
         }
      }
  
  The package details are in the C<Package> section. The prereqs are
  in the C<Prereqs> section, under the C<native> or C<perl> categories,
  under the C<configure> or C<runtime> phase.
  
  Pakket I<might> store these configurations in JSON, but it could also
  store it in other ways if desired.
  
  =head3 Parcels
  
  Parcels are the result of building packages. Parcels are what gets
  finally installed. You may also call them the "build artifacts" if you
  wish.
  
  While other packaging systems usually have I<development packages> (or
  I<devel> or I<dev>), Pakket doesn't differentiate between those.
  Instead, a Pakket package contains everything created at install time
  for a built package, including the headers, if such would have been
  installed.
PAKKET

$fatpacked{"Pakket/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER';
  package Pakket::Builder;
  # ABSTRACT: Build pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp                      qw< croak >;
  use Path::Tiny                qw< path        >;
  use File::Copy::Recursive     qw< dircopy     >;
  use Algorithm::Diff::Callback qw< diff_hashes >;
  use Types::Path::Tiny         qw< Path >;
  use Log::Any                  qw< $log >;
  use version 0.77;
  
  use Pakket::Log qw< log_success log_fail >;
  use Pakket::Package;
  use Pakket::PackageQuery;
  use Pakket::Bundler;
  use Pakket::Installer;
  use Pakket::Builder::NodeJS;
  use Pakket::Builder::Perl;
  use Pakket::Builder::Native;
  
  use Pakket::Utils qw< generate_env_vars >;
  
  use constant {
      'BUILD_DIR_TEMPLATE' => 'BUILD-XXXXXX',
  };
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasSpecRepo
      Pakket::Role::HasSourceRepo
      Pakket::Role::HasParcelRepo
      Pakket::Role::Perl::BootstrapModules
      Pakket::Role::RunCommand
  >;
  
  has 'build_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'coerce'  => 1,
      'lazy'    => 1,
      'default' => sub {
          return Path::Tiny->tempdir(
              BUILD_DIR_TEMPLATE(),
              'CLEANUP' => 0,
          );
      },
  );
  
  has 'keep_build_dir' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has 'is_built' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'build_files_manifest' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'builders' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          return {
              'nodejs' => Pakket::Builder::NodeJS->new(),
              'perl'   => Pakket::Builder::Perl->new(),
              'native' => Pakket::Builder::Native->new(),
          };
      },
  );
  
  has 'bundler' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Bundler',
      'lazy'    => 1,
      'builder' => '_build_bundler',
  );
  
  has 'installer' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Installer',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Installer->new(
              'pakket_dir'  => $self->build_dir,
              'parcel_repo' => $self->parcel_repo,
          );
      },
  );
  
  has 'installer_cache' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'bootstrapping' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {1},
  );
  
  has 'requirements' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  sub _build_bundler {
      my $self = shift;
  
      return Pakket::Bundler->new(
          'parcel_repo' => $self->parcel_repo,
      );
  }
  
  sub build {
      my ( $self, @queries ) = @_;
      my %categories = map +( $_->category => 1 ), @queries;
  
      $self->_setup_build_dir;
  
      if ( $self->bootstrapping ) {
          foreach my $category ( keys %categories ) {
              $self->bootstrap_build($category);
              log_success('Bootstrapping');
          }
      }
  
      foreach my $query (@queries) {
          $self->run_build($query);
      }
  }
  
  sub DEMOLISH {
      my $self      = shift;
      my $build_dir = $self->build_dir;
  
      if ( !$self->keep_build_dir ) {
          $log->debug("Removing build dir $build_dir");
  
          # "safe" is false because it might hit files which it does not have
          # proper permissions to delete (example: ZMQ::Constants.3pm)
          # which means it won't be able to remove the directory
          $build_dir->remove_tree( { 'safe' => 0 } );
      }
  
      return;
  }
  
  sub _setup_build_dir {
      my $self = shift;
  
      $log->debugf( 'Creating build dir %s', $self->build_dir->stringify );
      my $prefix_dir = $self->build_dir->child('main');
  
      $prefix_dir->is_dir or $prefix_dir->mkpath;
  
      return;
  }
  
  sub bootstrap_build {
      my ( $self, $category ) = @_;
  
      my @dists =
          $category eq 'perl' ? @{ $self->perl_bootstrap_modules } :
          # add more categories here
          ();
  
      @dists or return;
  
      ## no critic qw(BuiltinFunctions::ProhibitComplexMappings Lax::ProhibitComplexMappings::LinesNotStatements)
      my %dist_reqs = map {;
          my $name    = $_;
          my $ver_rel = $self->spec_repo->latest_version_release(
              $category, $name,
          );
          my ( $version, $release ) = @{$ver_rel};
  
          $name => Pakket::PackageQuery->new(
              'name'     => $name,
              'category' => $category,
              'version'  => $version,
              'release'  => $release,
          );
      } @dists;
  
      foreach my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $self->parcel_repo->has_object($dist_req->id)
              or next;
  
          $log->debugf(
              'Skipping: parcel %s already exists',
              $dist_req->full_name,
          );
  
          delete $dist_reqs{$dist_name};
      }
  
      @dists = grep { $dist_reqs{$_} } @dists;
      @dists or return;
  
      # Pass I: bootstrap toolchain - build w/o dependencies
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $log->debugf( 'Bootstrapping: phase I: %s (%s)',
                         $dist_req->full_name, 'no-deps' );
  
          $self->run_build(
              $dist_req,
              { 'bootstrapping_1_skip_prereqs' => 1 },
          );
      }
  
      # Pass II: bootstrap toolchain - build dependencies only
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          $log->debugf( 'Bootstrapping: phase II: %s (%s)',
                         $dist_req->full_name, 'deps-only' );
  
          $self->run_build(
              $dist_req,
              { 'bootstrapping_2_deps_only' => 1 },
          );
      }
  
      # Pass III: bootstrap toolchain - rebuild w/ dependencies
      # XXX: Whoa!
      my $bootstrap_builder = ref($self)->new(
          'parcel_repo'    => $self->parcel_repo,
          'spec_repo'      => $self->spec_repo,
          'source_repo'    => $self->source_repo,
          'keep_build_dir' => $self->keep_build_dir,
          'builders'       => $self->builders,
          'installer'      => $self->installer,
          'bootstrapping'  => 0,
      );
  
      for my $dist_name ( @dists ) {
          my $dist_req = $dist_reqs{$dist_name};
  
          # remove the temp (no-deps) parcel
          $log->debugf( 'Removing %s (no-deps parcel)',
                         $dist_req->full_name );
  
          $self->parcel_repo->remove_package_parcel($dist_req);
  
          # build again with dependencies
  
          $log->debugf( 'Bootstrapping: phase III: %s (%s)',
                         $dist_req->full_name, 'full deps' );
  
          $bootstrap_builder->build($dist_req);
      }
  }
  
  sub run_build {
      my ( $self, $query, $params ) = @_;
      $params //= {};
      my $level             = $params->{'level'}                        || 0;
      my $skip_prereqs      = $params->{'bootstrapping_1_skip_prereqs'} || 0;
      my $bootstrap_prereqs = $params->{'bootstrapping_2_deps_only'}    || 0;
      my $full_name         = $query->full_name;
  
      $self->builders->{ $query->category }->exclude_packages->{ $query->name }
          and return;
  
      if ( ! $bootstrap_prereqs and defined $self->is_built->{$full_name} ) {
          $log->debug(
              "We already built or building $full_name, skipping...",
          );
  
          return;
      }
  
      $self->is_built->{$full_name} = 1;
  
      $log->infof( '%s Working on %s', '|...' x $level, $query->full_name );
  
      # Create a Package instance from the spec
      # using the information we have on it
      my $package_spec = $self->spec_repo->retrieve_package_spec($query);
      my $package      = Pakket::Package->new_from_spec( +{
          %{$package_spec},
  
          # We are dealing with a version which should not be installed
          # outside of a bootstrap phase, so we're "marking" this package
          'is_bootstrap' => !!$skip_prereqs,
      } );
  
      my $top_build_dir  = $self->build_dir;
      my $main_build_dir = $top_build_dir->child('main');
  
      my $installer = $self->installer;
  
      if ( !$skip_prereqs && !$bootstrap_prereqs ) {
          my $installer_cache = $self->installer_cache;
          my $bootstrap_cache = {
              %{ $self->installer_cache },
  
              # Phase 3 needs to avoid trying to install
              # the bare minimum toolchain (Phase 1)
              $query->category => { $package->name => $package->version },
          };
  
          my $successfully_installed = $installer->try_to_install_package(
              $package,
              $main_build_dir,
              {
                  'cache'        => ( $self->bootstrapping ? $installer_cache : $bootstrap_cache ),
                  'skip_prereqs' => $skip_prereqs,
              },
          );
  
          if ($successfully_installed) {
  
              # snapshot_build_dir
              $self->snapshot_build_dir( $package, $main_build_dir->absolute, 0 );
  
              $log->infof( '%s Installed %s', '|...' x $level, $query->full_name );
  
              # sync build cache with our install cache
              # so we do not accidentally build things
              # that were installed in some recursive iteration
              foreach my $category ( sort keys %{$installer_cache} ) {
                  foreach my $package_name (
                      keys %{ $installer_cache->{$category} } )
                  {
                      my ($ver,$rel) = @{$installer_cache->{$category}{$package_name}};
                      my $pkg = Pakket::PackageQuery->new(
                                          'category' => $category,
                                          'name'     => $package_name,
                                          'version'  => $ver,
                                          'release'  => $rel,
                                      );
                      $self->is_built->{ $pkg->full_name } = 1;
  
                      # save requirements of dependencies
                      my $spec = $self->spec_repo->retrieve_package_spec($pkg);
  
                      for my $dep_category ( keys %{$spec->{'Prereqs'}} ) {
                          my $runtime_deps =
                                  $spec->{'Prereqs'}{$dep_category}{'runtime'};
  
                          for my $dep_name (keys %$runtime_deps) {
                              $self->requirements->{$dep_name}{$pkg->short_name} =
                                          $runtime_deps->{$dep_name}{'version'};
                          }
                      }
                  }
              }
  
              return;
          }
      }
  
      # recursively build prereqs
      # FIXME: GH #74
      if ( $bootstrap_prereqs or ! $skip_prereqs ) {
          foreach my $category ( keys %{ $self->builders } ) {
              $self->_recursive_build_phase( $package, $category, 'configure', $level+1 );
              $self->_recursive_build_phase( $package, $category, 'runtime', $level+1 );
          }
      }
  
      $bootstrap_prereqs and return; # done building prereqs
      my $package_src_dir
          = $self->source_repo->retrieve_package_source($package);
  
      $log->debug('Copying package files');
  
      my $env_vars_spec = $package->build_opts->{'env_vars'};
      # FIXME: This shouldn't just be configure flags
      # we should allow the builder to have access to a general
      # metadata chunk which *might* include configure flags
      my %env_vars = generate_env_vars( $top_build_dir, $main_build_dir, $env_vars_spec );
      my $configure_flags = $self->get_configure_flags(
          $package->build_opts->{'configure_flags'},
          { %ENV, %env_vars },
      );
  
      my $build_flags = $self->get_configure_flags(
          $package->build_opts->{'build_flags'},
          { %ENV, %env_vars },
      );
  
      if ( my $builder = $self->builders->{ $package->category } ) {
          my $package_dst_dir = $top_build_dir->child(
              'src',
              $package->category,
              $package_src_dir->basename,
          );
  
  
          dircopy( $package_src_dir, $package_dst_dir );
  
          # during coping, dircopy() resets mtime to current time,
          # which breaks 'make' for some native libraries
          # we have to keep original mtime for files from tar archive
          fix_timestamps($package_src_dir, $package_dst_dir);
  
          if ( $package->build_opts->{'pre_build'} ) {
              foreach my $cmd_set ( @{ $package->build_opts->{'pre_build'} } ) {
                  $self->run_command(
                      $package_src_dir,
                      $cmd_set,
                  );
              }
          }
  
          $builder->build_package(
              $package->name,
              $package_dst_dir,
              $main_build_dir,
              $configure_flags,
              $build_flags,
              $env_vars_spec,
          );
  
          if ( $package->build_opts->{'post_build'} ) {
              foreach my $cmd_set ( @{ $package->build_opts->{'post_build'} } ) {
                  $self->run_command(
                      $package_src_dir,
                      $cmd_set,
                  );
              }
          }
      } else {
          croak( $log->criticalf(
              'I do not have a builder for category %s.',
              $package->category,
          ) );
      }
  
      my $package_files = $self->snapshot_build_dir(
          $package, $main_build_dir,
      );
  
      $log->infof( '%s Bundling %s', '|...' x $level, $package->full_name );
      $self->bundler->bundle(
          $main_build_dir->absolute,
          $package,
          $package_files,
      );
  
      $log->infof( '%s Finished on %s', '|...' x $level, $query->full_name );
      log_success( sprintf 'Building %s', $query->full_name );
  
      return;
  }
  
  sub fix_timestamps {
      my ($src_dir, $dst_dir) = @_;
      $src_dir->visit(
          sub {
              my $src = shift;
              my $dst = path($dst_dir, $src->relative($src_dir));
              $dst->touch( $src->stat->mtime );
          },
          { recurse => 1 }
      );
  }
  
  sub _recursive_build_phase {
      my ( $self, $package, $category, $phase, $level ) = @_;
      my @prereqs = keys %{ $package->prereqs->{$category}{$phase} };
  
      foreach my $prereq_name (@prereqs) {
          $self->requirements->{$prereq_name}{$package->short_name} =
              $package->prereqs->{$category}{$phase}{$prereq_name}{'version'};
  
          my $prereq_ver_req = join(",",
                                  values %{$self->requirements->{$prereq_name}});
  
          my $ver_rel = $self->spec_repo->latest_version_release(
              $category, $prereq_name, $prereq_ver_req,
          );
  
          my ( $version, $release ) = @{$ver_rel};
  
          my $req = Pakket::PackageQuery->new(
              'category' => $category,
              'name'     => $prereq_name,
              'version'  => $version,
              'release'  => $release,
          );
  
          $self->run_build( $req, { 'level' => $level } );
      }
  }
  
  sub snapshot_build_dir {
      my ( $self, $package, $main_build_dir, $error_out ) = @_;
      $error_out //= 1;
  
      $log->debug('Scanning directory.');
  
      # XXX: this is just a bit of a smarter && dumber rsync(1):
      # rsync -qaz BUILD/main/ output_dir/
      # the reason is that we need the diff.
      # if you can make it happen with rsync, remove all of this. :P
      # perhaps rsync(1) should be used to deploy the package files
      # (because then we want *all* content)
      # (only if unpacking it directly into the directory fails)
      my $package_files = $self->retrieve_new_files($main_build_dir);
  
      if ($error_out) {
          keys %{$package_files}
              or croak( $log->criticalf(
                  'This is odd. %s build did not generate new files. '
                      . 'Cannot package.',
                  $package->full_name,
              ) );
      }
  
      # store per all packages to get the diff
      @{ $self->build_files_manifest }{ keys( %{$package_files} ) }
          = values %{$package_files};
  
      return $self->normalize_paths($package_files);
  }
  
  sub normalize_paths {
      my ( $self, $package_files ) = @_;
      my $paths;
      for my $path_and_timestamp (keys %$package_files) {
          my ($path) = $path_and_timestamp =~ /^(.+)_\d+?$/;
          $paths->{$path} = $package_files->{$path_and_timestamp};
      }
      return $paths;
  }
  
  sub retrieve_new_files {
      my ( $self, $build_dir ) = @_;
  
      my $nodes = $self->_scan_directory($build_dir);
      my $new_files
          = $self->_diff_nodes_list( $self->build_files_manifest, $nodes, );
  
      return $new_files;
  }
  
  sub _scan_directory {
      my ( $self, $dir ) = @_;
  
      my $visitor = sub {
          my ( $node, $state ) = @_;
  
          return if $node->is_dir;
  
          my $path_and_timestamp = sprintf("%s_%s",$node->absolute, $node->stat->ctime);
  
          # save the symlink path in order to symlink them
          if ( -l $node ) {
              path( $state->{ $path_and_timestamp } = readlink $node )->is_absolute
                  and croak( $log->critical(
                      "Error. Absolute path symlinks aren't supported.",
                  ) );
          } else {
              $state->{ $path_and_timestamp } = '';
          }
      };
  
      return $dir->visit(
          $visitor,
          { 'recurse' => 1, 'follow_symlinks' => 0 },
      );
  }
  
  # There is a possible micro optimization gain here
  # if we diff and copy in the same loop
  # instead of two steps
  sub _diff_nodes_list {
      my ( $self, $old_nodes, $new_nodes ) = @_;
  
      my %nodes_diff;
      diff_hashes(
          $old_nodes,
          $new_nodes,
          'added'   => sub { $nodes_diff{ $_[0] } = $_[1] },
      );
  
      return \%nodes_diff;
  }
  
  sub get_configure_flags {
      my ( $self, $config, $expand_env ) = @_;
  
      $config or return [];
  
      my @flags = @{$config};
  
      $self->_expand_flags_inplace( \@flags, $expand_env );
  
      return \@flags;
  }
  
  sub _expand_flags_inplace {
      my ( $self, $flags, $env ) = @_;
  
      for my $flag ( @{$flags} ) {
          for my $key ( keys %{$env} ) {
              my $placeholder = '%' . uc($key) . '%';
              $flag =~ s/$placeholder/$env->{$key}/gsm;
          }
      }
  
      return;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      use Pakket::Builder;
      my $builder = Pakket::Builder->new();
      $builder->build('perl/Dancer2=0.205000');
  
  =head1 DESCRIPTION
  
  The L<Pakket::Builder> is in charge of building a Pakket package. It is
  normally accessed with the C<pakket install> command. Please see
  L<pakket> for the command line interface. Specifically
  L<Pakket::CLI::Command::install> for the C<install> command
  documentation.
  
  The building includes bootstrapping any toolchain systems (currently
  only applicable to Perl) and then building all packages specifically.
  
  The installer (L<Pakket::Installer>) can be used to install pre-built
  packages.
  
  Once the building is done, the files and their manifest is sent to the
  bundler (L<Pakket::Bundler>) in order to create the final parcel. The
  parcel will be stored in the appropriate storage, based on your
  configuration.
  
  =head1 ATTRIBUTES
  
  =head2 bootstrapping
  
  A boolean indiciating if we want to bootstrap.
  
  Default: B<1>.
  
  =head2 build_dir
  
  The directory in which we build the packages.
  
  Default: A temporary build directory in your temp dir.
  
  =head2 build_files_manifest
  
  After building, the list of built files are stored in this hashref.
  
  =head2 builders
  
  A hashref of available builder classes.
  
  Currently, L<Pakket::Builder::Native>, L<Pakket::Builder::Perl>, and
  L<Pakket::Builder::NodeJS>.
  
  =head2 bundler
  
  The L<Pakket::Bundler> object used for creating the parcel from the
  built files.
  
  =head2 config
  
  A configuration hashref populated by L<Pakket::Config> from the config file.
  
  Read more at L<Pakket::Role::HasConfig>.
  
  =head2 installer
  
  The L<Pakket::Installer> object used for installing any pre-built
  parcels during the build phase.
  
  =head2 installer_cache
  
  A cache for the installer to prevent installation loops.
  
  =head2 is_built
  
  A cache for the built packages for the builder to prevent a loop
  during the build phase.
  
  =head2 keep_build_dir
  
  A boolean that controls whether the build dir will be deleted or
  not. This is useful for debugging.
  
  Default: B<0>.
  
  =head2 perl_bootstrap_modules
  
  See L<Pakket::Role::Perl::BootstrapModules>.
  
  =head2 parcel_repo
  
  See L<Pakket::Role::HasParcelRole>.
  
  =head2 parcel_repo_backend
  
  See L<Pakket::Role::HasParcelRole>.
  
  =head2 source_repo
  
  See L<Pakket::Role::HasSourceRole>.
  
  =head2 source_repo_backend
  
  See L<Pakket::Role::HasSourceRole>.
  
  =head2 spec_repo
  
  See L<Pakket::Role::HasSpecRole>.
  
  =head2 spec_repo_backend
  
  See L<Pakket::Role::HasSpecRole>.
  
  =head2 requirements
  
  A hashref in which we store the requirements for further building
  during the build phase.
  
  =head1 METHODS
  
  =head2 run_command
  
  See L<Pakket::Role::RunCommand>.
  
  =head2 run_command_sequence
  
  See L<Pakket::Role::RunCommand>.
  
  =head2 bootstrap_build($category)
  
  Build all the packages to bootstrap a build environment. This would
  include any toolchain packages necessary.
  
      $builder->bootstrap_build('perl');
  
  This procedure requires three steps:
  
  =over 4
  
  =item 1.
  
  First, we build the bootstrapping packages within the context of the
  builder. However, they will depend on any libraries or applications
  already available in the current environment. For example, in a Perl
  environment, it will use core modules available with the existing
  interpreter.
  
  They will need to be built without any dependencies. Since they assume
  on the available dependencies in the system, they will build
  succesfully.
  
  =item 2.
  
  Secondly, we build their dependencies only. This will allow us to then
  build on top of them the original bootstrapping modules, thus
  separating them from the system entirely.
  
  =item 3.
  
  Lastly, we repeat the first step, except with dependencies, and
  explicitly preferring the dependencies we built at step 2.
  
  =back
  
  =head2 build(@pkg_queries)
  
  The main method of the class. Sets up the bootstrapping and calls
  C<run_build>.
  
      my $pkg_query = Pakket::PackageQuery->new(...);
      $builder->build($pkg_query);
  
  See L<Pakket::PackageQuery> on defining a query for a package.
  
  =head2 get_configure_flags(\%configure_flags, \%env)
  
  This method generates the configure flags for a given package from its
  configuration.
  
  =head2 normalize_paths(\%package_files);
  
  Given a set of paths and timestamps, returns a new hashref with
  normalized paths.
  
  =head2 retrieve_new_files($build_dir)
  
  Once a build has finished, we attempt to install the directory to a
  controlled environment. This method scans that directory to find any
  new files generated. This is determined to get packaged in the parcel.
  
  =head2 run_build($pkg_query, \%params)
  
  You should not be calling this function directly.
  
  The guts of the class. Builds an available package and all of its
  dependencies recursively.
  
      my $pkg_query = Pakket::PackageQuery->new(...);
  
      $builder->run_build(
          $pkg_query,
          {%parameters},
      );
  
  See L<Pakket::PackageQuery> on defining a query for a package.
  
  The method receives a single package query object and a hashref of
  parameters.
  
  =over 4
  
  =item * level
  
  This helps with debugging.
  
  =item * bootstrapping_1_skip_prereqs
  
  An indicator of phase 1 of boostrapping.
  
  =item * boostrapping_2_deps_only
  
  An indicator of phase 2 of boostrapping.
  
  =back
  
  =head2 snapshot_build_dir( $package, $build_dir, $error_out )
  
  This method generates the manifest list for the parcel from the scanned
  files.
  
  =head2 DEMOLISH
  
  Clean up phase, provided by L<Moose>, used to remove the build
  directory if C<keep_build_dir> is false.
  
  Do not call directly.
PAKKET_BUILDER

$fatpacked{"Pakket/Builder/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NATIVE';
  package Pakket::Builder::Native;
  # ABSTRACT: Build Native Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp qw< croak >;
  use Log::Any qw< $log >;
  use Pakket::Log;
  use Pakket::Builder::Native::Makefile;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $flags ) = @_;
  
      if (   $build_dir->child('configure')->exists
          || $build_dir->child('config')->exists
          || $build_dir->child('Configure')->exists
          || $build_dir->child('cmake')->exists )
      {
          my $builder = Pakket::Builder::Native::Makefile->new();
          $builder->build_package( $package, $build_dir, $prefix, $flags );
      } else {
          croak( $log->critical(
              "Cannot build native package '$package', no '[Cc]onfigure' or 'config'.") );
      }
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NATIVE

$fatpacked{"Pakket/Builder/Native/Makefile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NATIVE_MAKEFILE';
  package Pakket::Builder::Native::Makefile;
  # ABSTRACT: Build Native Pakket packages that use Makefile
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp qw< croak >;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $flags ) = @_;
  
      $log->info("Building native package '$package'");
  
      my $opts = {
          'env' => {
              generate_env_vars($build_dir, $prefix),
          },
      };
  
      my $configurator;
      my @configurator_flags = ('--prefix=' . $prefix->absolute);
      if ( -f $build_dir->child('configure') ) {
          $configurator = './configure';
      } elsif ( -f $build_dir->child('config') ) {
          $configurator = './config';
      } elsif ( -f $build_dir->child('Configure') ) {
          $configurator = './Configure';
      } elsif ( -e $build_dir->child('cmake') ) {
          $configurator = 'cmake';
          @configurator_flags = ('-DCMAKE_INSTALL_PREFIX=' . $prefix->absolute, '.') ;
      } else {
          croak( $log->critical( "Don't know how to configure native package '$package'"
                  . " (Cannot find executale '[Cc]onfigure' or 'config')" ) );
      }
  
      my @seq = (
  
          # configure
          [
              $build_dir,
              [
                  $configurator, @configurator_flags,
                  @{$flags},
              ],
              $opts,
          ],
  
          # build
          [ $build_dir, ['make'], $opts, ],
  
          # install
          [ $build_dir, [ 'make', 'install' ], $opts, ],
      );
  
      my $success = $self->run_command_sequence(@seq);
  
      if ( !$success ) {
          croak( $log->critical("Failed to build native package '$package'") );
      }
  
      $log->info("Done building native package '$package'");
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NATIVE_MAKEFILE

$fatpacked{"Pakket/Builder/NodeJS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_NODEJS';
  package Pakket::Builder::NodeJS;
  # ABSTRACT: Build Perl Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp       qw< croak >;
  use English    qw< -no_match_vars >;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  
  with qw<Pakket::Role::Builder>;
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix ) = @_;
  
      $log->info("Building NodeJS module: $package");
  
      my $opts = {
          'env' => {
              generate_env_vars($prefix),
          },
      };
  
      my $source = $build_dir;
  
      if ( $ENV{'NODE_NPM_REGISTRY'} ) {
          $self->run_command( $build_dir,
              [ qw< npm set registry >, $ENV{'NODE_NPM_REGISTRY'} ], $opts );
          $source = $package;
      }
  
      my $success
          = $self->run_command( $build_dir, [ qw< npm install -g >, $source ],
          $opts );
  
      if ( !$success ) {
          croak( $log->critical("Failed to build $package") );
      }
  
      $log->info("Done preparing $package");
  
      return;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_NODEJS

$fatpacked{"Pakket/Builder/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUILDER_PERL';
  package Pakket::Builder::Perl;
  # ABSTRACT: Build Perl Pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use English    qw< -no_match_vars >;
  use Log::Any   qw< $log >;
  use Pakket::Log;
  use Pakket::Utils qw< generate_env_vars >;
  use Carp ();
  
  with qw<Pakket::Role::Builder>;
  
  has '+exclude_packages' => (
      'default' => sub {
          return {
              'perl'     => 1,
  
              # MetaCPAN bug
              'perl_mlb' => 1,
          };
      },
  );
  
  sub build_package {
      my ( $self, $package, $build_dir, $prefix, $config_flags, $build_flags, $env_vars ) = @_;
  
      $log->info("Building Perl module: $package");
  
  
      # FIXME: run_command will not return output, so we do this for now
      my $inc;
      {
          local $ENV{'PERL5LIB'}; # don't let us affect the exec'ed process
          chomp( $inc = `perl -e'print join ":",\@INC'` );
      }
  
      my %env = generate_env_vars( $build_dir, $prefix, { 'inc' => $inc }, $env_vars);
  
      # By default ExtUtils::Install checks if a file wasn't changed then skip it
      # which breaks Builder::snapshot_build_dir().
      # To change that behaviour and force installer to copy all files,
      # ExtUtils::Install uses a parameter 'always_copy'
      # or environment variable EU_INSTALL_ALWAYS_COPY.
      $env{'EU_INSTALL_ALWAYS_COPY'} = 1;
  
      my $opts = { 'env' => \%env };
  
      foreach my $env_var ( keys %env ) {
          $log->trace( 'export ' . join '=', $env_var, $env{$env_var} );
      }
  
      my $install_base = $prefix->absolute;
  
      # taken from cpanminus
      my %should_use_mm = map +( "perl/$_" => 1 ),
          qw( version ExtUtils-ParseXS ExtUtils-Install ExtUtils-Manifest );
  
      # If you have a Build.PL file but we can't load Module::Build,
      # it means you didn't declare it as a dependency
      # If you have a Makefile.PL, we can at least use that,
      # otherwise, we'll croak
      my $has_build_pl    = $build_dir->child('Build.PL')->exists;
      my $has_makefile_pl = $build_dir->child('Makefile.PL')->exists;
  
      my @seq;
      if ( $has_build_pl && !exists $should_use_mm{$package} ) {
          # Do we have Module::Build?
          my $has_module_build =
              $self->run_command($build_dir, ['perl','-MModule::Build','-e1'], $opts)
              || $self->run_command($build_dir,[ 'perl','-MModule::Build::Tiny','-e1'], $opts);
  
          # If you have Module::Build, we can use it!
          if ($has_module_build) {
              @seq = $self->_build_pl_cmds( $build_dir, $install_base, $config_flags, $build_flags, $opts );
          } else {
              $log->warn(
                  'Defined Build.PL but can\'t load Module::Build. Will try Makefile.PL',
              );
          }
      }
  
      if ($has_makefile_pl && !@seq) {
          @seq = $self->_makefile_pl_cmds( $build_dir, $install_base, $config_flags, $build_flags, $opts );
      }
  
      @seq or Carp::croak('Could not find an installer (Makefile.PL/Build.PL)');
  
      my $success = $self->run_command_sequence(@seq);
  
      if ( !$success ) {
          Carp::croak( $log->critical("Failed to build $package") );
      }
  
      $log->info("Done preparing $package");
  
      return;
  }
  
  sub _build_pl_cmds {
      my ( $self, $build_dir, $install_base, $config_flags, $build_flags, $opts ) = @_;
      return (
  
          # configure
          [
              $build_dir,
              [ 'perl', '-f', 'Build.PL', '--install_base', $install_base, @{$config_flags} ],
              $opts,
          ],
  
          # build
          [ $build_dir, [ 'perl', '-f', './Build', @{$build_flags} ], $opts ],
  
          # install
          [ $build_dir, [ 'perl', '-f', './Build', 'install' ], $opts ],
      );
  }
  
  sub _makefile_pl_cmds {
      my ( $self, $build_dir, $install_base, $config_flags, $build_flags, $opts ) = @_;
      return (
  
          # configure
          [
              $build_dir,
              [ 'perl', '-f', 'Makefile.PL', "INSTALL_BASE=$install_base", @{$config_flags} ],
              $opts,
          ],
  
          # build
          [ $build_dir, ['make', @{$build_flags}], $opts ],
  
          # install
          [ $build_dir, [ 'make', 'install' ], $opts ],
      );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_BUILDER_PERL

$fatpacked{"Pakket/Bundler.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_BUNDLER';
  package Pakket::Bundler;
  # ABSTRACT: Bundle pakket packages into a parcel file
  
  use Moose;
  use MooseX::StrictConstructor;
  use JSON::MaybeXS;
  use File::chdir;
  use File::Spec;
  use Carp              qw< croak >;
  use Path::Tiny        qw< path >;
  use Types::Path::Tiny qw< AbsPath >;
  use Log::Any          qw< $log >;
  
  use Pakket::Package;
  use Pakket::Repository::Parcel;
  
  use Pakket::Constants qw<
      PARCEL_FILES_DIR
      PARCEL_METADATA_FILE
  >;
  
  use Pakket::Utils qw< encode_json_pretty >;
  
  use constant {
      'BUNDLE_DIR_TEMPLATE' => 'BUNDLE-XXXXXX',
  };
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasParcelRepo
  >;
  
  sub bundle {
      my ( $self, $build_dir, $package, $files ) = @_;
  
      my $original_dir    = Path::Tiny->cwd;
      my $parcel_dir_path = Path::Tiny->tempdir(
          'TEMPLATE' => BUNDLE_DIR_TEMPLATE(),
          'CLEANUP'  => 1,
      );
  
      $parcel_dir_path->child( PARCEL_FILES_DIR() )->mkpath;
  
      chdir $parcel_dir_path->child( PARCEL_FILES_DIR() )->stringify;
  
      foreach my $orig_file ( keys %{$files} ) {
          $log->debug("Bundling $orig_file");
          my $new_fullname = $self->_rebase_build_to_output_dir(
              $build_dir, $orig_file,
          );
  
          -e $new_fullname
              and croak( 'Odd. File already seems to exist in packaging dir. '
                    . "Stopping.\n" );
  
          # create directories
          $new_fullname->parent->mkpath;
  
          # regular file
          if ( $files->{$orig_file} eq '' ) {
              path($orig_file)->copy($new_fullname)
                  or croak("Failed to copy $orig_file to $new_fullname\n");
  
              my $raw_mode = ( stat($orig_file) )[2];
              my $mode_str = sprintf '%04o', $raw_mode & oct('07777');
              chmod oct($mode_str), $new_fullname;
          } else {
              my $new_symlink = $self->_rebase_build_to_output_dir(
                  $build_dir, $files->{$orig_file},
              );
              {
                  local $CWD = $new_fullname->parent;
                  symlink $new_symlink, $new_fullname->basename;
              }
          }
      }
  
      path( PARCEL_METADATA_FILE() )->spew_utf8(
          encode_json_pretty( $package->spec ),
      );
  
      chdir '..';
  
      $log->infof( 'Creating parcel file for %s', $package->full_name );
  
      # The lovely thing here is that is creates a parcel file from the
      # bundled directory, which gets cleaned up automatically
      $self->parcel_repo->store_package_parcel(
          $package,
          $parcel_dir_path,
      );
  
      chdir $original_dir;
  
      return;
  }
  
  sub _rebase_build_to_output_dir {
      my ( $self, $build_dir, $orig_filename ) = @_;
      ( my $new_filename = $orig_filename ) =~ s/^ \Q$build_dir\E //xms;
      my @parts = File::Spec->splitdir($new_filename);
  
      # in case the path is absolute (leading slash)
      # the split function will generate an empty first element
      # if it's relative, it will have value and shouldn't be removed
      $parts[0] eq '' and shift @parts;
  
      return path(@parts);
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 config
  
  See L<Pakket::Role::HasConfig>.
  
  =head2 parcel_repo
  
  See L<Pakket::Role::HasParcelRepo>.
  
  =head1 METHODS
  
  =head2 BUILD
  
  Build phase, provided by L<Moose>, used to set up the parcel repo
  before we begin bundling.
  
  Do not call directly.
  
  =head2 bundle($build_dir, $package, \%files)
  
  This will bundle the list of files for a given package in a given
  directory. It will create a parcel file which will include the files,
  including metadata on the package it includes.
PAKKET_BUNDLER

$fatpacked{"Pakket/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI';
  package Pakket::CLI;
  # ABSTRACT: Command line interface for Pakket
  
  use strict;
  use warnings;
  use App::Cmd::Setup '-app';
  
  1;
  
  __END__
PAKKET_CLI

$fatpacked{"Pakket/CLI/Command/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_BUILD';
  package Pakket::CLI::Command::build;
  # ABSTRACT: Build a Pakket parcel
  
  use strict;
  use warnings;
  
  use Pakket::CLI '-command';
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  use Pakket::Config;
  use Pakket::Builder;
  use Pakket::PackageQuery;
  use Pakket::Log;
  use Pakket::Utils::Repository qw< gen_repo_config >;
  
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  use Log::Any::Adapter;
  
  sub abstract    { 'Build a package' }
  sub description { 'Build a package' }
  
  sub opt_spec {
      return (
          [ 'input-file=s',    'build stuff from this file' ],
          [ 'build-dir=s',     'use an existing build directory' ],
          [ 'keep-build-dir',  'do not delete the build directory' ],
          [ 'spec-dir=s',      'directory holding the specs' ],
          [ 'source-dir=s',    'directory holding the sources' ],
          [ 'output-dir=s',    'output directory (default: .)' ],
          [ 'config|c=s',      'configuration file' ],
          [ 'verbose|v+',      'verbose output (can be provided multiple times)' ],
          [ 'log-file=s',      'Log file (default: build.log)' ],
          [ 'ignore-failures', 'Continue even if some builds fail' ],
      );
  }
  
  sub _determine_config {
      my ( $self, $opt ) = @_;
  
      my $config_file = $opt->{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      my $config = $config_reader->read_config;
  
      # Setup default repos
      my %repo_opt = (
          'spec'   => 'spec_dir',
          'source' => 'source_dir',
          'parcel' => 'output_dir',
      );
  
      foreach my $type ( keys %repo_opt ) {
          my $opt_key   = $repo_opt{$type};
          my $directory = $opt->{$opt_key};
          if ( $directory ) {
              my $repo_conf = $self->gen_repo_config( $type, $directory );
              $config->{'repositories'}{$type} = $repo_conf;
          }
          $config->{'repositories'}{$type}
              or $self->usage_error("Missing configuration for $type repository");
      }
  
      return $config;
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      $opt->{'config'} = $self->_determine_config($opt);
      $opt->{'config'}{'env'}{'cli'} = 1;
  
      my $log_file = $opt->{'log_file'} || $opt->{'config'}{'log_file'};
      Log::Any::Adapter->set(
          'Dispatch',
          'dispatcher' => Pakket::Log->build_logger(
              $opt->{'verbose'}, $log_file,
          ),
      );
  
      my @specs;
      if ( defined ( my $file = $opt->{'input_file'} ) ) {
          my $path = path($file);
          $path->exists && $path->is_file
              or $self->usage_error("Bad input file: $path");
  
          push @specs, $path->lines_utf8( { 'chomp' => 1 } );
      } elsif ( @{$args} ) {
          @specs = @{$args};
      } else {
          $self->usage_error('Must specify at least one package or a file');
      }
  
      foreach my $spec_str (@specs) {
          my ( $cat, $name, $version, $release ) =
              $spec_str =~ PAKKET_PACKAGE_SPEC();
  
          $cat && $name && $version && $release
              or $self->usage_error(
                  "Provide category/name=version:release, not '$spec_str'",
              );
  
          my $query;
          eval { $query = Pakket::PackageQuery->new_from_string($spec_str); 1; }
          or do {
              my $error = $@ || 'Zombie error';
              $log->debug("Failed to create PackageQuery: $error");
              $self->usage_error(
                  "We do not understand this package string: $spec_str",
              );
          };
  
          push @{ $self->{'queries'} }, $query;
      }
  
      if ( $opt->{'build_dir'} ) {
          path( $opt->{'build_dir'} )->is_dir
              or die "You asked to use a build dir that does not exist.\n";
      }
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      my $builder = Pakket::Builder->new(
          'config' => $opt->{'config'},
  
          # Maybe we have it, maybe we don't
          map( +(
              defined $opt->{$_}
                  ? ( $_ => $opt->{$_} )
                  : ()
          ), qw< build_dir keep_build_dir > ),
      );
  
      if ( ! $opt->{'ignore_failures'} ) {
          $builder->build( @{ $self->{'queries'} } );
          return;
      }
  
      foreach my $query ( @{ $self->{'queries'} } ) {
          eval {
              $builder->build($query);
              1;
          } or do {
              my $error = $@ || 'Zombie error';
              $log->warnf('Failed to build %s, skipping.', $query->full_name );
          };
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      $ pakket build perl/Dancer2
  
      $ pakket build native/tidyp=1.04
  
      $ pakket build --help
  
          --input-file STR     build stuff from this file
          --build-dir STR      use an existing build directory
          --keep-build-dir     do not delete the build directory
          --spec-dir STR       directory holding the specs
          --source-dir STR     directory holding the sources
          --output-dir STR     output directory (default: .)
          -c STR --config STR  configuration file
          -v --verbose         verbose output (can be provided multiple times)
          --log-file STR       Log file (default: build.log)
          --ignore-failures    Continue even if one the builds failed
  
  =head1 DESCRIPTION
  
  Once you have your configurations (spec) and the sources for your
  packages, you can issue a build of them using this command. It will
  generate parcels, which are the build artifacts.
  
  (The parcels are equivalent of C<.rpm> or C<.deb> files.)
  
      # Build latest version of package "Dancer2" of category "perl"
      $ pakket build perl/Dancer2
  
      # Build specific version
      $ pakket build perl/Dancer2=0.205000
  
  Depending on the configuration you have for Pakket, the result will
  either be saved in a file or in a database or sent to a remote server.
PAKKET_CLI_COMMAND_BUILD

$fatpacked{"Pakket/CLI/Command/init.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_INIT';
  package Pakket::CLI::Command::init;
  
  # ABSTRACT: Initialize a pakket instance
  
  use strict;
  use warnings;
  use English '-no_match_vars';
  use Pakket::CLI '-command';
  use Pakket::Log;
  use Pakket::Utils qw< is_writeable >;
  use Log::Any::Adapter;
  use Log::Any   qw< $log >;
  use Path::Tiny qw< path >;
  use File::HomeDir;
  
  sub abstract    {'Initialize Pakket'}
  sub description {'Initialize Pakket'}
  
  sub opt_spec {
      return (
          [ 'repo-dir=s', 'repo directory (default: /var/lib/pakket)' ],
          [ 'local',      'short-hand for --repo-dir=~/.pakket' ],
          [ 'force|f',    'force init (for reinitialization)' ],
          [ 'verbose|v+', 'verbose output (can be provided multiple times)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt ) = @_;
  
      my $logger = Pakket::Log->cli_logger(2); # verbosity
      Log::Any::Adapter->set( 'Dispatch', dispatcher => $logger );
  
      # global installation and pakket is already available
      if (  !$opt->{'repo_dir'}
          && $ENV{'PAKKET_REPO'}
          && -d $ENV{'PAKKET_REPO'}
          && !$opt->{'force'} )
      {
          die $log->critical(
              "Pakket is already globally initialized at $ENV{'PAKKET_REPO'}");
      }
  
      $self->{'repo'} = path(
          $opt->{'repo_dir'} // $opt->{'local'}
          ? ( File::HomeDir->my_home, '.pakket' )
          : ( Path::Tiny->rootdir, qw< usr local pakket > ),
      );
  }
  
  sub execute {
      my $self = shift;
  
      # 1. create main repo directory
      # TODO: allow configuration files? interactive?
      my $repo_dir = $self->{'repo'};
  
      if ( !is_writeable($repo_dir) ) {
          die $log->critical("No permissions to write to $repo_dir.");
      }
  
      $repo_dir->is_dir
          or $repo_dir->mkpath;
  
      # 2. print the configuration
      my $pakket_homedir
          = path( File::HomeDir->my_home,
          $OSNAME =~ m{win}ms ? 'pakket' : '.pakket' );
  
      $pakket_homedir->is_dir
          or $pakket_homedir->mkpath;
  
      # FIXME: currently only bash support, what about csh/fish/zsh/Windows?
      my $shellfile = path( $pakket_homedir, 'pakket.sh' );
      $shellfile->spew(
          "export PAKKET_REPO=$repo_dir\n",
          "export PERL5LIB=$repo_dir/lib/perl5:\$PERL5LIB\n",
          "export LD_LIBRARY_PATH=$repo_dir/lib:\$LD_LIBRARY_PATH\n",
      );
  
      $log->info("Done. Please add $shellfile to your bashrc.");
  }
  
  1;
  
  __END__
PAKKET_CLI_COMMAND_INIT

$fatpacked{"Pakket/CLI/Command/install.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_INSTALL';
  package Pakket::CLI::Command::install;
  # ABSTRACT: Install a Pakket parcel
  
  use strict;
  use warnings;
  use Pakket::CLI '-command';
  use Pakket::Installer;
  use Pakket::Config;
  use Pakket::Log;
  use Pakket::Package;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  use Log::Any          qw< $log >;
  use Log::Any::Adapter;
  use Path::Tiny        qw< path >;
  
  sub abstract    { 'Install a package' }
  sub description { 'Install a package' }
  
  sub _determine_config {
      my ( $self, $opt ) = @_;
  
      # Read configuration
      my $config_file   = $opt->{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      my $config = $config_reader->read_config;
  
      # Default File backend
      if ( $opt->{'from'} ) {
          $config->{'repositories'}{'parcel'} = [
              'File', 'directory' => $opt->{'from'},
          ];
      }
  
      # Double check
      if ( !$config->{'repositories'}{'parcel'} ) {
          $self->usage_error(
              "Missing where to install from\n"
            . '(Create a configuration or use --from)',
          );
      }
  
      if ( $opt->{'to'} ) {
          $config->{'install_dir'} = $opt->{'to'};
      }
  
      if ( !$config->{'install_dir'} ) {
          $self->usage_error(
              "Missing where to install\n"
            . '(Create a configuration or use --to)',
          );
      }
  
      return $config;
  }
  
  sub _determine_packages {
      my ( $self, $opt, $args ) = @_;
  
      my @package_strs
          = defined $opt->{'input_file'}
          ? path( $opt->{'input_file'} )->lines_utf8( { 'chomp' => 1 } )
          : @{$args};
  
      my @packages;
      foreach my $package_str (@package_strs) {
          my ( $pkg_cat, $pkg_name, $pkg_version, $pkg_release ) =
              $package_str =~ PAKKET_PACKAGE_SPEC();
  
          push @packages, Pakket::Package->new(
              'category' => $pkg_cat,
              'name'     => $pkg_name,
              'version'  => $pkg_version // 0,
              'release'  => $pkg_release // 0,
          );
      }
  
      return \@packages;
  }
  
  sub opt_spec {
      return (
          [
              'to=s',
              'directory to install the package in',
          ],
          [
              'from=s',
              'directory to install the packages from',
          ],
          [ 'input-file=s',   'install everything listed in this file' ],
          [ 'config|c=s',     'configuration file' ],
          [ 'show-installed', 'print list of installed packages' ],
          [ 'ignore-failures', 'Continue even if some installs fail' ],
          [ 'force|f',        'force reinstall if package exists' ],
          [
              'verbose|v+',
              'verbose output (can be provided multiple times)',
              { 'default' => 1 },
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      $opt->{'config'}     = $self->_determine_config($opt);
      $opt->{'packages'}   = $self->_determine_packages( $opt, $args );
  
      $opt->{'config'}{'env'}{'cli'} = 1;
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      if ( $opt->{'show_installed'} ) {
          my $installer = _create_installer($opt);
          return $installer->show_installed();
      }
  
      my $installer = _create_installer($opt);
      return $installer->install( @{ $opt->{'packages'} } );
  }
  
  sub _create_installer {
      my $opt = shift;
  
      return Pakket::Installer->new(
          'config'          => $opt->{'config'},
          'pakket_dir'      => $opt->{'config'}{'install_dir'},
          'force'           => $opt->{'force'},
          'ignore_failures' => $opt->{'ignore_failures'},
      );
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      # Install the first release of a particular version
      # of the package "Dancer2" of the category "perl"
      $ pakket install perl/Dancer2=0.205000:1
  
      $ pakket install --help
  
          --to STR             directory to install the package in
          --from STR           directory to install the packages from
          --input-file STR     install everything listed in this file
          -c STR --config STR  configuration file
          --show-installed     print list of installed packages
          --ignore-failures    Continue even if some installs fail
          -f --force           force reinstall if package exists
          -v --verbose         verbose output (can be provided multiple times)
  
  =head1 DESCRIPTION
  
  Installing Pakket packages requires knowing the package names,
  including their category, their name, their version, and their release.
  If you do not provide a version or release, it will simply take the
  last one available.
  
  You can also show which packages are currently installed.
PAKKET_CLI_COMMAND_INSTALL

$fatpacked{"Pakket/CLI/Command/manage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_MANAGE';
  package Pakket::CLI::Command::manage;
  # ABSTRACT: The pakket manage command
  
  use strict;
  use warnings;
  
  use Path::Tiny qw< path  >;
  use Ref::Util  qw< is_arrayref is_coderef >;
  use Log::Any   qw< $log >; # to log
  use Log::Any::Adapter;     # to set the logger
  
  use Pakket::CLI '-command';
  use Pakket::Log;
  use Pakket::Config;
  use Pakket::Manager;
  use Pakket::PackageQuery;
  use Pakket::Utils::Repository qw< gen_repo_config >;
  use Pakket::Constants qw<
      PAKKET_PACKAGE_SPEC
      PAKKET_VALID_PHASES
  >;
  
  sub abstract    { 'Manage Pakket packages and repositories' }
  sub description { return <<'_END_DESC';
  This command manages Pakket packages across repositories.
  It allows you to add new specs, sources, and packages, as well
  as edit existing ones, and view your repositories.
  _END_DESC
  }
  
  my %commands = map +( $_ => 1 ), qw<
      add-package
      remove-package
      show-package
      remove-parcel
      add-deps
      remove-deps
      list-deps
      list-specs
      list-sources
      list-parcels
  >;
  
  sub opt_spec {
      return (
          [ 'cpanfile=s',   'cpanfile to configure from' ],
          [ 'spec-dir=s',   'directory to write the spec to (JSON files)' ],
          [ 'source-dir=s', 'directory to write the sources to (downloads if provided)' ],
          [ 'parcel-dir=s', 'directory where build output (parcels) are' ],
          [ 'cache-dir=s',  'directory to get sources from (optional)' ],
          [ 'additional-phase=s@',
            "additional phases to use ('develop' = author_requires, 'test' = test_requires). configure & runtime are done by default.",
          ],
          [ 'config|c=s',   'configuration file' ],
          [ 'verbose|v+',   'verbose output (can be provided multiple times)' ],
          [ 'phase=s',      '(deps) What phase is the dependency' ],
          [ 'on=s',         '(deps) What is the dependency on'    ],
          [ 'cpan-02packages=s', '02packages file (optional)'     ],
          [ 'no-deps',      'do not add dependencies (top-level only)' ],
          [ 'is-local=s@',  'do not use upstream sources (i.e. CPAN) for given packages' ],
          [ 'requires-only', 'do not set recommended/suggested dependencies' ],
          [ 'no-bootstrap',  'skip bootstrapping phase (toolchain packages)' ],
          [ 'source-archive=s', 'archve with sources (optional, only for native)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set(
          'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ),
      );
  
      $self->{'opt'}  = $opt;
      $self->{'args'} = $args;
  
      $self->_validate_arg_command;
      $self->_validate_arg_cache_dir;
      $self->_read_config;
  }
  
  sub execute {
      my $self = shift;
  
      my $command = $self->{'command'};
  
      my $is_local = +{
          map { $_ => 1 } @{ $self->{'opt'}{'is_local'} }
      };
  
      my $manager = Pakket::Manager->new(
          config          => $self->{'config'},
          cpanfile        => $self->{'cpanfile'},
          cache_dir       => $self->{'cache_dir'},
          phases          => $self->{'gen_phases'},
          package         => $self->{'package'},
          file_02packages => $self->{'file_02packages'},
          no_deps         => $self->{'opt'}{'no_deps'},
          requires_only   => $self->{'opt'}{'requires_only'},
          no_bootstrap    => $self->{'opt'}{'no_bootstrap'},
          is_local        => $is_local,
          source_archive  => $self->{'source_archive'},
      );
  
      my %actions = (
          'add-package'    => sub { $manager->add_package; },
          'remove-package' => sub {
              # TODO: check we are allowed to remove package (dependencies)
              $manager->remove_package('spec');
              $manager->remove_package('source');
          },
  
          'remove-parcel'  => sub {
              # TODO: check we are allowed to remove package (dependencies)
              $manager->remove_package('parcel');
          },
  
          'add-deps'       => sub {
              $manager->add_dependency( $self->{'dependency'} );
          },
  
          'remove-deps'    => sub {
              $manager->remove_dependency( $self->{'dependency'} );
          },
  
          'list-specs'     => sub { $manager->list_ids('spec'); },
          'list-sources'   => sub { $manager->list_ids('source'); },
          'list-parcels'   => sub { $manager->list_ids('parcel'); },
          'show-package'   => sub { $manager->show_package_config; },
          'list-deps'      => sub { $manager->show_package_deps; },
      );
  
      return $actions{$command}->();
  }
  
  sub _read_config {
      my $self = shift;
  
      my $config_file   = $self->{'opt'}{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      $self->{'config'} = $config_reader->read_config;
  
      $self->_validate_repos;
  }
  
  sub _validate_repos {
      my $self = shift;
  
      my %cmd2repo = (
          'add-package'    => [ 'spec', 'source' ],
          'remove-package' => [ 'spec', 'source' ],
          'remove-parcel'  => [ 'parcel' ],
          'show-package'   => [ 'spec'   ],
          'add-deps'       => [ 'spec'   ],
          'remove-deps'    => [ 'spec'   ],
          'list-deps'      => [ 'spec'   ],
          'list-specs'     => [ 'spec'   ],
          'list-parcels'   => [ 'parcel' ],
          'list-sources'   => [ 'source' ],
      );
  
      my $config  = $self->{'config'};
      my $command = $self->{'command'};
  
      my @required_repos = @{ $cmd2repo{$command} };
  
      my %repo_opt = (
          'spec'   => 'spec_dir',
          'source' => 'source_dir',
          'parcel' => 'parcel_dir',
      );
  
      for my $type ( @required_repos ) {
          my $opt_key   = $repo_opt{$type};
          my $directory = $self->{'opt'}{$opt_key};
          if ( $directory ) {
              my $repo_conf = $self->gen_repo_config( $type, $directory );
              $config->{'repositories'}{$type} = $repo_conf;
          }
          $config->{'repositories'}{$type}
              or $self->usage_error("Missing configuration for $type repository");
      }
  }
  
  sub _validate_arg_command {
      my $self     = shift;
      my @cmd_list = sort keys %commands;
  
      my $command = shift @{ $self->{'args'} }
          or $self->usage_error( "Must pick action (@{[ join '/', @cmd_list ]})" );
  
      $commands{$command}
          or $self->usage_error( "Wrong command (@{[ join '/', @cmd_list ]})" );
  
      $self->{'command'} = $command;
  
      $command eq 'add-package'    and $self->_validate_args_add;       # FIXME: Rename method
      $command eq 'remove-package' and $self->_validate_args_remove;    # FIXME: Rename method
      $command eq 'remove-parcel'  and $self->_validate_args_remove_parcel;
      $command eq 'list-deps'      and $self->_validate_args_show_deps; # FIXME: Rename method
      $command eq 'show-package'   and $self->_validate_args_show;      # FIXME: Rename method
  
      $command eq 'add-deps' || $command eq 'remove-deps'
         and $self->_validate_args_dependency;
  }
  
  sub _validate_arg_cache_dir {
      my $self = shift;
  
      my $cache_dir = $self->{'opt'}{'cache_dir'};
  
      if ( $cache_dir ) {
          path( $cache_dir )->exists
              or $self->usage_error( "cache-dir: $cache_dir doesn't exist\n" );
          $self->{'cache_dir'} = $cache_dir;
      }
      if ($self->{'opt'}{'is_local'} and !$self->{'cache_dir'}) {
          $self->usage_error( "Flag --is-local doesn't make sense without --cache-dir.\n".
                              "Please specify directory with sources --cache-dir.\n");
      }
  }
  
  sub _validate_args_add {
      my $self = shift;
  
      my $cpanfile = $self->{'opt'}{'cpanfile'};
      my $additional_phase = $self->{'opt'}{'additional_phase'};
  
      $self->{'file_02packages'} = $self->{'opt'}{'cpan_02packages'};
      $self->{'source_archive'}  = $self->{'opt'}{'source_archive'};
  
      if ( $cpanfile ) {
          @{ $self->{'args'} }
              and $self->usage_error( "You can't have both a 'package' and a 'cpanfile'\n" );
          $self->{'cpanfile'} = $cpanfile;
      } else {
          $self->_read_set_package_str;
      }
  
      # TODO: config ???
      $self->{'gen_phases'} = [qw< configure runtime >];
      if ( is_arrayref($additional_phase) ) {
          exists PAKKET_VALID_PHASES->{$_} or $self->usage_error( "Unsupported phase: $_" )
              for @{ $additional_phase };
          push @{ $self->{'gen_phases'} } => @{ $additional_phase };
      }
  }
  
  sub _validate_args_remove {
      my $self = shift;
      $self->_read_set_package_str;
  }
  
  sub _validate_args_remove_parcel {
      my $self = shift;
      $self->_read_set_package_str;
  }
  
  sub _validate_args_dependency {
      my $self = shift;
      my $opt  = $self->{'opt'};
  
      # package
      $self->_read_set_package_str;
  
      # pakket manage add-deps perl/Dancer2=0.9 --phase runtime --on perl/Moo=2
      defined $opt->{$_} or $self->usage_error("Missing argument $_")
          for qw< phase on >;
  
      my $dep = $self->_read_package_str( $opt->{'on'} );
  
      defined $dep->{'version'}
          or $self->usage_error( "Invalid dependency: missing version" );
  
      $dep->{'phase'}       = $opt->{'phase'}; # FIXME: Should be in instantiation above
      $self->{'dependency'} = $dep;
  }
  
  sub _validate_args_show {
      my $self = shift;
      $self->_read_set_package_str;
  }
  
  sub _validate_args_show_deps {
      my $self = shift;
      $self->_read_set_package_str;
  }
  
  sub _read_package_str {
      my ( $self, $spec_str ) = @_;
  
      my $package = Pakket::PackageQuery->new_from_string($spec_str);
  
      # add supported categories
      if ( !( $package->category eq 'perl' or $package->category eq 'native' ) ) {
          $self->usage_error( "Wrong 'name' format\n" );
      }
  
      return $package;
  }
  
  sub _read_set_package_str {
      my $self = shift;
  
      my $spec_str = shift @{ $self->{'args'} };
      $spec_str or $self->usage_error( "Must provide a package id (category/name=version:release)" );
  
      $self->{'package'} = $self->_read_package_str($spec_str);
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      $ pakket manage add-package perl/Dancer2=0.205000:1
      $ pakket manage show-package perl/Dancer2=0.205000:1
      $ pakket manage remove-package perl/Dancer2=0.205000:1
      $ pakket manage remove-parcel perl/Dancer2=0.205000:1
  
      $ pakket manage list-deps perl/Dancer2=0.205000:1
      $ pakket manage list-specs
      $ pakket manage list-sources
      $ pakket manage list-parcels
  
      $ pakket manage [-cv] [long options...]
  
  =head1 DESCRIPTION
  
  The C<manage> command does all management with the repositories. This
  includes listing, adding, and removing packages. It includes listing
  all information across repositories (specs, sources, parlces), as well
  as dependencies for any package.
PAKKET_CLI_COMMAND_MANAGE

$fatpacked{"Pakket/CLI/Command/run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_RUN';
  package Pakket::CLI::Command::run;
  # ABSTRACT: The pakket run command
  
  use strict;
  use warnings;
  use Pakket::CLI '-command';
  use Pakket::Runner;
  use Pakket::Log;
  use Log::Any::Adapter;
  use Path::Tiny qw< path >;
  
  sub abstract    { 'Run commands using pakket' }
  sub description { 'Run commands using pakket' }
  
  sub opt_spec {
      return (
          [
              'from=s',
              'defines pakket active directory to use. '
                  . '(mandatory, unless set in PAKKET_ACTIVE_PATH)',
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      my $active_path
          = exists $ENV{'PAKKET_ACTIVE_PATH'}
          ? $ENV{'PAKKET_ACTIVE_PATH'}
          : $opt->{'from'};
  
      $active_path
          or $self->usage_error('No active path provided');
  
      $opt->{'active_path'} = $active_path;
  }
  
  sub execute {
      my ( $self, $opt, $args ) = @_;
  
      my $runner = Pakket::Runner->new(
          'active_path' => $opt->{'active_path'},
      );
  
      exit $runner->run( @{$args} );
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      # Generate environment variables
      $ pakket run --from=/opt/pakket/
  
      # Run application directly
      $ pakekt run --from=/opt/pakket myscript.pl
  
  =head1 DESCRIPTION
  
  The runner allows you to either run your application in Pakket or set
  up environment variables so you could run your application later, not
  requiring the runner again.
PAKKET_CLI_COMMAND_RUN

$fatpacked{"Pakket/CLI/Command/serve.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_SERVE';
  package Pakket::CLI::Command::serve;
  # ABSTRACT: Serve Pakket objects over HTTP
  
  use strict;
  use warnings;
  
  use Path::Tiny      qw< path >;
  use Log::Any::Adapter;
  
  use Pakket::CLI '-command';
  use Pakket::Web::Server;
  use Pakket::Log;
  
  sub abstract    { 'Serve objects' }
  sub description { 'Serve objects' }
  
  sub opt_spec {
      return (
          [ 'port=s',     'port where server will listen', ],
          [ 'verbose|v+', 'verbose output (can be provided multiple times)' ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
      my $server = Pakket::Web::Server->new(
          # default main object
          map( +(
              defined $opt->{$_}
                  ? ( $_ => $opt->{$_} )
                  : ()
          ), qw< port > ),
      );
  
      $server->run();
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      $ pakket serve
      $ pakket serve --port 3000
  
  =head1 DESCRIPTION
  
  The C<serve> command allows you to start a web server for Pakket. It is
  highly configurable and can serve any amount of repositories of all
  kinds.
  
  It will load one of following files in the following order:
  
  =over 4
  
  =item * C<PAKKET_WEB_CONFIG> environment variable (to a filename)
  
  =item * C<~/.pakket-web.json>
  
  =item * C</etc/pakket-web.json>
  
  =back
  
  =head2 Configuration example
  
      $ cat ~/.pakket-web.json
  
      {
          "repositories" : [
              {
                  "type" : "Spec",
                  "path" : "/pakket/spec"
                  "backend" : [
                      "HTTP",
                      "host", "pakket.mydomain.com",
                      "port", 80
                  ]
              },
              {
                  "type" : "Source",
                  "path" : "/pakket/source",
                  "backend" : [
                      "File",
                      "directory", "/mnt/pakket-sources"
                  ],
              },
  
              ...
          ]
      }
PAKKET_CLI_COMMAND_SERVE

$fatpacked{"Pakket/CLI/Command/uninstall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CLI_COMMAND_UNINSTALL';
  package Pakket::CLI::Command::uninstall;
  
  # ABSTRACT: The pakket uninstall command
  
  use strict;
  use warnings;
  
  use Log::Any qw< $log >;
  use Log::Any::Adapter;
  use IO::Prompt::Tiny qw< prompt >;
  use Path::Tiny qw< path >;
  
  use Pakket::CLI '-command';
  use Pakket::Config;
  use Pakket::Uninstaller;
  use Pakket::Log;
  use Pakket::Package;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  
  sub abstract    {'Uninstall a package'}
  sub description {'Uninstall a package'}
  
  sub _determine_packages {
      my ( $self, $opt, $args ) = @_;
  
      my @package_strs
          = defined $opt->{'input_file'}
          ? path( $opt->{'input_file'} )->lines_utf8( { 'chomp' => 1 } )
          : @{$args};
  
      my @packages;
      foreach my $package_str (@package_strs) {
          my ( $pkg_cat, $pkg_name ) = $package_str =~ PAKKET_PACKAGE_SPEC();
  
          if ( !$pkg_cat || !$pkg_name ) {
              die $log->critical(
                  "Can't parse $package_str. Use format category/package_name");
          }
  
          push @packages, { 'category' => $pkg_cat, 'name' => $pkg_name };
      }
  
      return \@packages;
  }
  
  sub _determine_config {
      my ( $self, $opt ) = @_;
  
      # Read configuration
      my $config_file   = $opt->{'config'};
      my $config_reader = Pakket::Config->new(
          $config_file ? ( 'files' => [$config_file] ) : (),
      );
  
      my $config = $config_reader->read_config;
  
      if ( $opt->{'pakket_dir'} ) {
          $config->{'install_dir'} = $opt->{'pakket_dir'};
      }
  
      if ( !$config->{'install_dir'} ) {
          $self->usage_error(
              "please define the library dir --pakket-dir <path_to_library>\n"
          );
      }
  
      path($config->{'install_dir'})->exists
          or $self->usage_error( sprintf(
              "Library dir: %s doesn't exist\n", $config->{'install_dir'}));
  
      return $config;
  }
  
  sub opt_spec {
      return (
          [ 'pakket-dir=s',         'path where installed pakket' ],
          [ 'input-file=s',         'uninstall everything listed in this file' ],
          [ 'without-dependencies', 'don\'t remove dependencies' ],
          [
              'verbose|v+',
              'verbose output (can be provided multiple times)',
              { 'default' => 1 },
          ],
      );
  }
  
  sub validate_args {
      my ( $self, $opt, $args ) = @_;
  
      Log::Any::Adapter->set( 'Dispatch',
          'dispatcher' => Pakket::Log->build_logger( $opt->{'verbose'} ) );
  
      $opt->{'config'}   = $self->_determine_config($opt);
      $opt->{'packages'} = $self->_determine_packages( $opt, $args );
  }
  
  sub execute {
      my ( $self, $opt ) = @_;
  
      my $uninstaller = Pakket::Uninstaller->new(
          'pakket_dir'           => $opt->{'config'}{'install_dir'},
          'packages'             => $opt->{'packages'},
          'without_dependencies' => $opt->{'without_dependencies'},
      );
  
      my @packages_for_uninstall
          = $uninstaller->get_list_of_packages_for_uninstall();
  
      print "We are going to remove:\n";
      for my $package (@packages_for_uninstall) {
          print "* $package->{category}/$package->{name}\n";
      }
  
      my $answer = prompt( 'Continue?', 'y' );
  
      lc $answer eq 'y'
          and $uninstaller->uninstall();
  
      return;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      $ pakket uninstall perl/Dancer2
  
  =head1 DESCRIPTION
  
  Uninstall a given package.
PAKKET_CLI_COMMAND_UNINSTALL

$fatpacked{"Pakket/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CONFIG';
  package Pakket::Config;
  # ABSTRACT: Read and represent Pakket configurations
  
  use Moose;
  use MooseX::StrictConstructor;
  use Config::Any;
  use Path::Tiny        qw< path >;
  use Types::Path::Tiny qw< Path >;
  use Log::Any          qw< $log >;
  use Carp              qw< croak >;
  
  has 'paths' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub { return ['~/.pakket', '/etc/pakket'] },
  );
  
  has 'extensions' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub { return [qw< json yaml yml conf cfg >] },
  );
  
  has 'files' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          if ( $ENV{'PAKKET_CONFIG_FILE'} ) {
              return [ $ENV{'PAKKET_CONFIG_FILE'} ];
          }
  
          my %files;
          foreach my $path ( @{ $self->{'paths'} } ) {
              foreach my $extension ( @{ $self->{'extensions'} } ) {
                  my $file = path("$path.$extension");
  
                  $file->exists
                      or next;
  
                  $files{$path}
                      and croak $log->criticalf(
                      'Multiple extensions for same config file name: %s and %s',
                      $files{$path}, $file
                      );
  
                  $files{$path} = $file;
              }
  
              # We found a file in order of precedence
              # so we return it
              $files{$path}
                  and return [ $files{$path} ];
          }
  
          # Could not find any files
          return [];
      },
  );
  
  sub read_config {
      my $self   = shift;
  
      @{ $self->files }
          or return {};
  
      my $config = Config::Any->load_files({
          'files'   => $self->files,
          'use_ext' => 1,
      });
  
      my %cfg;
      foreach my $config_chunk ( @{$config} ) {
          foreach my $filename ( keys %{$config_chunk} ) {
              my %config_part = %{ $config_chunk->{$filename} };
              @cfg{ keys(%config_part) } = values %config_part;
              $log->info("Using config file $filename");
          }
      }
  
      return \%cfg;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
  
  __END__
  
  =pod
PAKKET_CONFIG

$fatpacked{"Pakket/Constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_CONSTANTS';
  package Pakket::Constants; ## no critic (Subroutines::ProhibitExportingUndeclaredSubs)
  # ABSTRACT: Constants used in Pakket
  
  use strict;
  use warnings;
  use parent 'Exporter';
  
  use constant {
      'PARCEL_EXTENSION'     => 'pkt',
      'PARCEL_FILES_DIR'     => 'files',
      'PARCEL_METADATA_FILE' => 'meta.json',
  
      # CATEGORY/PACKAGE                 == latest version, latest release
      # CATEGORY/PACKAGE=VERSION         == Exact version, latest release
      # CATEGORY/PACKAGE=VERSION:RELEASE == Exact version and release
      'PAKKET_PACKAGE_SPEC'  => qr{
          ^
          ( [^/]+ )       # category
          /
          ( [^=]+ )       # name
          (?:
              =
              ( [^:]+ )   # optional version
              (?:
                  :
                  (.*)    # optional release
              )?
          )?
          $
      }xms,
  
      'PAKKET_DEFAULT_RELEASE' => 1,
      'PAKKET_INFO_FILE'       => 'info.json',
      'PAKKET_VALID_PHASES'    => {
          'configure' => 1,
          'develop'   => 1,
          'runtime'   => 1,
          'test'      => 1,
      },
  };
  
  our @EXPORT_OK = qw<
      PARCEL_EXTENSION
      PARCEL_FILES_DIR
      PARCEL_METADATA_FILE
      PAKKET_PACKAGE_SPEC
      PAKKET_DEFAULT_RELEASE
      PAKKET_INFO_FILE
      PAKKET_VALID_PHASES
  >;
  
  1;
PAKKET_CONSTANTS

$fatpacked{"Pakket/Installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_INSTALLER';
  package Pakket::Installer;
  # ABSTRACT: Install pakket packages into an installation directory
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp                  qw< croak >;
  use Path::Tiny            qw< path  >;
  use Types::Path::Tiny     qw< Path  >;
  use File::Copy::Recursive qw< dircopy >;
  use Time::HiRes           qw< time >;
  use Log::Any              qw< $log >;
  use JSON::MaybeXS         qw< decode_json >;
  use Archive::Any;
  use English               qw< -no_match_vars >;
  
  use Pakket::Repository::Parcel;
  use Pakket::Package;
  use Pakket::PackageQuery;
  use Pakket::Log       qw< log_success log_fail >;
  use Pakket::Types     qw< PakketRepositoryBackend >;
  use Pakket::Utils     qw< is_writeable >;
  use Pakket::Constants qw<
      PARCEL_METADATA_FILE
      PARCEL_FILES_DIR
  >;
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasParcelRepo
      Pakket::Role::HasInfoFile
      Pakket::Role::HasLibDir
      Pakket::Role::RunCommand
  >;
  
  has 'force' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has 'requirements' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'ignore_failures' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has 'installed_packages' => (
      'is'      => 'rw',
      'isa'     => 'HashRef',
      # Don't load installed_packages in constuctor.
      # Installer is also used by Builder,
      # which doesn't have installed_packages
      'default' => sub { +{} },
  );
  
  sub install {
      my ( $self, @packages ) = @_;
  
      if ( !@packages ) {
          $log->notice('Did not receive any parcels to deliver');
          return;
      }
  
      @packages = $self->set_latest_version_for_undefined(@packages);
  
      foreach (@packages) { $self->requirements->{$_->short_name} = $_ };
  
      $self->installed_packages($self->load_installed_packages($self->active_dir));
  
      if ( !$self->force ) {
          @packages = $self->drop_installed_packages(@packages);
          @packages or return;
      }
  
      my $installer_cache = {};
  
      foreach my $package (@packages) {
          eval {
              $self->install_package(
                  $package,
                  $self->work_dir,
                  { 'cache' => $installer_cache }
              );
              1;
          } or do {
              $self->ignore_failures or die $@;
              $log->warnf( 'Failed to install %s, skipping', $package->full_name);
          };
      }
  
      $self->activate_work_dir;
  
      $log->infof(
          "Finished installing %d packages into '%s'",
          scalar keys %{$installer_cache}, $self->pakket_dir,
      );
  
      log_success( 'Finished installing: ' . join ', ',
          map $_->full_name, @packages );
  
      $self->remove_old_libraries;
  
      return;
  }
  
  sub try_to_install_package {
      my ( $self, $package, $dir, $opts ) = @_;
  
      $log->debugf( 'Trying to install %s', $package->full_name );
  
      # First we check whether a package exists, because if not
      # we wil throw a silly critical warning about it
      # This can also speed stuff up, but maybe should be put into
      # "has_package" wrapper function... -- SX
      $self->parcel_repo->has_object( $package->id )
          or return;
  
      eval {
          $self->install_package( $package, $dir, $opts );
          1;
      } or do {
          $log->debugf( 'Could not install %s', $package->full_name );
          return;
      };
  
      return 1;
  }
  
  sub install_package {
      my ( $self, $package, $dir, $opts ) = @_;
      my $installer_cache = $opts->{'cache'};
  
      pre_install_checks($dir, $package, $opts);
  
      $log->debugf( "About to install %s (into $dir)", $package->full_name );
  
      $self->is_installed($installer_cache, $package)
          and return;
  
      mark_as_installed($installer_cache, $package);
  
      my $parcel_dir
          = $self->parcel_repo->retrieve_package_parcel($package);
  
      my $full_parcel_dir = $parcel_dir->child( PARCEL_FILES_DIR() );
  
      # Get the spec and create a new Package object
      # This one will have the dependencies as well
      my $spec_file    = $full_parcel_dir->child( PARCEL_METADATA_FILE() );
      my $spec         = decode_json $spec_file->slurp_utf8;
      my $full_package = Pakket::Package->new_from_spec($spec);
  
      my $prereqs = $full_package->prereqs;
      foreach my $prereq_category ( keys %{$prereqs} ) {
          my $runtime_prereqs = $prereqs->{$prereq_category}{'runtime'};
  
          foreach my $prereq_name ( keys %{$runtime_prereqs} ) {
              my $prereq_data = $runtime_prereqs->{$prereq_name};
  
              $self->install_prereq(
                  $prereq_category,
                  $prereq_name,
                  $prereq_data,
                  $dir,
                  $opts,
              );
          }
      }
  
      copy_package_to_install_dir($full_parcel_dir, $dir);
  
      $self->add_package_in_info_file( $parcel_dir, $dir, $full_package, $opts );
  
      log_success( sprintf 'Delivering parcel %s', $full_package->full_name );
  
      return;
  }
  
  sub install_prereq {
      my ($self, $category, $name, $prereq_data, $dir, $opts) = @_;
      my $package;
      if (exists $self->requirements->{"$category/$name"}) {
          $package = $self->requirements->{"$category/$name"};
          # FIXME: should we check compatibility
          # requested by user version of package
          # with dependencies requirements?
          # if yes, should we disable it by option --force?
      } else {
          # FIXME: This should be removed when we introduce version ranges
          # This forces us to install the latest version we have of
          # something, instead of finding the latest, based on the
          # version range, which "$prereq_version" contains. -- SX
          my $ver_rel = $self->parcel_repo->latest_version_release(
                      $category,
                      $name,
                      $prereq_data->{'version'},
                  );
  
          my ( $version, $release ) = @{$ver_rel};
  
          $package = Pakket::PackageQuery->new(
                  'category' => $category,
                  'name'     => $name,
                  'version'  => $version,
                  'release'  => $release,
                  );
      }
  
      $self->install_package(
          $package, $dir,
          { %{$opts}, 'as_prereq' => 1 },
      );
  }
  
  sub copy_package_to_install_dir {
      my ($full_parcel_dir, $dir) = @_;
      foreach my $item ( $full_parcel_dir->children ) {
          my $basename = $item->basename;
  
          $basename eq PARCEL_METADATA_FILE()
              and next;
  
          my $target_dir = $dir->child($basename);
          local $File::Copy::Recursive::RMTrgFil = 1;
          dircopy($item, $target_dir)
              or croak($log->criticalf("Can't copy $item to $target_dir ($!)"));
      }
  }
  
  sub is_installed {
      my ($self, $installer_cache, $package) = @_;
  
      if ($self->installed_packages->{$package->full_name}) {
          $log->infof( '%s already installed', $package->full_name );
          return 1;
      }
  
      my $pkg_cat  = $package->category;
      my $pkg_name = $package->name;
  
      if ( defined $installer_cache->{$pkg_cat}{$pkg_name} ) {
          my $ver_rel = $installer_cache->{$pkg_cat}{$pkg_name};
          my ( $version, $release ) = @{$ver_rel};
  
          # Check version
          if ( $version ne $package->version ) {
              croak( $log->criticalf(
                  "%s=$version already installed. "
                . "Cannot install new version: %s",
                $package->short_name,
                $package->version,
              ) );
          }
  
          # Check release
          if ( $release ne $package->release ) {
              croak( $log->criticalf(
                  '%s=%s:%s already installed. '
                . 'Cannot install new version: %s:%s',
                  $package->short_name,
                  $version, $release,
                  $package->release,
              ) );
          }
  
          $log->debugf( '%s already installed.', $package->full_name );
  
          return 1;
      }
  
      return 0;
  }
  
  sub mark_as_installed {
      my ($installer_cache, $package) = @_;
  
      my $pkg_cat  = $package->category;
      my $pkg_name = $package->name;
  
      $installer_cache->{$pkg_cat}{$pkg_name} = [
          $package->version, $package->release,
      ];
  }
  
  sub pre_install_checks {
      my ($dir, $package, $opts) = @_;
  
      # Are we in a regular (non-bootstrap) mode?
      # Are we using a bootstrap version of a package?
      if ( ! $opts->{'skip_prereqs'} && $package->is_bootstrap ) {
          croak( $log->critical(
              'You are trying to install a bootstrap version of %s.'
            . ' Please rebuild this package from scratch.',
              $package->full_name,
          ) );
      }
  
      if ( !is_writeable($dir) ) {
          croak( $log->critical(
              "Can't write to your installation directory ($dir)",
          ) );
      }
  }
  
  sub show_installed {
      my $self = shift;
      my $installed_packages = $self->load_installed_packages($self->active_dir);
      print join("\n", sort keys %{$installed_packages} ) . "\n";
  }
  
  sub drop_installed_packages {
      my $self = shift;
      my @packages = @_;
      my @out;
      for my $package (@packages) {
          if ($self->installed_packages->{$package->full_name}) {
              $log->infof( '%s already installed', $package->full_name );
          } else {
              push @out, $package;
          }
      }
      return @out;
  }
  
  sub set_latest_version_for_undefined {
      my $self      = shift;
      my @packages  = @_;
  
      my @output;
      for my $package (@packages) {
          if ($package->version && $package->release) {
              push @output, $package;
          } else {
              my $ver_condition = $package->version
                  ? "== " . $package->version
                  : ">= 0";
  
              my ($ver, $rel) = @{$self->parcel_repo->latest_version_release(
                                      $package->category, $package->name, $ver_condition)};
  
              push @output, Pakket::Package->new(
                                  'category' => $package->category,
                                  'name'     => $package->name,
                                  'version'  => $ver,
                                  'release'  => $rel,
                              );
          }
      }
      return @output;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 config
  
  See L<Pakket::Role::HasConfig>.
  
  =head2 parcel_repo
  
  See L<Pakket::Role::HasParcelRepo>.
  
  =head2 parcel_repo_backend
  
  See L<Pakket::Role::HasParcelRepo>.
  
  =head2 requirements
  
  List in hashref built during install of additional requirements.
  
  =head2 force
  
  A boolean to install packages even if they are already installed.
  
  =head2 pakket_dir
  
  See L<Pakket::Role::HasLibDir>.
  
  =head2 libraries_dir
  
  See L<Pakket::Role::HasLibDir>.
  
  =head2 active_dir
  
  See L<Pakket::Role::HasLibDir>.
  
  =head2 work_dir
  
  See L<Pakket::Role::HasLibDir>.
  
  =head1 METHODS
  
  =head2 activate_work_dir
  
  See L<Pakket::Role::HasLibDir>.
  
  =head2 remove_old_libraries
  
  See L<Pakket::Role::HasLibDir>.
  
  =head2 add_package_in_info_file
  
  See L<Pakket::Role::HasInfoFile>.
  
  =head2 load_info_file
  
  See L<Pakket::Role::HasInfoFile>.
  
  =head2 save_info_file
  
  See L<Pakket::Role::HasInfoFile>.
  
  =head2 load_installed_packages
  
  See L<Pakket::Role::HasInfoFile>.
  
  =head2 install(@packages)
  
  The main method used to install packages.
  
  Installs all packages and then turns on the active directory link.
  
  =head2 try_to_install_package($package, $dir, \%opts)
  
  Attempts to install a package while reporting failure. This is useful
  when it is possible to install but might not work. It is used by the
  L<Pakket::Builder> to install all possible available pre-built
  packages.
  
  =head2 install_package($package, $dir, \%opts)
  
  The guts of installing a package. This is used by C<install> and
  C<try_to_install_package>.
  
  =head2 install_prereq($category, $name, \%prereq_data, $dir, \%opts)
  
  Takes a prereq from a package, finds the matching package and installs
  it.
  
  =head2 copy_package_to_install_dir($source_dir, $target_dir)
  
  Recursively copy all the package directories and files to the install
  directory.
  
  =head2 is_installed(\%installer_cache, $package)
  
  Check whether the package is already installed or not using our
  installer cache.
  
  =head2 mark_as_installed(\%installer_cache, $package)
  
  Add to cache as installed.
  
  =head2 pre_install_checks($dir, $package, \%opts)
  
  Perform all the checks for the installation phase.
  
  =head2 show_installed()
  
  Display all the installed packages. This is helpful for debugging.
  
  =head2 drop_installed_packages(@packages)
  
  Removes installed packages from a list of given packages.
  
  =head2 run_command
  
  See L<Pakket::Role::RunCommad>.
  
  =head2 run_command_sequence
  
  See L<Pakket::Role::RunCommad>.
PAKKET_INSTALLER

$fatpacked{"Pakket/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_LOG';
  package Pakket::Log;
  # ABSTRACT: A logger for Pakket
  
  use strict;
  use warnings;
  use parent 'Exporter';
  use Log::Dispatch;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  use Term::GentooFunctions qw< ebegin eend >;
  
  use constant {
      'DEBUG_LOG_LEVEL'    => 3,
      'DEBUG_INFO_LEVEL'   => 2,
      'DEBUG_NOTICE_LEVEL' => 1,
  
      'TERM_SIZE_MAX'     => 80,
      'TERM_EXTRA_SPACES' => ( length(' * ') + length(' [ ok ]') ),
  };
  
  # Just so I remember it:
  # 1  fatal     system unusable, aborts program!
  # 2  alert     failure in primary system
  # 3  critical  failure in backup system
  # 4  error     non-urgent program errors, a bug
  # 5  warning   possible problem, not necessarily error
  # 6  notice    unusual conditions
  # 7  info      normal messages, no action required
  # 8  debug     debugging messages for development
  # 9  trace     copious tracing output
  
  our @EXPORT_OK = qw< log_success log_fail >; ## no critic qw(Modules::ProhibitAutomaticExportation)
  
  sub _extra_spaces {
      my $msg = shift;
      return abs( TERM_SIZE_MAX() - ( length($msg) + TERM_EXTRA_SPACES() ) );
  }
  
  sub _log_to_outputs {
      my ( $msg, $status ) = @_;
      my $status_output = $status ? ' [ ok ]' : ' [ !! ]';
      my @log_outputs   = $log->adapter->{'dispatcher'}->outputs;
  
      foreach my $output (@log_outputs) {
          if ( ref($output) =~ m{^Log::Dispatch::Screen}xms ) {
              ebegin $msg;
              eend 1;
              next;
          }
  
          my $level   = $status ? 'info' : 'error';
          my $message = " * $msg" . ' ' x _extra_spaces($msg) . $status_output;
  
          $output->log(
              'level'   => $level,
              'message' => $message,
          );
      }
  
      return $msg;
  }
  
  sub log_success {
      my $msg = shift;
      return _log_to_outputs( $msg, 1 );
  }
  
  sub log_fail {
      my $msg = shift;
      return _log_to_outputs( $msg, 0 );
  }
  
  sub arg_default_logger {
      return $_[1] || Log::Dispatch->new(
          'outputs' => [
              [
                  'Screen',
                  'min_level' => 'notice',
                  'newline'   => 1,
              ],
          ],
      );
  }
  
  sub build_logger {
      my ( $class, $verbose, $file ) = @_;
      my $logger = Log::Dispatch->new(
          'outputs' => [
              $class->_build_logger($file),
              $class->_cli_logger( $verbose // 1 ),
          ],
      );
  
      return $logger;
  }
  
  sub _build_logger {
      my ($class, $file) = @_;
  
      if (!$file) {
          my $dir = Path::Tiny::path('~/.pakket');
          eval {
              $dir->mkpath;
              1;
          } or do {
              die "Can't create directory $dir : " . $!;
          };
  
          $file = $dir->child("pakket.log")->stringify;
      }
  
      return [
          'File',
          'min_level' => 'debug',
          'filename'  => $file,
          'newline'   => 1,
      ];
  }
  
  sub cli_logger {
      my ( $class, $verbose ) = @_;
  
      my $logger = Log::Dispatch->new(
          'outputs' => [ $class->_cli_logger($verbose) ],
      );
  
      return $logger;
  }
  
  sub _cli_logger {
      my ( $class, $verbose ) = @_;
  
      $verbose ||= 0;
  
      my $screen_level =
          $verbose >= +DEBUG_LOG_LEVEL    ? 'debug'  : # log 2
          $verbose == +DEBUG_INFO_LEVEL   ? 'info'   : # log 1
          $verbose == +DEBUG_NOTICE_LEVEL ? 'notice' : # log 0
                                            'warning';
      return [
          'Screen::Gentoo',
          'min_level' => $screen_level,
          'newline'   => 1,
          'utf8'      => 1,
      ];
  }
  
  1;
  
  __END__
PAKKET_LOG

$fatpacked{"Pakket/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_MANAGER';
  package Pakket::Manager;
  # ABSTRACT: Manage pakket packages and repos
  
  use Moose;
  use Log::Any qw< $log >;
  use Carp     qw< croak >;
  use Safe::Isa;
  
  use Pakket::Log;
  use Pakket::Scaffolder::Native;
  use Pakket::Scaffolder::Perl;
  
  has 'config' => (
      'is'        => 'ro',
      'isa'       => 'HashRef',
      'default'   => sub { +{} },
  );
  
  has 'category' => (
      'is'        => 'ro',
      'isa'       => 'Str',
      'lazy'      => 1,
      'builder'   => '_build_category',
  );
  
  has 'cache_dir' => (
      'is'        => 'ro',
      'isa'       => 'Maybe[Str]',
  );
  
  has 'cpanfile' => (
      'is'        => 'ro',
      'isa'       => 'Maybe[Str]',
  );
  
  has 'package' => (
      'is'        => 'ro',
  );
  
  has 'phases' => (
      'is'        => 'ro',
      'isa'       => 'Maybe[ArrayRef]',
  );
  
  has 'file_02packages' => (
      'is'        => 'ro',
      'isa'       => 'Maybe[Str]',
  );
  
  has 'no_deps' => (
      'is'        => 'ro',
      'isa'       => 'Bool',
      'default'   => 0,
  );
  
  has 'is_local' => (
      'is'        => 'ro',
      'isa'       => 'HashRef',
      'default'   => sub { +{} },
  );
  
  has 'requires_only' => (
      'is'        => 'ro',
      'isa'       => 'Bool',
      'default'   => 0,
  );
  
  has 'no_bootstrap' => (
      'is'        => 'ro',
      'isa'       => 'Bool',
      'default'   => 0,
  );
  
  has 'source_archive' => (
      'is'        => 'ro',
      'isa'       => 'Maybe[Str]',
  );
  
  sub _build_category {
      my $self = shift;
      $self->{'cpanfile'} and return 'perl';
      return $self->package->category;
  }
  
  sub list_ids {
      my ( $self, $type ) = @_;
      my $repo = $self->_get_repo($type);
      print "$_\n" for sort @{ $repo->all_object_ids };
  }
  
  sub show_package_config {
      my $self = shift;
      my $repo = $self->_get_repo('spec');
      my $spec = $repo->retrieve_package_spec( $self->package );
  
      my ( $category, $name, $version, $release ) =
          @{ $spec->{'Package'} }{qw< category name version release >};
  
      print <<"SHOW";
  
  # PACKAGE:
  
  category: $category
  name:     $name
  version:  $version
  release:  $release
  
  # DEPENDENCIES:
  
  SHOW
  
      for my $c ( sort keys %{ $spec->{'Prereqs'} } ) {
          for my $p ( sort keys %{ $spec->{'Prereqs'}{$c} } ) {
              print "$c/$p:\n";
              for my $n ( sort keys %{ $spec->{'Prereqs'}{$c}{$p} } ) {
                  my $v = $spec->{'Prereqs'}{$c}{$p}{$n}{'version'};
                  print "- $n-$v\n";
              }
              print "\n";
          }
      }
  
      if ($spec->{'build_opts'}) {
          print "build options:\n";
          if ($spec->{'build_opts'}{'configure_flags'}) {
              print "    configure flags:\n";
              for my $flag (@{$spec->{'build_opts'}{'configure_flags'}}) {
                  print "        $flag\n";
              }
          }
          if ($spec->{'build_opts'}{'build_flags'}) {
              print "    build flags:\n";
              for my $flag (@{$spec->{'build_opts'}{'build_flags'}}) {
                  print "        $flag\n";
              }
          }
          if ($spec->{'build_opts'}{'env_vars'}) {
              print "    env vars:\n";
              for my $var (keys %{$spec->{'build_opts'}{'env_vars'}}) {
                  my $value = $spec->{'build_opts'}{'env_vars'}{$var};
                  print "        $var=$value\n";
              }
          }
          print "\n";
      }
  
      # TODO: reverse dependencies (requires map)
  }
  
  sub show_package_deps {
      my $self = shift;
  
      my $SPACES = "  ";
      my @queue = ({package => $self->package, level => 0});
      my $repo = $self->_get_repo('spec');
      my %seen;
      while (0+@queue) {
          my $entry = pop @queue;
          my $spaces = $SPACES x $entry->{'level'};
  
          # text entry: configure or runtime
          if ( my $type = $entry->{'type'} ) {
              print $spaces ."$type:\n";
              next;
          }
  
          my $package = $entry->{'package'};
          my $exists = $seen{$package->short_name} ? " (exists)" : "" ;
          print $spaces . $package->id . "$exists\n";
  
          $exists and next;
  
          $seen{$package->short_name}=1;
          my @deps;
          my $level = $entry->{'level'} + 1;
          my $spec = $repo->retrieve_package_spec( $package );
          my $prereq = $spec->{'Prereqs'};
          for my $category (sort keys %$prereq) {
              for my $type (sort keys %{$prereq->{$category}}) {
                  unshift @deps, {'level'=> $level,'type'=>$type};
                  for my $name (sort keys %{$prereq->{$category}{$type}}) {
                      my $req_ver = $prereq->{$category}{$type}{$name}{'version'};
  
                      my $ver_rel = $repo->latest_version_release(
                                              $category, $name, $req_ver);
  
                      my ( $version, $release ) = @{$ver_rel};
  
                      my $req = Pakket::PackageQuery->new(
                                      'category' => $category,
                                      'name'     => $name,
                                      'version'  => $version,
                                      'release'  => $release,
                                  );
                      unshift @deps, {'level'=> $level+1, 'package'=>$req};
                  }
              }
          }
  
          push @queue, @deps;
      }
  }
  
  sub add_package {
      my $self = shift;
      my $errors = $self->_get_scaffolder->run;
      $errors && exit(1);
  }
  
  sub remove_package {
      my ( $self, $type ) = @_;
      my $repo = $self->_get_repo( $type );
      $repo->remove_package_file( $type, $self->package );
      $log->info( sprintf("Removed %s from the %s repo.", $self->package->id, $type ) );
  }
  
  sub add_dependency {
      my ( $self, $dependency ) = @_;
      $self->_package_dependency_edit($dependency, 'add');
  }
  
  sub remove_dependency {
      my ( $self, $dependency ) = @_;
      $self->_package_dependency_edit($dependency, 'remove');
  }
  
  sub _package_dependency_edit {
      my ( $self, $dependency, $cmd ) = @_;
      my $repo = $self->_get_repo('spec');
      my $spec = $repo->retrieve_package_spec( $self->package );
  
      my $dep_name    = $dependency->{'name'};
      my $dep_version = $dependency->{'version'};
  
      my ( $category, $phase ) = @{$dependency}{qw< category phase >};
  
      my $dep_exists = ( defined $spec->{'Prereqs'}{$category}{$phase}{$dep_name} );
  
      my $name = $self->package->name;
  
      if ( $cmd eq 'add' ) {
          if ( $dep_exists ) {
              $log->info( sprintf("%s is already a %s dependency for %s.",
                                  $dep_name, $phase, $name) );
              exit 1;
          }
  
          $spec->{'Prereqs'}{$category}{$phase}{$dep_name} = +{
              version => $dep_version
          };
  
          $log->info( sprintf("Added %s as %s dependency for %s.",
                              $dep_name, $phase, $name) );
  
      } elsif ( $cmd eq 'remove' ) {
          if ( !$dep_exists ) {
              $log->info( sprintf("%s is not a %s dependency for %s.",
                                  $dep_name, $phase, $name) );
              exit 1;
          }
  
          delete $spec->{'Prereqs'}{$category}{$phase}{$dep_name};
  
          $log->info( sprintf("Removed %s as %s dependency for %s.",
                              $dep_name, $phase, $name) );
      }
  
      $repo->store_package_spec($self->package, $spec);
  }
  
  sub _get_repo {
      my ( $self, $key ) = @_;
      my $class = 'Pakket::Repository::' . ucfirst($key);
      return $class->new(
          'backend' => $self->config->{'repositories'}{$key},
      );
  }
  
  sub _get_scaffolder {
      my $self = shift;
  
      $self->category eq 'perl'
          and return $self->_gen_scaffolder_perl;
      $self->category eq 'native'
          and return $self->_gen_scaffolder_native;
  
      croak("Scaffolder for category " . $self->category . " doesn't exist");
  }
  
  sub _gen_scaffolder_perl {
      my $self = shift;
  
      my %params = (
          'config'   => $self->config,
          'phases'   => $self->phases,
          'no_deps'  => $self->no_deps,
          'is_local' => $self->is_local,
          ( 'types'  => ['requires'] )x!! $self->requires_only,
      );
  
      if ( $self->cpanfile ) {
          $params{'cpanfile'} = $self->cpanfile;
      } else {
          $params{'module'} = $self->package;
      }
  
      $self->cache_dir
          and $params{'cache_dir'} = $self->cache_dir;
  
      $self->file_02packages
          and $params{'file_02packages'} = $self->file_02packages;
  
      $self->no_bootstrap
          and $params{'no_bootstrap'} = $self->no_bootstrap;
  
      return Pakket::Scaffolder::Perl->new(%params);
  }
  
  sub _gen_scaffolder_native {
      my $self = shift;
  
      my $name = $self->package->name;
      my $version = $self->package->version;
  
      my %params = (
          'package'         => $self->package,
          'source_archive'  => $self->source_archive,
          'config'          => $self->config,
      );
  
      return Pakket::Scaffolder::Native->new(%params);
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_MANAGER

$fatpacked{"Pakket/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_PACKAGE';
  package Pakket::Package;
  # ABSTRACT: An object representing a package
  
  use Moose;
  use MooseX::StrictConstructor;
  use Pakket::Types;
  use Pakket::Constants qw< PAKKET_DEFAULT_RELEASE >;
  use JSON::MaybeXS qw< decode_json >;
  use version 0.77;
  
  with qw< Pakket::Role::BasicPackageAttrs >;
  
  has [ qw< name category version release > ] => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'is_bootstrap' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  has [qw<build_opts bundle_opts>] => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { return +{} },
  );
  
  # FIXME: GH #73 will make this more reasonable
  has 'configure_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_configure_prereqs',
  );
  
  has 'test_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_test_prereqs',
  );
  
  has 'runtime_prereqs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_runtime_prereqs',
  );
  
  sub BUILDARGS {
      my ( $class, %args ) = @_;
      if ($args{'category'} eq 'perl') {
          my $ver = version->new($args{'version'});
          if ($ver->is_qv) {$ver = version->new($ver->normal)};
          $args{'version'} = $ver->stringify();
      }
      return \%args;
  }
  
  sub _build_configure_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('configure');
  }
  
  sub _build_test_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('test');
  }
  
  sub _build_runtime_prereqs {
      my $self    = shift;
      return $self->phase_prereqs('runtime');
  }
  
  sub phase_prereqs {
      my ( $self, $phase ) = @_;
      my $prereqs = $self->prereqs;
      return +{
          map { $_ => $prereqs->{$_}{$phase} }
              keys %{$prereqs},
      };
  }
  
  sub spec {
      my $self = shift;
  
      return +{
          'Package' => {
              # This is so we don't see is_bootstrap in spec
              # if not required -- SX
              ( 'is_bootstrap' => 1 )x!! $self->is_bootstrap,
  
              map +( $_ => $self->$_ ), qw<category name version release>,
          },
  
          'Prereqs' => $self->prereqs,
  
          map +( $_ => $self->$_ ), qw<build_opts bundle_opts>,
      };
  }
  
  sub new_from_spec {
      my ( $class, $spec ) = @_;
  
      my %package_details = (
          %{ $spec->{'Package'} },
          'prereqs'      => $spec->{'Prereqs'}    || {},
          'build_opts'   => $spec->{'build_opts'} || {},
          'is_bootstrap' => !!$spec->{'is_bootstrap'},
      );
  
      return $class->new(%package_details);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
PAKKET_PACKAGE

$fatpacked{"Pakket/PackageQuery.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_PACKAGEQUERY';
  package Pakket::PackageQuery;
  # ABSTRACT: An object representing a query for a package
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Carp              qw< croak >;
  use Log::Any          qw< $log >;
  use version 0.77;
  use Pakket::Constants qw<
      PAKKET_PACKAGE_SPEC
      PAKKET_DEFAULT_RELEASE
  >;
  use Pakket::Types;
  
  with qw< Pakket::Role::BasicPackageAttrs >;
  
  has [qw< name category version >] => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'release' => (
      'is'      => 'ro',
      'isa'     => 'PakketRelease',
      'coerce'  => 1,
      'default' => sub { PAKKET_DEFAULT_RELEASE() },
  );
  
  has 'is_bootstrap' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {0},
  );
  
  sub BUILDARGS {
      my ( $class, %args ) = @_;
      if ($args{'category'} eq 'perl') {
          my $ver = version->new($args{'version'});
          if ($ver->is_qv) {$ver = version->new($ver->normal)};
          $args{'version'} = $ver->stringify();
      }
      return \%args;
  }
  
  sub new_from_string {
      my ( $class, $req_str ) = @_;
  
      if ( $req_str !~ PAKKET_PACKAGE_SPEC() ) {
          croak( $log->critical("Cannot parse $req_str") );
      } else {
          # This shuts up Perl::Critic
          return $class->new(
              'category' => $1,
              'name'     => $2,
              'version'  => $3,
              ( 'release'  => $4 )x!! $4,
          );
      }
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_PACKAGEQUERY

$fatpacked{"Pakket/Repository.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY';
  package Pakket::Repository;
  # ABSTRACT: Build in-memory representation of repo
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Path::Tiny;
  use Archive::Any;
  use Archive::Tar;
  use File::chdir;
  use Carp ();
  use Log::Any      qw< $log >;
  use Pakket::Types qw< PakketRepositoryBackend >;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  use Pakket::Versioning;
  
  has 'backend' => (
      'is'      => 'ro',
      'does'    => 'PakketRepositoryBackend',
      'coerce'  => 1,
      'lazy'    => 1,
      'builder' => '_build_backend',
      'handles' => [ qw<
          all_object_ids all_object_ids_by_name has_object
          store_content  retrieve_content  remove_content
          store_location retrieve_location remove_location
      > ],
  );
  
  sub _build_backend {
      my $self = shift;
      Carp::croak( $log->critical(
          'You did not specify a backend '
        . '(using parameter or URI string)',
      ) );
  }
  
  sub BUILD {
      my $self = shift;
      $self->backend();
  }
  
  sub retrieve_package_file {
      my ( $self, $type, $package ) = @_;
      my $file = $self->retrieve_location( $package->id );
  
      if ( !$file ) {
          Carp::croak( $log->criticalf(
              'We do not have the %s for package %s',
              $type, $package->full_name,
          ) );
      }
  
      my $dir = Path::Tiny->tempdir( 'CLEANUP' => 1 );
      my $arch = Archive::Any->new( $file->stringify );
      $arch->extract($dir);
  
      return $dir;
  }
  
  sub remove_package_file {
      my ( $self, $type, $package ) = @_;
      my $file = $self->retrieve_location( $package->id );
  
      if ( !$file ) {
          Carp::croak( $log->criticalf(
              'We do not have the %s for package %s',
              $type, $package->full_name,
          ) );
      }
  
      $log->debug("Removing $type package");
      $self->remove_location( $package->id );
  }
  
  sub latest_version_release {
      my ( $self, $category, $name, $req_string ) = @_;
  
      # This will also convert '0' to '>= 0'
      # (If we want to disable it, we just can just //= instead)
      $req_string ||= '>= 0';
  
      # Category -> Versioning type class
      my %types = (
          'perl' => 'Perl',
          'native' => 'Perl',
      );
  
      my %versions;
      foreach my $object_id ( @{ $self->all_object_ids } ) {
          my ( $my_category, $my_name, $my_version, $my_release ) =
              $object_id =~ PAKKET_PACKAGE_SPEC();
  
          # Ignore what is not ours
          $category eq $my_category and $name eq $my_name
              or next;
  
          # Add the version
          push @{ $versions{$my_version} }, $my_release;
      }
  
      my $versioner = Pakket::Versioning->new(
          'type' => $types{$category},
      );
  
      my $latest_version = $versioner->latest(
          $category, $name, $req_string, keys %versions,
      ) or Carp::croak(
          $log->criticalf(
              'Could not analyze %s/%s to find latest version', $category,
              $name,
          ),
      );
  
      # return the latest version and latest release available for this version
      return [
          $latest_version,
          ( sort @{ $versions{$latest_version} } )[-1],
      ];
  }
  
  sub freeze_location {
      my ( $self, $orig_path ) = @_;
  
      my $base_path = $orig_path;
      my @files;
  
      if ( $orig_path->is_file ) {
          $base_path = $orig_path->basename;
          push @files, $orig_path;
      } elsif ( $orig_path->is_dir ) {
          $orig_path->children
              or Carp::croak(
              $log->critical("Cannot freeze empty directory ($orig_path)") );
  
          $orig_path->visit(
              sub {
                  my $path = shift;
                  $path->is_file or return;
  
                  push @files, $path;
              },
              { 'recurse' => 1 },
          );
      } else {
          Carp::croak(
              $log->criticalf( "Unknown location type: %s", $orig_path ) );
      }
  
      @files = map {$_->relative($base_path)->stringify} @files;
  
      # Write and compress
      my $arch = Archive::Tar->new();
      {
          local $CWD = $base_path; # chdir, to use relative paths in archive
          $arch->add_files(@files);
      }
      my $file = Path::Tiny->tempfile();
      $log->debug("Writing archive as $file");
      $arch->write( $file->stringify, COMPRESS_GZIP );
  
      return $file;
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      my $repository = Pakket::Repository::Spec->new(
          'backend' => Pakket::Repository::Backend::file->new(...),
      );
  
      # or
      my $repository = Pakket::Repository::Spec->new(
          'backend' => 'file:///var/lib/',
      );
  
      ...
  
  This is an abstract class that represents all repositories. It
  implements a few generic methods all repositories use. Other than that,
  there is very little usage of instantiate this object.
  
  Below is the documentation for these generic methods, as well as how to
  set the backend when instantiating. If you are interested in
  documentation about particular repository methods, see:
  
  =over 4
  
  =item * L<Pakket::Repository::Spec>
  
  =item * L<Pakket::Repository::Source>
  
  =item * L<Pakket::Repository::Parcel>
  
  =back
  
  =head1 ATTRIBUTES
  
  =head2 backend
  
      my $repo = Pakket::Repository::Source->new(
          'backend' => Pakket::Repository::Backend::file->new(
              ...
          ),
      );
  
      # Or the short form:
      my $repo = Pakket::Repository::Source->new(
          'backed' => 'file://...',
      );
  
      # Or, if you need additional parameters
      my $repo = Pakket::Repository::Source->new(
          'backed'       => 'file://...',
          'backend_opts' => {
              'file_extension' => 'src',
          },
      );
  
  You can either provide an object or a string URI. You can provide
  
  Holds the repository backend implementation. Can be set with either an
  object instance or with a string URI. Additional parameters can be set
  with C<backend_opts>.
  
  Existing backends are:
  
  =over 4
  
  =item * L<Pakket::Repository::Backend::file>
  
  File-based backend, useful locally.
  
  =item * L<Pakket::Repository::Backend::http>
  
  HTTP-based backend, useful remotely.
  
  =item * L<Pakket::Repository::Backend::dbi>
  
  Database-based backed, useful remotely.
  
  =back
  
  =head2 backend_opts
  
  A hash reference that holds any additional parameters that could either
  be part of the URI specification (like a port) or extended beyond the
  URI specification (like a file extension).
  
  See examples in C<backend> above.
  
  =head1 METHODS
  
  =head2 retrieve_package_file
  
  =head2 remove_package_file
  
  =head2 latest_version_release
  
  =head2 freeze_location
  
  =head2 all_object_ids
  
  This method will call C<all_object_ids> on the backend.
  
  =head2 all_object_ids_by_name
  
  This method will call C<all_object_ids_by_name> on the backend.
  
  =head2 has_object
  
  This method will call C<has_object> on the backend.
  
  =head2 store_content
  
  This method will call C<store_content> on the backend.
  
  =head2 retrieve_content
  
  This method will call C<retrieve_content> on the backend.
  
  =head2 remove_content
  
  This method will call C<remove_content> on the backend.
  
  =head2 store_location
  
  This method will call C<store_location> on the backend.
  
  =head2 retrieve_location
  
  This method will call C<retrieve_location> on the backend.
  
  =head2 remove_location
  
  This method will call C<remove_location> on the backend.
  
PAKKET_REPOSITORY

$fatpacked{"Pakket/Repository/Backend/dbi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_DBI';
  package Pakket::Repository::Backend::dbi;
  # ABSTRACT: A DBI-based backend repository
  
  # FIXME: Add methods: remove_location, remove_content
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Carp       qw< croak >;
  use DBI        qw< :sql_types >;
  use Types::DBI;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'dbh' => (
     'is'       => 'ro',
     'isa'      => Dbh,
     'required' => 1,
     'coerce'   => 1,
  );
  
  sub new_from_uri {
      my ( $class, $uri ) = @_;
      return $class->new( 'dbh' => $uri );
  }
  
  ## no critic qw(Variables::ProhibitPackageVars)
  sub all_object_ids {
      my $self = shift;
      my $sql  = q{SELECT id FROM data};
      my $stmt = $self->_prepare_statement($sql);
  
      if ( !$stmt->execute() ) {
          croak( $log->criticalf(
              'Could not get remote all_object_ids: %s',
              $DBI::errstr,
          ) );
      }
  
      my @all_object_ids = map +( $_->[0] ), @{ $stmt->fetchall_arrayref() };
      return \@all_object_ids;
  }
  
  sub _prepare_statement {
      my ( $self, $sql ) = @_;
      my $stmt = $self->dbh->prepare($sql);
  
      if ( !$stmt ) {
          croak( $log->criticalf(
              'Could not prepare statement [%s] => %s',
              $sql,
              $DBI::errstr,
          ) );
      }
  
      return $stmt;
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      my $sql  = q{ SELECT id FROM data WHERE id = ? };
      my $stmt = $self->_prepare_statement($sql);
  
      $stmt->bind_param( 1, $id, SQL_VARCHAR );
      if ( !$stmt->execute() ) {
          croak( $log->criticalf(
              'Could not retrieve content for id %d: %s',
              $id,
              $DBI::errstr,
          ) );
      }
  
      my $results = $stmt->fetchall_arrayref();
      return @{$results} == 1;
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $content = path($file_to_store)->slurp( { 'binmode' => ':raw' } );
      $self->store_content( $id, $content );
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $content = $self->retrieve_content->($id);
      my $location = Path::Tiny->tempfile;
      $location->spew( { 'binmode' => ':raw' }, $content );
      return $location;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      {
          my $sql  = q{DELETE FROM data WHERE id = ?};
          my $stmt = $self->_prepare_statement($sql);
  
          $stmt->bind_param( 1, $id, SQL_VARCHAR );
          if ( !$stmt->execute() ) {
              croak( $log->criticalf(
                  'Could not delete content for id %d: %s',
                  $id,
                  $DBI::errstr,
              ) );
          }
      }
      {
          my $sql  = q{INSERT INTO data (id, content) VALUES (?, ?)};
          my $stmt = $self->_prepare_statement($sql);
  
          $stmt->bind_param( 1, $id,      SQL_VARCHAR );
          $stmt->bind_param( 2, $content, SQL_BLOB );
          if ( !$stmt->execute() ) {
              croak( $log->criticalf(
                  'Could not insert content for id %d: %s',
                  $id,
                  $DBI::errstr,
              ) );
          }
      }
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      my $sql  = q{SELECT content FROM data WHERE id = ?};
      my $stmt = $self->_prepare_statement($sql);
  
      $stmt->bind_param(1, $id, SQL_VARCHAR);
      if ( !$stmt->execute() ) {
          croak( $log->criticalf(
              'Could not retrieve content for id %d: %s',
              $id,
              $DBI::errstr,
          ) );
      }
  
      my $all_content = $stmt->fetchall_arrayref();
      if ( !$all_content || @{$all_content} != 1 ) {
          croak( $log->criticalf(
              'Failed to retrieve exactly one row for id %d: %s',
              $id,
          ) );
      }
  
      return $all_content->[0];
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
PAKKET_REPOSITORY_BACKEND_DBI

$fatpacked{"Pakket/Repository/Backend/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_FILE';
  package Pakket::Repository::Backend::file;
  # ABSTRACT: A file-based backend repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Carp              qw< croak >;
  use JSON::MaybeXS     qw< decode_json >;
  use Path::Tiny        qw< path >;
  use Log::Any          qw< $log >;
  use Types::Path::Tiny qw< Path AbsPath >;
  use Digest::SHA       qw< sha1_hex >;
  use Regexp::Common    qw< URI >;
  use Pakket::Utils     qw< encode_json_canonical encode_json_pretty >;
  use Pakket::Constants qw< PAKKET_PACKAGE_SPEC >;
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'directory' => (
      'is'       => 'ro',
      'isa'      => AbsPath,
      'coerce'   => 1,
      'required' => 1,
  );
  
  has 'file_extension' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'sgm'},
  );
  
  has 'index_file' => (
      'is'       => 'ro',
      'isa'      => Path,
      'coerce'   => 1,
      'default'  => sub {
          my $self = shift;
          return $self->directory->child('index.json');
      },
  );
  
  has 'pretty_json' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => sub {1},
  );
  
  sub new_from_uri {
      my ( $class, $uri ) = @_;
  
      $uri =~ /$RE{'URI'}{'file'}{'-keep'}/xms
          or croak( $log->critical("URI '$uri' is not a proper file URI") );
  
      my $path = $3; # perldoc Regexp::Common::URI::file
      return $class->new( 'directory' => $path );
  }
  
  sub BUILD {
      my $self = shift;
      if (!$self->directory->exists) {
          croak( $log->criticalf("Directory %s doesn't exist", $self->directory));
      }
  }
  
  sub repo_index {
      my $self = shift;
      my $file = $self->index_file;
  
      $file->is_file
          or return +{};
  
      return decode_json( $file->slurp_utf8 );
  }
  
  sub all_object_ids {
      my $self           = shift;
      my @all_object_ids = keys %{ $self->repo_index };
      return \@all_object_ids;
  }
  
  sub all_object_ids_by_name {
      my ( $self, $name, $category ) = @_;
      my @all_object_ids =
          grep { $_ =~ PAKKET_PACKAGE_SPEC(); $1 eq $category and $2 eq $name }
          keys %{ $self->repo_index };
      return \@all_object_ids;
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      return exists $self->repo_index->{$id};
  }
  
  sub _store_in_index {
      my ( $self, $id ) = @_;
  
      # Decide on a proper filename for $id
      # Meaningless extension
      my $filename = sha1_hex($id) . '.' . $self->file_extension;
  
      # Store in the index
      my $repo_index = $self->repo_index;
      $repo_index->{$id} = $filename;
  
      $self->_save_index($repo_index);
  
      return $filename;
  }
  
  sub _save_index {
      my ( $self, $repo_index ) = @_;
  
      my $content
          = $self->pretty_json
          ? encode_json_pretty($repo_index)
          : encode_json_canonical($repo_index);
  
      $self->index_file->spew_utf8($content);
  }
  
  sub _retrieve_from_index {
      my ( $self, $id ) = @_;
      return $self->repo_index->{$id};
  }
  
  sub _remove_from_index {
      my ( $self, $id ) = @_;
      my $repo_index = $self->repo_index;
      delete $repo_index->{$id};
      $self->_save_index($repo_index);
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $filename  = $self->_store_in_index($id);
      my $directory = $self->directory;
  
      return path($file_to_store)->copy( $directory->child($filename) );
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $filename = $self->_retrieve_from_index($id);
      $filename
          and return $self->directory->child($filename);
  
      $log->debug("File for ID '$id' does not exist in storage");
      return;
  }
  
  sub remove_location {
      my ( $self, $id ) = @_;
      my $location = $self->retrieve_location($id);
      $location or return;
      $location->remove;
      $self->_remove_from_index($id);
      return 1;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      my $file_to_store = Path::Tiny->tempfile;
      $file_to_store->spew( { 'binmode' => ':raw' }, $content );
      return $self->store_location( $id, $file_to_store );
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      return $self->retrieve_location($id)
                  ->slurp_utf8( { 'binmode' => ':raw' } );
  }
  
  sub remove_content {
      my ( $self, $id ) = @_;
      return $self->remove_location($id);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      my $backend = Pakket::Repository::Backend::file->new(
          'directory'      => '/var/lib/pakket/specs',
          'file_extension' => 'json',
          'index_file'     => 'index.json',
          'pretty_json'    => 1,
      );
  
      # Handling locations
      $backend->store_location( $id, $path_to_file );
      my $path_to_file = $backend->retrieve_location($id);
      $backend->remove_location($id);
  
      # Handling content
      $backend->store_content( $id, $structure );
      my $structure = $backend->retrieve_content($id);
      $backend->remove_content($id);
  
      # Getting data
      my $ids = $backend->all_object_ids; # [ ... ]
      my $ids = $backend->all_object_ids_by_name( 'Path::Tiny', 'perl' );
      if ( $backend->has_object($id) ) {
          ...
      }
  
  =head1 DESCRIPTION
  
  This is a file-based repository backend, allowing a repository to store
  information as files. It could store either content or files
  ("locations").
  
  Every and content is stored using its ID. The backend maintains an
  index file of all files so it could locate them quickly. The index file
  is stored in a JSON format.
  
  You can control the file extension and the index filename. See below.
  
  =head1 ATTRIBUTES
  
  When creating a new class, you can provide the following attributes:
  
  =head2 directory
  
  This is the directory that will be used. There is no root so it is
  better to provide an absolute path.
  
  This is a required parameter.
  
  =head2 file_extension
  
  The extension of files it stores. This has no effect on the format of
  the files, only the file extension. The reason is to be able to differ
  between files that contain specs versus files of parcels.
  
  Our preference is C<pkt> for packages, C<spkt> for sources, and C<json>
  for specs.
  
  Default: B<< C<sgm> >>.
  
  =head2 index_file
  
  The index file contains a list of all packages IDs and the files that
  correlate to it. Files are stored by their hashed ID and the index
  contains a mapping from the non-hashed ID to the hashed ID.
  
  Default: B<< F<index.json> >>.
  
  =head2 pretty_json
  
  This is a boolean controlling whether the index file should store
  pleasantly-readable JSON.
  
  Default: B<1>.
  
  =head1 METHODS
  
  All examples below use a particular string as the ID, but the ID could
  be anything you wish. Pakket uses the package ID for it, which consists
  of the category, name, version, and release.
  
  =head2 store_location
  
      $backend->store_location(
          'perl/Path::Tiny=0.100:1',
          '/tmp/myfile.tar.gz',
      );
  
  This method stores the ID with the hashed value and moves the file
  under its new name to the directory.
  
  It will return the file path.
  
  =head2 retrieve_location 
  
      my $path = $backend->retrieve_location('perl/Path::Tiny=0.100:1');
  
  This method locates the file in the directory and provides the full
  path to it. It does not copy it elsewhere. If you want to change it,
  you will need to do this yourself.
  
  =head2 remove_location
  
      $backend->remove_location('perl/Path::Tiny=0.100:1');
  
  This will remove the file from the directory and the index.
  
  =head2 store_content
  
      my $path = $backend->store_content(
          'perl/Path::Tiny=0.100:1',
          {
              'Package' => {
                  'category' => 'perl',
                  'name'     => 'Path::Tiny',
                  'version'  => 0.100,
                  'release'  => 1,
              },
  
              'Prereqs' => {...},
          },
      );
  
  This method stores content (normally spec files, but could be used for
  anything) in the directory. It will create a file with the appropriate
  hash ID and save it in the index by serializing it in JSON. This means
  you cannot store objects, only plain structures.
  
  It will return the path of that file. However, this is likely not be
  very helpful since you would like to retrieve the content. For this,
  use C<retrieve_content> described below.
  
  =head2 retrieve_content
  
      my $struct = $backend->retrieve_content('perl/Path::Tiny=0.100:1');
  
  This method will find the file, unserialize the file content, and
  return the structure it stores.
  
  =head2 remove_content
  
      $backend->remove_content('perl/Path::Tiny=0.100:1');
  
  =head2 repo_index
  
      my $repo_index_content = $backend->repo_index();
  
  This retrieves the unserialized content of the index. It is a hash
  reference that maps IDs to hashed IDs that correlate to file paths.
  
  =head2 all_object_ids
  
      my $ids = $backend->all_object_ids();
  
  Returns all the IDs of objects it stores in an array reference. This
  helps find whether an object is available or not.
  
  =head2 all_object_ids_by_name
  
      my $ids = $backend->all_object_ids_by_name( $name, $category );
  
  This is a more specialized method that receives a name and category for
  a package and locates all matching IDs in the index. It then returns
  them in an array reference.
  
  You do not normally need to use this method.
  
  =head2 has_object
  
      my $exists = $backend->has_object('perl/Path::Tiny=0.100:1');
  
  This method receives an ID and returns a boolean if it's available.
  
  This method depends on the index so if you screw up with the index, all
  bets are off. The methods above make sure the index is consistent.
PAKKET_REPOSITORY_BACKEND_FILE

$fatpacked{"Pakket/Repository/Backend/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_BACKEND_HTTP';
  package Pakket::Repository::Backend::http;
  # ABSTRACT: A remote HTTP backend repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Carp              qw< croak >;
  use URI::Escape       qw< uri_escape >;
  use JSON::MaybeXS     qw< decode_json >;
  use Path::Tiny        qw< path >;
  use Log::Any          qw< $log >;
  use Types::Path::Tiny qw< Path >;
  use HTTP::Tiny;
  use Regexp::Common    qw< URI >;
  use Pakket::Utils     qw< encode_json_canonical >;
  
  use constant { 'HTTP_DEFAULT_PORT' => 80 };
  
  with qw<
      Pakket::Role::Repository::Backend
  >;
  
  has 'scheme' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'http'},
  );
  
  has 'host' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'port' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub { HTTP_DEFAULT_PORT() },
  );
  
  has 'base_url' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'lazy'     => 1,
      'builder'  => '_build_base_url',
  );
  
  has 'base_path' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {''},
  );
  
  has 'http_client' => (
      'is'      => 'ro',
      'isa'     => 'HTTP::Tiny',
      'default' => sub { HTTP::Tiny->new },
  );
  
  sub new_from_uri {
      my ( $class, $uri ) = @_;
  
      # We allow the user to not include http, because we're nice like that
      $uri !~ m{^https?://}xms
          and $uri = "http://$uri";
  
      $uri =~ /$RE{'URI'}{'HTTP'}{ '-scheme' => qr{https?} }{'-keep'}/xms
          or croak( $log->critical("URI '$uri' is not a proper HTTP URI") );
  
      # perldoc Regexp::Common::URI::http
      return $class->new(
          'scheme'    => $2,
          'host'      => $3,
  
          # only if matched
        ( 'port'      => $4 )x !!$4,
        ( 'base_path' => $5 )x !!$5,
      );
  }
  
  sub BUILD {
      my $self = shift;
  
      # check that repo exists
  
      # TODO: should we create dedicated endpoint to check existence of repo
      # because all_object_ids may be too heavy?
      # FIXME: If we set this to "head" instead of "get", we at least
      # don't transfer the content. -- SX
      my $url      = $self->base_url . '/all_object_ids';
      my $response = $self->http_client->get($url);
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not connect to repository %s : %d -- %s',
              $url, $response->{'status'}, $response->{'reason'} ) );
      }
  }
  
  sub _build_base_url {
      my $self = shift;
  
      return sprintf(
          '%s://%s:%s%s',
          $self->scheme, $self->host, $self->port, $self->base_path,
      );
  }
  
  sub all_object_ids {
      my $self     = shift;
      my $url      = '/all_object_ids';
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not get remote all_object_ids: %d -- %s',
              $response->{'status'}, $response->{'reason'} ) );
      }
  
      my $content = decode_json( $response->{'content'} );
      return $content->{'object_ids'};
  }
  
  sub all_object_ids_by_name {
      my ( $self, $name, $category ) = @_;
      my $response = $self->http_client->get(
          sprintf( '%s/all_object_ids_by_name?name=%s&category=%s',
              $self->base_url, uri_escape($name), uri_escape($category),
          ),
      );
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not get remote all_object_ids: %d -- %s',
              $response->{'status'}, $response->{'reason'} ) );
      }
  
      my $content = decode_json( $response->{'content'} );
      return $content->{'object_ids'};
  }
  
  sub has_object {
      my ( $self, $id ) = @_;
      my $response = $self->http_client->get(
          $self->base_url . '/has_object?id=' . uri_escape($id),
      );
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not get remote has_object: %d -- %s',
              $response->{'status'}, $response->{'reason'} ) );
      }
  
      my $content = decode_json( $response->{'content'} );
      return $content->{'has_object'};
  }
  
  sub store_location {
      my ( $self, $id, $file_to_store ) = @_;
      my $content = path($file_to_store)->slurp(
          { 'binmode' => ':raw' },
      );
  
      my $url      = "/store/location?id=" . uri_escape($id);
      my $full_url = $self->base_url . $url;
  
      my $response = $self->http_client->post(
          $full_url => {
              'content' => $content,
              'headers' => {
                  'Content-Type' => 'application/x-www-form-urlencoded',
              },
          },
      );
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf(
              'Could not store location for id %s, URL: %s, Status: %s, Reason: %s',
              $id, $response->{'url'}, $response->{'status'}, $response->{'reason'}));
      }
  }
  
  sub retrieve_location {
      my ( $self, $id ) = @_;
      my $url      = '/retrieve/location?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      $response->{'success'} or return;
      my $content  = $response->{'content'};
      my $location = Path::Tiny->tempfile;
      $location->spew( { 'binmode' => ':raw' }, $content );
      return $location;
  }
  
  sub store_content {
      my ( $self, $id, $content ) = @_;
      my $url      = "/store/content";
      my $full_url = $self->base_url . $url;
  
      my $response = $self->http_client->post(
          $full_url => {
              'content' => encode_json_canonical(
                  { 'content' => $content, 'id' => $id, },
              ),
  
              'headers' => {
                  'Content-Type' => 'application/json',
              },
          },
      );
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not store content for id %s', $id ) );
      }
  }
  
  sub retrieve_content {
      my ( $self, $id ) = @_;
      my $url      = '/retrieve/content?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
  
      if ( !$response->{'success'} ) {
          croak( $log->criticalf( 'Could not retrieve content for id %s', $id ) );
      }
  
      return $response->{'content'};
  }
  
  sub remove_location {
      my ( $self, $id ) = @_;
      my $url = '/remove/location?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      return $response->{'success'};
  }
  
  sub remove_content {
      my ( $self, $id ) = @_;
      my $url = '/remove/content?id=' . uri_escape($id);
      my $full_url = $self->base_url . $url;
      my $response = $self->http_client->get($full_url);
      return $response->{'success'};
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
  
  =pod
  
  =head1 SYNOPSIS
  
      my $backend = Pakket::Repository::Backend::http->new(
          'scheme'      => 'https',
          'host'        => 'your.pakket.subdomain.company.com',
          'port'        => '80',
          'base_path'   => '/pakket/,
          'http_client' => HTTP::Tiny->new(...),
      );
  
      # Handling locations
      $backend->store_location( $id, $path_to_file );
      my $path_to_file = $backend->retrieve_location($id);
      $backend->remove_location($id);
  
      # Handling content
      $backend->store_content( $id, $structure );
      my $structure = $backend->retrieve_content($id);
      $backend->remove_content($id);
  
      # Getting data
      my $ids = $backend->all_object_ids; # [ ... ]
      my $ids = $backend->all_object_ids_by_name( 'Path::Tiny', 'perl' );
      if ( $backend->has_object($id) ) {
          ...
      }
  
  =head1 DESCRIPTION
  
  This repository backend will use HTTP to store and retrieve files and
  content structures. It is useful when you are using multiple client
  machines that need to either build to a remote repository or install
  from a remote repository.
  
  On the server side you will need to use L<Pakket::Web>.
  
  =head1 ATTRIBUTES
  
  When creating a new class, you can provide the following attributes:
  
  =head2 scheme
  
  The scheme to use.
  
  Default: B<https>.
  
  =head2 host
  
  Hostname or IP string to use.    
  
  This is a required parameter.
  
  =head2 port
  
  The port on which the remote server is listening.
  
  Default: B<80>.
  
  =head2 base_path
  
  The default path to prepend to the request URL. This is useful when you
  serve it on a server that also serves other content, or when you have
  multiple pakket instances and they are in subdirectories.
  
  Default: empty.
  
  =head2 base_url
  
  This is an advanced attribute that is generated automatically from the
  C<host>, C<port>, and C<base_path>. This uses B<http> by default but
  you can create your own with B<https>:
  
      my $backend = Pakket::Repository::Backend::http->new(
          'base_path' => 'https://my.path:80/secure_packages/',
      );
  
  Default: B<<C<http://HOST:PORT/BASE_URL>>>.
  
  =head2 http_client
  
  This is an advanced attribute defining the user agent to be used for
  fetching or updating data. This uses L<HTTP::Tiny> so you need one that
  is compatible or a subclass of it.
  
  Default: L<HTTP::Tiny> object.
  
  =head1 METHODS
  
  All examples below use a particular string as the ID, but the ID could
  be anything you wish. Pakket uses the package ID for it, which consists
  of the category, name, version, and release.
  
  =head2 store_location
  
      $backend->store_location(
          'perl/Path::Tiny=0.100:1',
          '/tmp/myfile.tar.gz',
      );
  
  This method makes a request to the server in the path
  C</store/location?id=$ID>. The C<$ID> is URI-escaped and the request
  is made as a C<x-www-form-urlencoded> request.
  
  The request is guarded by a check that will report this error, making
  the return value is useless.
  
  =head2 retrieve_location 
  
      my $path = $backend->retrieve_location('perl/Path::Tiny=0.100:1');
  
  This method makes a request to the server in the path
  C</retrieve/location?id=$ID>. The C<$ID> is URI-escaped.
  
  A temporary file is then created with the content and the method
  returns the location of this file.
  
  =head2 remove_location
  
      $backend->remove_location('perl/Path::Tiny=0.100:1');
  
  This method makes a request to the server in the path
  C</remove/location?id=$ID>. The C<$ID> is URI-escaped.
  
  The return value is a boolean of the success or fail of this operation.
  
  =head2 store_content
  
      $backend->store_content(
          'perl/Path::Tiny=0.100:1',
          {
              'Package' => {
                  'category' => 'perl',
                  'name'     => 'Path::Tiny',
                  'version'  => 0.100,
                  'release'  => 1,
              },
  
              'Prereqs' => {...},
          },
      );
  
  This method makes a POST request to the server in the path
  C</store/content>. The request body contains the content, encoded
  into JSON. This means you cannot store objects, only plain structures.
  
  The request is guarded by a check that will report this error, making
  the return value is useless. To retrieve the content, use
  C<retrieve_content> described below.
  
  =head2 retrieve_content
  
      my $struct = $backend->retrieve_content('perl/Path::Tiny=0.100:1');
  
  This method makes a request to the server in the path
  C</retrieve/content?id=$ID>. The C<$ID> is URI-escaped.
  
  It then returns the content as a structure, unserialized.
  
  =head2 remove_content
  
      my $success = $backend->remove_content('perl/Path::Tiny=0.100:1');
  
  This method makes a request to the server in the path
  C</remove/content?id=$ID>. The C<$ID> is URI-escaped.
  
  The return value is a boolean of the success or fail of this operation.
  
  =head2 all_object_ids
  
      my $ids = $backend->all_object_ids();
  
  This method makes a request to the server in the path
  C</all_object_ids> and returns all the IDs of objects it stores in an
  array reference. This helps find whether an object is available or not.
  
  =head2 all_object_ids_by_name
  
      my $ids = $backend->all_object_ids_by_name( $name, $category );
  
  This is a more specialized method that receives a name and category for
  a package and locates all matching IDs.
  
  This method makes a request to the server in the path
  C</all_object_ids_by_name?name=$NAME&category=$CATEGORY>. The
  C<$NAME> and C<$CATEGORY> are URI-escaped.
  
  It then returns all the IDs it finds in an array reference.
  
  You do not normally need to use this method.
  
  =head2 has_object
  
      my $exists = $backend->has_object('perl/Path::Tiny=0.100:1');
  
  This method receives an ID and returns a boolean if it's available.
  
  This method makes a request to the server in the path
  C</has_object?id=$ID>. The C<$ID> is URI-escaped.
PAKKET_REPOSITORY_BACKEND_HTTP

$fatpacked{"Pakket/Repository/Parcel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_PARCEL';
  package Pakket::Repository::Parcel;
  # ABSTRACT: A parcel repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Path::Tiny;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_parcel {
      my ( $self, $package ) = @_;
      return $self->retrieve_package_file( 'parcel', $package );
  }
  
  sub store_package_parcel {
      my ( $self, $package, $parcel_path ) = @_;
  
      $log->debug("Adding $parcel_path to file");
      my $file = $self->freeze_location($parcel_path);
  
      $log->debug("Storing $file");
      $self->store_location( $package->id, $file );
  }
  
  sub remove_package_parcel {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'parcel', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_PARCEL

$fatpacked{"Pakket/Repository/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_SOURCE';
  package Pakket::Repository::Source;
  # ABSTRACT: A source repository
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Path::Tiny;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_source {
      my ( $self, $package ) = @_;
      return $self->retrieve_package_file( 'source', $package );
  }
  
  sub store_package_source {
      my ( $self, $package, $source_path ) = @_;
  
      $log->debug("Adding $source_path to file");
      my $file = $self->freeze_location($source_path);
  
      $log->debug("Storing $file");
      $self->store_location( $package->id, $file );
  }
  
  sub remove_package_source {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'source', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_SOURCE

$fatpacked{"Pakket/Repository/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REPOSITORY_SPEC';
  package Pakket::Repository::Spec;
  # ABSTRACT: A spec repository
  
  use Moose;
  use MooseX::StrictConstructor;
  use Types::Path::Tiny qw< Path >;
  use Carp              qw< croak >;
  use JSON::MaybeXS     qw< decode_json >;
  use Pakket::Utils     qw< encode_json_pretty >;
  
  extends qw< Pakket::Repository >;
  
  sub retrieve_package_spec {
      my ( $self, $package ) = @_;
  
      my $spec_str;
      eval {
          $spec_str = $self->retrieve_content($package->id);
          1;
      } or do {
          die "Cannot fetch content for package " . $package->id . "\n";
      };
  
      my $config;
      eval {
          my $config_raw = decode_json($spec_str);
          $config = exists $config_raw->{'content'}
              ? decode_json $config_raw->{'content'}
              : $config_raw;
          1;
      } or do {
          my $err = $@ || 'Unknown error';
          croak("Cannot read spec properly: $err");
      };
  
      return $config;
  }
  
  sub store_package_spec {
      my ( $self, $package, $spec ) = @_;
  
      return $self->store_content(
          $package->id,
          encode_json_pretty( $spec || $package->spec ),
      );
  }
  
  sub remove_package_spec {
      my ( $self, $package ) = @_;
      return $self->remove_package_file( 'spec', $package );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REPOSITORY_SPEC

$fatpacked{"Pakket/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_REQUIREMENT';
  package Pakket::Requirement;
  # ABSTRACT: A Pakket requirement
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Carp     qw< croak >;
  use Log::Any qw< $log >;
  
  has [ qw< category name > ] => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'version' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub { '>= 0' },
  );
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_REQUIREMENT

$fatpacked{"Pakket/Role/BasicPackageAttrs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_BASICPACKAGEATTRS';
  package Pakket::Role::BasicPackageAttrs;
  # ABSTRACT: Some helpers to print names nicely
  
  use Moose::Role;
  use Pakket::Utils qw< canonical_package_name >;
  
  sub short_name {
      my $self = shift;
      return canonical_package_name( $self->category, $self->name );
  }
  
  sub full_name {
      my $self = shift;
      return canonical_package_name(
          $self->category, $self->name, $self->version, $self->release,
      );
  }
  
  sub id {
      my $self = shift;
      return $self->full_name;
  }
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
PAKKET_ROLE_BASICPACKAGEATTRS

$fatpacked{"Pakket/Role/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_BUILDER';
  package Pakket::Role::Builder;
  
  # ABSTRACT: A role for all builders
  
  use Moose::Role;
  
  with qw< Pakket::Role::RunCommand >;
  
  requires qw< build_package >;
  
  has 'exclude_packages' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  no Moose::Role;
  
  1;
PAKKET_ROLE_BUILDER

$fatpacked{"Pakket/Role/HasConfig.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASCONFIG';
  package Pakket::Role::HasConfig;
  # ABSTRACT: A role providing access to the Pakket configuration file
  
  use Moose::Role;
  use Pakket::Config;
  
  has 'config' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_config',
  );
  
  sub _build_config {
      my $self        = shift;
      my $config_reader = Pakket::Config->new();
      return $config_reader->read_config;
  }
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  This role provides any consumer with a C<config> attribute and builder,
  allowing the class to seamlessly load configuration and refer to it, as
  well as letting users override it during instantiation.
  
  This role is a wrapper around L<Pakket::Config>.
  
  =head1 ATTRIBUTES
  
  =head2 config
  
  A hashref built from the config file using L<Pakket::Config>.
PAKKET_ROLE_HASCONFIG

$fatpacked{"Pakket/Role/HasInfoFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASINFOFILE';
  package Pakket::Role::HasInfoFile;
  # ABSTRACT: Functions to work with 'info.json'
  
  use Moose::Role;
  
  use Log::Any qw< $log >;
  use JSON::MaybeXS qw< decode_json >;
  use Pakket::Utils qw< encode_json_pretty >;
  use Pakket::Constants qw<PAKKET_INFO_FILE>;
  use Pakket::Package;
  
  sub add_package_in_info_file {
      my ( $self, $parcel_dir, $dir, $package, $opts ) = @_;
  
      my $install_data = $self->load_info_file($dir);
  
      my %files;
  
      # get list of files
      $parcel_dir->visit(
          sub {
              my ( $path, $state ) = @_;
              $path->is_file or return;
  
              my $filename = $path->relative($parcel_dir);
              $files{$filename} = {
                  'category' => $package->category,
                  'name'     => $package->name,
                  'version'  => $package->version,
                  'release'  => $package->release,
              };
          },
          { 'recurse' => 1 },
      );
  
      my ( $cat, $name ) = ( $package->category, $package->name );
      $install_data->{'installed_packages'}{$cat}{$name} = {
          'version'   => $package->version,
          'release'   => $package->release,
          'files'     => [ keys %files ],
          'as_prereq' => $opts->{'as_prereq'} ? 1 : 0,
          'prereqs'   => $package->prereqs,
      };
  
      foreach my $file ( keys %files ) {
          $install_data->{'installed_files'}{$file} = $files{$file};
      }
  
      $self->save_info_file( $dir, $install_data );
  }
  
  sub load_info_file {
      my ($self, $dir) = @_;
  
      my $info_file = $dir->child( PAKKET_INFO_FILE() );
  
      my $install_data
          = $info_file->exists
          ? decode_json( $info_file->slurp_utf8 )
          : {};
  
      return $install_data;
  }
  
  sub save_info_file {
      my ( $self, $dir, $install_data ) = @_;
  
      my $info_file = $dir->child( PAKKET_INFO_FILE() );
  
      $info_file->spew_utf8( encode_json_pretty($install_data) );
  }
  
  sub load_installed_packages {
      my ($self, $dir) = @_;
  
      my $install_data = $self->load_info_file($dir);
      my $packages = $install_data->{'installed_packages'};
      my %packages = ();
      for my $category (keys %$packages) {
          for my $name (keys %{$packages->{$category}}) {
              my $p = $packages->{$category}{$name};
              my $package = Pakket::Package->new(
                                  'category' => $category,
                                  'name'     => $name,
                                  'version'  => $p->{'version'},
                                  'release'  => $p->{'release'},
                              );
              $packages{$package->full_name} = 1;
          }
      }
      return \%packages;
  }
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_HASINFOFILE

$fatpacked{"Pakket/Role/HasLibDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASLIBDIR';
  package Pakket::Role::HasLibDir;
  
  # ABSTRACT: a Role to add lib directory functionality
  
  use Moose::Role;
  
  use Carp qw< croak >;
  use Path::Tiny qw< path  >;
  use Types::Path::Tiny qw< Path  >;
  use File::Copy::Recursive qw< dircopy >;
  use Time::HiRes qw< time >;
  use Log::Any qw< $log >;
  use English qw< -no_match_vars >;
  
  has 'pakket_dir' => (
      'is'       => 'ro',
      'isa'      => Path,
      'coerce'   => 1,
      'required' => 1,
  );
  
  has 'libraries_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'coerce'  => 1,
      'lazy'    => 1,
      'builder' => '_build_libraries_dir',
  );
  
  has 'active_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'coerce'  => 1,
      'lazy'    => 1,
      'builder' => '_build_active_dir',
  );
  
  has 'work_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'coerce'  => 1,
      'lazy'    => 1,
      'builder' => '_build_work_dir',
  );
  
  sub _build_libraries_dir {
      my $self = shift;
  
      my $libraries_dir = $self->pakket_dir->child('libraries');
  
      $libraries_dir->is_dir
          or $libraries_dir->mkpath();
  
      return $libraries_dir;
  }
  
  sub _build_active_dir {
      my $self = shift;
  
      return $self->libraries_dir->child('active');
  }
  
  sub _build_work_dir {
      my $self = shift;
  
      my $template = sprintf("%s/work_%s_%s_XXXXX", $self->libraries_dir, $PID, time());
      my $work_dir = Path::Tiny->tempdir($template, TMPDIR => 0, CLEANUP => 1);
  
      $work_dir->exists
          or croak( $log->critical(
              "Could not create installation directory ($work_dir), exiting",
          ) );
  
      # we copy any previous installation
      if ( $self->active_dir->exists ) {
          my $orig_work_dir = eval { my $link = readlink $self->active_dir } or do {
              croak( $log->critical("$self->active_dir is not a symlink") );
          };
  
          dircopy( $self->libraries_dir->child($orig_work_dir), $work_dir );
      }
      $log->debugf( 'Created new working directory %s', $work_dir );
  
      return $work_dir;
  }
  
  sub activate_work_dir {
      my $self     = shift;
      my $work_dir = $self->work_dir;
  
      # The only way to make a symlink point somewhere else in an atomic way is
      # to create a new symlink pointing to the target, and then rename it to the
      # existing symlink (that is, overwriting it).
      #
      # This actually works, but there is a caveat: how to generate a name for
      # the new symlink? File::Temp will both create a new file name and open it,
      # returning a handle; not what we need.
      #
      # So, we just create a file name that looks like 'active_P_T.tmp', where P
      # is the pid and T is the current time.
      my $active_temp
          = $self->libraries_dir->child(
          sprintf( 'active_%s_%s.tmp', $PID, time() ),
          );
  
      if ( $active_temp->exists ) {
          # Huh? why does this temporary pathname exist? Try to delete it...
          $log->debug('Deleting existing temporary active object');
          $active_temp->remove
              or croak( $log->error(
                  'Could not activate new installation (temporary symlink remove failed)'
              ) );
      }
  
      # Need to set proper permissions before we move the work directory
      $work_dir->chmod('0755');
  
      my $work_final = $self->libraries_dir->child( time() );
      $log->debugf( 'Moving work directory %s to its final place %s', $work_dir, $work_final );
      $work_dir->move($work_final)
          or croak( $log->error(
              'Could not move work_dir to its final place'
          ) );
  
      # Unfortunately, if we die in the next call the work_dir will not be
      # removed, because we already changed its name so no cleanup will happen.
  
      $log->debugf( 'Setting temporary active symlink to new work directory %s',
          $work_final );
      symlink( $work_final->basename, $active_temp )
          or croak( $log->error(
              'Could not activate new installation (temporary symlink create failed)'
          ) );
  
      $log->debugf( 'Moving symlink %s to its final place %s', $active_temp, $self->active_dir );
      $active_temp->move($self->active_dir)
          or croak( $log->error(
              'Could not atomically activate new installation (symlink rename failed)'
          ) );
  }
  
  sub remove_old_libraries {
      my $self = shift;
  
      my $keep = 1;
  
      my @dirs = sort { $a->stat->mtime <=> $b->stat->mtime }
          grep +( $_->basename ne 'active' && $_->is_dir ),
          $self->libraries_dir->children;
  
      my $num_dirs = @dirs;
      foreach my $dir (@dirs) {
          $num_dirs-- <= $keep and last;
          $log->debug("Removing old directory: $dir");
          path($dir)->remove_tree( { 'safe' => 0 } );
      }
  }
  
  no Moose::Role;
  1;
  __END__
PAKKET_ROLE_HASLIBDIR

$fatpacked{"Pakket/Role/HasParcelRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASPARCELREPO';
  package Pakket::Role::HasParcelRepo;
  # ABSTRACT: Provide parcel repo support
  
  use Moose::Role;
  use Pakket::Repository::Parcel;
  
  has 'parcel_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Parcel',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Parcel->new(
              'backend' => $self->parcel_repo_backend,
          );
      },
  );
  
  has 'parcel_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'parcel'};
      },
  );
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 parcel_repo
  
  Stores the parcel repository, built with the backend using
  C<parcel_repo_backend>.
  
  =head2 parcel_repo_backend
  
  A hashref of backend information populated from the config file.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Pakket::Repository::Parcel>
  
  =back
PAKKET_ROLE_HASPARCELREPO

$fatpacked{"Pakket/Role/HasSourceRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASSOURCEREPO';
  package Pakket::Role::HasSourceRepo;
  # ABSTRACT: Provide source repo support
  
  use Moose::Role;
  use Pakket::Repository::Source;
  
  has 'source_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Source',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Source->new(
              'backend' => $self->source_repo_backend,
          );
      },
  );
  
  has 'source_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'source'};
      },
  );
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 source_repo
  
  Stores the source repository, built with the backend using
  C<source_repo_backend>.
  
  =head2 source_repo_backend
  
  A hashref of backend information populated from the config file.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Pakket::Repository::Source>
  
  =back
PAKKET_ROLE_HASSOURCEREPO

$fatpacked{"Pakket/Role/HasSpecRepo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_HASSPECREPO';
  package Pakket::Role::HasSpecRepo;
  # ABSTRACT: Provide spec repo support
  
  use Moose::Role;
  use Pakket::Repository::Spec;
  
  has 'spec_repo' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Repository::Spec',
      'lazy'    => 1,
      'default' => sub {
          my $self = shift;
  
          return Pakket::Repository::Spec->new(
              'backend' => $self->spec_repo_backend,
          );
      },
  );
  
  has 'spec_repo_backend' => (
      'is'      => 'ro',
      'isa'     => 'PakketRepositoryBackend',
      'lazy'    => 1,
      'coerce'  => 1,
      'default' => sub {
          my $self = shift;
          return $self->config->{'repositories'}{'spec'};
      },
  );
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 spec_repo
  
  Stores the spec repository, built with the backend using
  C<spec_repo_backend>.
  
  =head2 spec_repo_backend
  
  A hashref of backend information populated from the config file.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Pakket::Repository::Spec>
  
  =back
PAKKET_ROLE_HASSPECREPO

$fatpacked{"Pakket/Role/Perl/BootstrapModules.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_PERL_BOOTSTRAPMODULES';
  package Pakket::Role::Perl::BootstrapModules;
  # ABSTRACT: role to provide Perl's list of bootstrap modules (distributions)
  
  use Moose::Role;
  
  # hardcoded list of packages we have to build first
  # using core modules to break cyclic dependencies.
  # we have to maintain the order in order for packages to build
  # this list is an arrayref to maintain order
  has 'perl_bootstrap_modules' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub {
          [
              'ExtUtils-MakeMaker',
              'Module-Build',
              'Module-Build-WithXSpp',
          ]
      },
  );
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  =head1 ATTRIBUTES
  
  =head2 perl_bootstrap_modules
  
  An arrayref containing distribution names of bootstrap modules.
  
  It is used as a list of Perl modules to bootstrap.
PAKKET_ROLE_PERL_BOOTSTRAPMODULES

$fatpacked{"Pakket/Role/Repository/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_REPOSITORY_BACKEND';
  package Pakket::Role::Repository::Backend;
  # ABSTRACT: A role for all repository backends
  
  use Moose::Role;
  
  # These are helper methods we want the backend to implement
  # in order for the Repository to easily use across any backend
  requires qw<
      new_from_uri
  
      all_object_ids all_object_ids_by_name has_object
  
      store_content  retrieve_content  remove_content
      store_location retrieve_location remove_location
  >;
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
PAKKET_ROLE_REPOSITORY_BACKEND

$fatpacked{"Pakket/Role/RunCommand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_RUNCOMMAND';
  package Pakket::Role::RunCommand;
  # ABSTRACT: Role for running commands
  
  use Moose::Role;
  use System::Command;
  use Path::Tiny qw< path >;
  use Log::Any   qw< $log >;
  
  sub run_command {
      my ( $self, $dir, $sys_cmds, $extra_opts ) = @_;
      $log->debug( join ' ', @{$sys_cmds} );
  
      my %opt = (
          'cwd' => path($dir)->stringify,
  
          %{ $extra_opts || {} },
  
          # 'trace' => $ENV{SYSTEM_COMMAND_TRACE},
      );
  
      my $cmd = System::Command->new( @{$sys_cmds}, \%opt );
  
      my $success = $cmd->loop_on(
          'stdout' => sub {
              my $msg = shift;
              chomp $msg;
              $log->debug($msg);
              1;
          },
  
          'stderr' => sub {
              my $msg = shift;
              chomp $msg;
              $log->notice($msg);
              1;
          },
      );
  
      $log->debugf(
          "Command '%s' exited with '%d'",
          join( ' ', $cmd->cmdline ),
          $cmd->exit,
      );
  
      return $success;
  }
  
  # does more or less the same as `command1 && command2 ... && commandN`
  sub run_command_sequence {
      my ( $self, @commands ) = @_;
  
      $log->debugf( 'Starting a sequence of %d commands', 0+@commands );
  
      for my $idx ( 0 .. $#commands ) {
          my $success = $self->run_command( @{ $commands[$idx] } );
          unless ($success) {
              $log->debug("Sequence terminated on item $idx");
              return;
          }
      }
  
      $log->debug('Sequence finished');
  
      return 1;
  }
  
  no Moose::Role;
  
  1;
  
  __END__
  
  =pod
  
  =head1 DESCRIPTION
  
  Methods that help run commands in a standardized way.
  
  =head1 METHODS
  
  =head2 run_command
  
  Run a command picking the directory it will run from and additional
  options (such as environment or debugging). This uses
  L<System::Command>.
  
      $self->run_command( $dir, $commands, $extra_opts );
  
      $self->run_command(
          '/tmp/mydir',
          [ 'echo', 'hello', 'world' ],
  
          # System::Command options
          { 'env' => { 'SHELL' => '/bin/bash' } },
      );
  
  =head2 run_command_sequence
  
  This method is useful when you want to run a sequence of commands in
  which each commands depends on the previous one succeeding.
  
      $self->run_command_sequence(
          [ $dir, $commands, $extra_opts ],
          [ $dir, $commands, $extra_opts ],
      );
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<System::Command>
  
  =back
PAKKET_ROLE_RUNCOMMAND

$fatpacked{"Pakket/Role/Versioning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_ROLE_VERSIONING';
  package Pakket::Role::Versioning;
  # ABSTRACT: A Versioning role
  
  use Moose::Role;
  
  requires qw< compare >;
  
  no Moose::Role;
  1;
PAKKET_ROLE_VERSIONING

$fatpacked{"Pakket/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_RUNNER';
  package Pakket::Runner;
  # ABSTRACT: Run Pakket-based applications
  
  use Moose;
  use Types::Path::Tiny qw< AbsPath >;
  
  has 'active_path' => (
      'is'       => 'ro',
      'isa'      => AbsPath,
      'coerce'   => 1,
      'required' => 1,
  );
  
  sub run {
      my ( $self, @args ) = @_;
  
      my $active_path = $self->active_path;
  
      # Avoid uninitialized values
      my $ENV_PATH            = $ENV{'PATH'}            // '';
      my $ENV_LD_LIBRARY_PATH = $ENV{'LD_LIBRARY_PATH'} // '';
  
      local $ENV{'PATH'}            = "$active_path/bin:$ENV_PATH";
      local $ENV{'PERL5LIB'}        = "$active_path/lib/perl5";
      local $ENV{'LD_LIBRARY_PATH'} = "$active_path/lib:$ENV_LD_LIBRARY_PATH";
  
      # FIXME: Move to IPC::Open3, use the logger, etc.
      # XXX:   Should this just use the RunCommand role?
      if (@args) {
          system @args;
      } else {
          print "$_=$ENV{$_}\n" for qw< PATH PERL5LIB LD_LIBRARY_PATH >;
      }
  
      return 0;
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_RUNNER

$fatpacked{"Pakket/Scaffolder/Native.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_NATIVE';
  package Pakket::Scaffolder::Native;
  # ABSTRACT: Scffolding Native distributions
  
  use Moose;
  use MooseX::StrictConstructor;
  use Path::Tiny          qw< path >;
  use Log::Any            qw< $log >;
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasSpecRepo
      Pakket::Role::HasSourceRepo
  >;
  
  has 'package' => (
      'is' => 'ro',
  );
  
  has 'source_archive' => (
      'is'      => 'ro',
      'isa'     => 'Maybe[Str]',
  );
  
  sub run {
      my $self = shift;
  
      if ( $self->spec_repo->has_object( $self->package->id ) ) {
          $log->debugf("Package %s already exists", $self->package->full_name);
          return;
      }
  
      $log->infof('Working on %s', $self->package->full_name);
  
      # Source
      $self->add_source();
  
      # Spec
      $self->add_spec();
  
      $log->infof('Done: %s', $self->package->full_name);
  }
  
  sub add_source {
      my $self = shift;
  
      if ($self->source_repo->has_object($self->package->id)) {
          $log->debugf("Package %s already exists in source repo (skipping)",
                          $self->package->full_name);
          return;
      }
  
      if (!$self->source_archive) {
          Carp::croak("Please specify --source-archive=<sources_file_name>");
      }
  
      my $file = path($self->source_archive);
      if (!$file->exists) {
          Carp::croak("Archive with sources doesn't exist: ", $self->source_archive);
      }
  
      my $target = Path::Tiny->tempdir();
      my $dir    = $self->unpack($target, $file);
  
      $log->debugf("Uploading %s into source repo from %s", $self->package->full_name, $dir);
      $self->source_repo->store_package_source($self->package, $dir);
  }
  
  sub add_spec {
      my $self = shift;
  
      $log->debugf("Creating spec for %s", $self->package->full_name);
  
      my $package = Pakket::Package->new(
              'category' => $self->package->category,
              'name'     => $self->package->name,
              'version'  => $self->package->version,
              'release'  => $self->package->release,
          );
  
      $self->spec_repo->store_package_spec($package);
  }
  
  sub unpack {
      my ($self, $target, $file) = @_;
  
      my $archive = Archive::Any->new($file);
  
      if ($archive->is_naughty) {
          Carp::croak($log->critical("Suspicious module ($file)"));
      }
  
      $archive->extract($target);
  
      my @files = $target->children();
      if (@files == 1 && $files[0]->is_dir) {
          return $files[0];
      }
  
      return $target;
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_NATIVE

$fatpacked{"Pakket/Scaffolder/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL';
  package Pakket::Scaffolder::Perl;
  # ABSTRACT: Scffolding Perl distributions
  
  use Moose;
  use MooseX::StrictConstructor;
  use version 0.77;
  use Carp ();
  use Archive::Any;
  use CPAN::DistnameInfo;
  use CPAN::Meta;
  use Parse::CPAN::Packages::Fast;
  use JSON::MaybeXS       qw< decode_json encode_json >;
  use Ref::Util           qw< is_arrayref is_hashref >;
  use Path::Tiny          qw< path >;
  use Types::Path::Tiny   qw< Path  >;
  use Log::Any            qw< $log >;
  
  use Pakket::Package;
  use Pakket::Types;
  use Pakket::Utils::Perl qw< should_skip_core_module >;
  use Pakket::Constants   qw< PAKKET_PACKAGE_SPEC >;
  use Pakket::Scaffolder::Perl::Module;
  use Pakket::Scaffolder::Perl::CPANfile;
  
  with qw<
      Pakket::Role::HasConfig
      Pakket::Role::HasSpecRepo
      Pakket::Role::HasSourceRepo
      Pakket::Role::Perl::BootstrapModules
      Pakket::Scaffolder::Perl::Role::Borked
      Pakket::Scaffolder::Role::Backend
      Pakket::Scaffolder::Role::Terminal
  >;
  
  use constant {
      'ARCHIVE_DIR_TEMPLATE' => 'ARCHIVE-XXXXXX',
  };
  
  has 'metacpan_api' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'lazy'    => 1,
      'builder' => '_build_metacpan_api',
  );
  
  has 'phases' => (
      'is'       => 'ro',
      'isa'      => 'ArrayRef[PakketPhase]',
      'required' => 1,
  );
  
  has 'processed_packages' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { return +{} },
  );
  
  has 'modules' => (
      'is'  => 'ro',
      'isa' => 'HashRef',
  );
  
  has 'download_dir' => (
      'is'      => 'ro',
      'isa'     => Path,
      'lazy'    => 1,
      'builder' => '_build_download_dir',
  );
  
  has 'cache_dir' => (
      'is'        => 'ro',
      'isa'       => Path,
      'coerce'    => 1,
      'predicate' => '_has_cache_dir',
  );
  
  has 'file_02packages' => (
      'is'      => 'ro',
      'isa'     => 'Str',
  );
  
  has 'cpan_02packages' => (
      'is'      => 'ro',
      'isa'     => 'Parse::CPAN::Packages::Fast',
      'lazy'    => 1,
      'builder' => '_build_cpan_02packages',
  );
  
  has 'versioner' => (
      'is'      => 'ro',
      'isa'     => 'Pakket::Versioning',
      'lazy'    => 1,
      'builder' => '_build_versioner',
  );
  
  has 'no_deps' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => 0,
  );
  
  has 'no_bootstrap' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => 0,
  );
  
  has 'is_local' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  has 'types' => (
      'is'      => 'ro',
      'isa'     => 'ArrayRef',
      'default' => sub { [qw< requires recommends suggests >] },
  );
  
  has 'dist_name' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub { +{} },
  );
  
  sub _build_metacpan_api {
      my $self = shift;
      return $ENV{'PAKKET_METACPAN_API'}
          || $self->config->{'perl'}{'metacpan_api'}
          || 'https://fastapi.metacpan.org';
  }
  
  sub _build_download_dir {
      my $self = shift;
      return Path::Tiny->tempdir( 'CLEANUP' => 1 );
  }
  
  sub _build_cpan_02packages {
      my $self = shift;
      my ( $dir, $file );
  
      if ( $self->file_02packages ) {
          $file = path( $self->file_02packages );
          $log->infof( "Using 02packages file: %s", $self->file_02packages );
  
      } else {
          $dir  = Path::Tiny->tempdir;
          $file = path( $dir, '02packages.details.txt' );
          $log->infof( "Downloading 02packages" );
          $self->ua->mirror( 'https://cpan.metacpan.org/modules/02packages.details.txt', $file );
      }
  
      return Parse::CPAN::Packages::Fast->new($file);
  }
  
  sub _build_versioner {
      return Pakket::Versioning->new( 'type' => 'Perl' );
  }
  
  sub BUILDARGS {
      my ( $class, @args ) = @_;
      my %args = @args == 1 ? %{ $args[0] } : @args;
  
      my $module   = delete $args{'module'};
      my $cpanfile = delete $args{'cpanfile'};
  
      Carp::croak("Please provide either 'module' or 'cpanfile'")
          unless $module xor $cpanfile;
  
      if ( $module ) {
          my $version = $module->version
                          ? "== " . $module->version  # exact version
                          : ">= 0";                   # latest version
  
          my ( $phase, $type   ) = delete @args{qw< phase type >};
          $args{'modules'} =
              Pakket::Scaffolder::Perl::Module->new(
                  'name'    => $module->name,
                  'version' => $version . ":" . $module->release,
                  ( phase   => $phase   )x!! defined $phase,
                  ( type    => $type    )x!! defined $type,
              )->prereq_specs;
      }
      else {
          $args{'modules'} =
              Pakket::Scaffolder::Perl::CPANfile->new(
                  'cpanfile' => $cpanfile
              )->prereq_specs;
      }
  
      return \%args;
  }
  
  sub run {
      my $self = shift;
      my %failed;
  
      # Bootstrap toolchain
      if ( !$self->no_bootstrap and !$self->no_deps ) {
          for my $package ( @{ $self->perl_bootstrap_modules } ) {
              $log->debugf( 'Bootstrapping toolchain: %s', $package );
              eval {
                  $self->scaffold_package( $package, { $package => "0" } );
                  1;
              } or do {
                  my $err = $@ || 'zombie error';
                  Carp::croak("Cannot bootstrap toolchain module: $package ($err)\n");
              };
          }
      }
  
      # the rest
      for my $phase ( @{ $self->phases } ) {
          for my $type ( @{ $self->types } ) {
              next unless is_hashref( $self->modules->{ $phase }{ $type } );
  
              my $requirements = $self->modules->{$phase}{$type};
  
              for my $package ( sort keys %{ $self->modules->{ $phase }{ $type } } ) {
                  eval {
                      $self->scaffold_package( $package, $requirements );
                      1;
                  } or do {
                      my $err = $@ || 'zombie error';
                      $failed{$package} = $err;
                  };
              }
          }
      }
  
      my $errors = keys %failed;
      if ($errors) {
          for my $f ( sort keys %failed ) {
              $log->errorf( "[FAILED] %s: %s", $f, $failed{$f} );
          }
      } else {
          $log->info( 'Done' );
      }
      return $errors;
  }
  
  sub scaffold_package {
      my ( $self, $package_name, $requirements ) = @_;
  
      if ( $self->processed_packages->{ $package_name }++ ) {
          $log->debugf("Skipping $package_name, already processed");
          return;
      }
  
      if ( $self->is_package_in_spec_repo($package_name, $requirements) ) {
          return;
      }
  
      my $release_info = $self->get_release_info_for_package( $package_name, $requirements );
  
      my $package_spec = {
          'Package' => {
              'category' => 'perl',
              'name'     => $package_name,
              'version'  => $release_info->{'version'},
              'release'  => $release_info->{'release'} // 1,
          },
      };
  
      my $package = Pakket::Package->new_from_spec($package_spec);
  
      $log->debug( '----------------------------------------------' );
      $log->infof( '%sWorking on %s', $self->spaces, $package->full_name );
      $self->set_depth( $self->depth + 1 );
  
      # Source
      $self->add_source_for_package($package, $release_info);
  
      # Spec
      $self->add_spec_for_package($package, $release_info, $package_spec);
  
      $log->infof( '%sDone: %s', $self->spaces, $package->full_name );
      $self->set_depth( $self->depth - 1 );
  }
  
  
  sub add_source_for_package {
      my ($self, $package, $release_info) = @_;
      my $package_name = $package->name;
  
      # check if we already have the source in the repo
      if ( $self->source_repo->has_object( $package->id ) ) {
          $log->debugf("Package %s already exists in source repo (skipping)",
                          $package->full_name);
          return;
      }
  
      my $download_url = $self->rewrite_download_url( $release_info->{'download_url'} );
  
      if ( $self->_has_cache_dir ) {
          my $from_file;
          if ($download_url) {
              my $name_ver = $download_url =~ s{^.+/}{}r;
              $from_file = path($self->cache_dir, $name_ver);
              $from_file->exists or $from_file = undef;
          } else {
              $from_file = $self->get_source_archive_path($package_name,
                      $release_info->{'version'}, $release_info->{'release'});
          }
          if ( $from_file ) {
              $log->debugf( 'Found source for %s in %s',
                              $package_name, $from_file->stringify);
  
              $self->upload_source_archive( $package, $from_file );
              return;
          }
      }
  
      if ( $self->is_local->{$package_name} ) {
          Carp::croak( "IMPOSSIBLE: Can't find archive with source for %s", $package_name );
      }
  
      if ( !$download_url ) {
          Carp::croak( "Don't have download_url for %s", $package_name );
      }
  
      my $source_file = path( $self->download_dir,
                              ( $download_url =~ s{^.+/}{}r ) );
      $log->debugf("Downloading sources for %s (%s)", $package_name, $download_url);
      $self->ua->mirror( $download_url, $source_file );
      $self->upload_source_archive( $package, $source_file );
  }
  
  sub add_spec_for_package {
      my ($self, $package, $release_info, $spec) = @_;
      if ( $self->spec_repo->has_object( $package->id ) ) {
          $log->debugf("Package %s already exists in spec repo (skipping)",
                          $package->full_name);
          return;
      }
      $log->debugf("Creating spec for %s", $package->full_name);
  
  
      my @dependencies_to_scaffold;
  
      for my $phase ( @{ $self->phases } ) {  # phases: configure, develop, runtime, test
          $spec->{'Prereqs'}{'perl'}{$phase} = +{};
  
          # CPAN requirement is a list of modules and their versions.
          # Pakket internally, in spec, keeps list of packages and their versions.
          # It is possible that few different modules from CPAN requirement are in one distribution.
          # We will gather distribution names and merge requirements of different modules of one distribution.
          my $spec_req = CPAN::Meta::Requirements->new;
  
          for my $dep_type ( @{ $self->types } ) {  # dep_type: requires, recommends
              next unless is_hashref( $release_info->{'prereqs'}->{ $phase }{ $dep_type } );
              my $dep_requirements = $release_info->{'prereqs'}{$phase}{$dep_type};
  
              for my $module ( keys %{ $release_info->{'prereqs'}->{ $phase }{ $dep_type } } ) {
                  next if $self->skip_module($module);
  
                  my $package_name = $self->get_dist_name($module);
                  $log->debugf( "Found module $module in distribution $package_name" );
  
                  if ( exists $self->known_incorrect_dependencies->{ $package->name }{ $package_name } ) {
                      $log->debugf( "%sskipping %s (known 'bad' dependency for %s)",
                                    $self->spaces, $package_name, $package->name );
                      next;
                  }
  
                  # TODO: find out correct way to translate module version to package version
                  $spec_req->add_string_requirement( $package_name,
                              $dep_requirements->{$module} );
              }
          }
  
          my $spec_req_h = $spec_req->as_string_hash();
          for my $package_name ( keys %{ $spec_req_h } ) {
              push @dependencies_to_scaffold,
                  { 'package_name' => $package_name, 'requirements' => $spec_req_h };
              $spec->{'Prereqs'}{'perl'}{$phase}->{ $package_name } =
                  +{ 'version' => ( $spec_req_h->{ $package_name } || 0 ) };
          }
      }
  
      if ( ! $self->no_deps ) {
          $log->debugf( 'Scaffolding dependencies of %s', $package->full_name );
          for my $dep (@dependencies_to_scaffold) {
              $self->scaffold_package($dep->{'package_name'}, $dep->{'requirements'} );
          }
      }
  
      $self->merge_pakket_json_into_spec($package, $spec);
  
      # We had a partial Package object
      # So now we have to recreate that package object
      # based on the full specs (including prereqs)
      $package = Pakket::Package->new_from_spec($spec);
  
      $self->spec_repo->store_package_spec($package);
  }
  
  sub skip_module {
      my ( $self, $module_name ) = @_;
  
      if ( should_skip_core_module($module_name) ) {
          $log->debugf( "%sSkipping %s (core module, not dual-life)", $self->spaces, $module_name );
          return 1;
      }
  
      if ( exists $self->known_modules_to_skip->{ $module_name } ) {
          $log->debugf( "%sSkipping %s (known 'bad' module for configuration)", $self->spaces, $module_name );
          return 1;
      }
  
      return 0;
  }
  
  sub unpack {
      my ( $self, $target, $file ) = @_;
  
      my $archive = Archive::Any->new($file);
  
      if ( $archive->is_naughty ) {
          Carp::croak( $log->critical("Suspicious module ($file)") );
      }
  
      $archive->extract($target);
  
      # Determine if this is a directory in and of itself
      # or whether it's just a bunch of files
      # (This is what Archive::Any refers to as "impolite")
      # It has to be done manually, because the list of files
      # from an archive might return an empty directory listing
      # or none, which confuses us
      my @files = $target->children();
      if ( @files == 1 && $files[0]->is_dir ) {
          # Polite
          return $files[0];
      }
  
      # Is impolite, meaning it's just a bunch of files
      # (or a single file, but still)
      return $target;
  }
  
  sub is_package_in_spec_repo {
      my ( $self, $package_name, $requirements ) = @_;
  
      my @versions = map { $_ =~ PAKKET_PACKAGE_SPEC(); "$3:$4" }
          @{ $self->spec_repo->all_object_ids_by_name($package_name, 'perl') };
  
      return 0 unless @versions; # there are no packages
  
      if (!exists $requirements->{$package_name}) {
          $log->debugf("Skipping %s, already have version: %s",
                          $package_name, join(", ", @versions));
          return 1;
      }
  
      if ($self->versioner->is_satisfying($requirements->{$package_name}, @versions)) {
          $log->debugf("Skipping %s, already have satisfying version: %s",
                          $package_name, join(", ", @versions));
          return 1;
      }
  
      return 0; # spec has package, but version is not compatible
  }
  
  sub upload_source_archive {
      my ( $self, $package, $file ) = @_;
  
      my $target = Path::Tiny->tempdir();
      my $dir    = $self->unpack( $target, $file );
  
      $log->debugf("Uploading %s into source repo from %s", $package->name, $dir);
      $self->source_repo->store_package_source($package, $dir);
  }
  
  sub get_dist_name {
      my ( $self, $module_name ) = @_;
  
      # check if we've already seen it
      exists $self->dist_name->{$module_name}
          and return $self->dist_name->{$module_name};
  
      my $dist_name;
  
      # check if we can get it from 02packages
      eval {
          my $url = $self->metacpan_api . "/package/" . $module_name;
          $log->debug("Requesting information about module $module_name ($url)");
          my $res = $self->ua->get($url);
  
          $res->{'status'} == 200
              or Carp::croak("Cannot fetch $url");
  
          my $content = decode_json $res->{'content'};
          $dist_name = $content->{'distribution'};
          1;
      } or do {
          my $error = $@ || 'Zombie error';
          $log->debug($error);
      };
  
      # fallback 1:  local copy of 02packages.details
      if ( ! $dist_name ) {
          my $mod = $self->cpan_02packages->package($module_name);
          $mod and $dist_name = $mod->distribution->dist;
      }
  
      # fallback 2: metacpan check
      if ( ! $dist_name ) {
          $module_name = $self->known_incorrect_name_fixes->{ $module_name }
              if exists $self->known_incorrect_name_fixes->{ $module_name };
  
          eval {
              my $mod_url  = $self->metacpan_api . "/module/$module_name";
              $log->debug("Requesting information about module $module_name ($mod_url)");
              my $response = $self->ua->get($mod_url);
  
              $response->{'status'} == 200
                  or Carp::croak("Cannot fetch $mod_url");
  
              my $content = decode_json $response->{'content'};
              $dist_name  = $content->{'distribution'};
              1;
          } or do {
              my $error = $@ || 'Zombie error';
              $log->debug($error);
          };
      }
  
      # fallback 3: check if name matches a distribution name
      if ( ! $dist_name ) {
          eval {
              $dist_name = $module_name =~ s/::/-/rgsmx;
              my $url = $self->metacpan_api . '/release';
              $log->debug("Requesting information about distribution $dist_name ($url)");
              my $res = $self->ua->post( $url,
                                         +{ 'content' => $self->get_is_dist_name_query($dist_name) }
                                     );
              $res->{'status'} == 200 or Carp::croak();
  
              my $res_body = decode_json $res->{'content'};
              $res_body->{'hits'}{'total'} > 0 or Carp::croak();
  
              1;
          } or do {
              $log->warn("Cannot find distribution for module $module_name. Trying to use $dist_name as fallback");
          };
      }
  
      $dist_name and
          $self->dist_name->{$module_name} = $dist_name;
  
      return $dist_name;
  }
  
  sub get_release_info_local {
      my ( $self, $package_name, $requirements ) = @_;
  
      my $full_ver = $requirements->{$package_name} =~ s/^[=\ ]+//r;
      my ($ver, $release) = split(/:/, $full_ver);
      my $prereqs;
      my $from_file = $self->get_source_archive_path($package_name, $ver, $release);
      if ( $from_file ) {
          my $target = Path::Tiny->tempdir();
          my $dir    = $self->unpack( $target, $from_file );
          $self->load_pakket_json($dir);
          if ( !$self->no_deps and
               ( $dir->child('META.json')->is_file or $dir->child('META.yml')->is_file )
          ) {
              my $file = $dir->child('META.json')->is_file
                  ? $dir->child('META.json')
                  : $dir->child('META.yml');
              my $meta = CPAN::Meta->load_file( $file );
              $prereqs = $meta->effective_prereqs->as_string_hash;
          } else {
              $log->warn("Can't find META.json or META.yml in $from_file");
          }
      } else {
          Carp::croak("Can't find source file for package $package_name");
      }
  
      return +{
          'distribution' => $package_name,
          'version'      => $ver,
          'release'      => $release,
          'prereqs'      => $prereqs,
      };
  }
  
  sub get_release_info_for_package {
      my ( $self, $package_name, $requirements ) = @_;
  
      # if is_local is set - generate info without upstream data
      if ( $self->is_local->{$package_name} ) {
          return $self->get_release_info_local( $package_name, $requirements );
      }
  
      # try the latest
      my $latest = $self->get_latest_release_info_for_distribution( $package_name );
      if ( $latest->{'version'} && defined $latest->{'download_url'}) {
          if ($self->versioner->is_satisfying($requirements->{$package_name}, $latest->{'version'})) {
              return $latest;
          }
          $log->debugf("Latest version of %s is %s. Doesn't satisfy requirements. Checking other old versions.",
                          $package_name, $latest->{'version'});
      }
  
      # else: fetch all release versions for this distribution
      my $release_prereqs;
      my $version;
      my $download_url;
  
      my $all_dist_releases = $self->get_all_releases_for_distribution($package_name);
  
      # get the matching version according to the spec
  
      my @valid_versions;
      for my $v ( keys %{$all_dist_releases} ) {
          eval {
              version->parse($v);
              push @valid_versions => $v;
              1;
          } or do {
              my $err = $@ || 'zombie error';
              $log->debugf( '[VERSION ERROR] distribution: %s, version: %s, error: %s',
                            $package_name, $v, $err );
          };
      }
  
      @valid_versions = sort { version->parse($b) <=> version->parse($a) } @valid_versions;
  
      for my $v ( @valid_versions ) {
          if ($self->versioner->is_satisfying($requirements->{$package_name}, $v)) {
              $version         = $v;
              $release_prereqs = $all_dist_releases->{$v}{'prereqs'} || {};
              $download_url    =
                  $self->rewrite_download_url( $all_dist_releases->{$v}{'download_url'} );
              last;
          }
      }
  
      $version = $self->known_incorrect_version_fixes->{ $package_name } // $version;
  
      if (!$version) {
          Carp::croak("Cannot find a suitable version for $package_name requirements: "
                          . $requirements->{$package_name}
                          . ", available: " . join(', ', @valid_versions));
      }
  
      return +{
          'distribution' => $package_name,
          'version'      => $version,
          'prereqs'      => $release_prereqs,
          'download_url' => $download_url,
      };
  }
  
  sub get_all_releases_for_distribution {
      my ( $self, $distribution_name ) = @_;
  
      my $url = $self->metacpan_api . "/release";
      $log->debugf("Requesting release info for all old versions of $distribution_name ($url)");
      my $res = $self->ua->post( $url,
              +{ content => $self->get_release_query($distribution_name) });
      if ($res->{'status'} != 200) {
          Carp::croak("Can't find any release for $distribution_name from $url, Status: "
                  . $res->{'status'} . ", Reason: " . $res->{'reason'} );
      }
      my $res_body = decode_json $res->{'content'};
      is_arrayref( $res_body->{'hits'}{'hits'} )
          or Carp::croak("Can't find any release for $distribution_name");
  
      my %all_releases =
          map {
              my $v = $_->{'fields'}{'version'};
              ( is_arrayref($v) ? $v->[0] : $v ) => {
                  'prereqs'       => $_->{'_source'}{'metadata'}{'prereqs'},
                  'download_url'  => $_->{'_source'}{'download_url'},
              },
          }
          @{ $res_body->{'hits'}{'hits'} };
  
      return \%all_releases;
  }
  
  sub rewrite_download_url {
      my ( $self, $download_url ) = @_;
      my $rewrite = $self->config->{'perl'}{'metacpan'}{'rewrite_download_url'};
      return $download_url unless is_hashref($rewrite);
      my ( $from, $to ) = @{$rewrite}{qw< from to >};
      return ( $download_url =~ s/$from/$to/r );
  }
  
  sub get_latest_release_info_for_distribution {
      my ( $self, $package_name ) = @_;
  
      my $url = $self->metacpan_api . "/release/$package_name";
      $log->debugf("Requesting release info for latest version of %s (%s)", $package_name, $url);
      my $res = $self->ua->get( $url );
      if ($res->{'status'} != 200) {
          $log->debugf("Failed receive from $url, Status: %s, Reason: %s", $res->{'status'}, $res->{'reason'});
          return;
      }
  
      my $res_body= decode_json $res->{'content'};
      my $version = $res_body->{'version'};
      $version = $self->known_incorrect_version_fixes->{ $package_name } // $version;
  
      return +{
              'distribution' => $package_name,
              'version'      => $version,
              'download_url' => $res_body->{'download_url'},
              'prereqs'      => $res_body->{'metadata'}{'prereqs'},
          };
  }
  
  sub get_is_dist_name_query {
      my ( $self, $name ) = @_;
  
      return encode_json(
          {
              'query'  => {
                  'bool' => {
                      'must' => [
                          { 'term'  => { 'distribution' => $name } },
                      ]
                  }
              },
              'fields' => [qw< distribution >],
              'size'   => 0,
          }
      );
  }
  
  sub get_release_query {
      my ( $self, $dist_name ) = @_;
  
      return encode_json(
          {
              'query'  => {
                  'bool' => {
                      'must' => [
                          { 'term'  => { 'distribution' => $dist_name } },
                          # { 'terms' => { 'status' => [qw< cpan latest >] } }
                      ]
                  }
              },
              'fields'  => [qw< version >],
              '_source' => [qw< metadata.prereqs download_url >],
              'size'    => 999,
          }
      );
  }
  
  # parsing Pakket.json
  # Packet.json should be in root directory of package, near META.json
  # It keeps some settings which we are missing in META.json.
  sub load_pakket_json {
      my ($self, $dir) = @_;
      my $pakket_json = $dir->child('Pakket.json');
  
      $pakket_json->exists or return;
  
      $log->debug("Found Pakket.json in $dir");
  
      my $data = decode_json($pakket_json->slurp_utf8);
  
      # Section 'module_to_distribution'
      # Using to map module->distribution for local not-CPAN modules
      if ($data->{'module_to_distribution'}) {
          for my $module_name ( keys %{$data->{'module_to_distribution'}}  ) {
              my $dist_name = $data->{'module_to_distribution'}{$module_name};
              $self->dist_name->{$module_name} = $dist_name;
          }
      }
      return $data;
  }
  
  sub merge_pakket_json_into_spec {
      my ($self, $package, $spec) = @_;
  
      my $src_dir = $self->source_repo->retrieve_package_source($package);
  
      my $pakket_json = $self->load_pakket_json($src_dir);
  
      if ($pakket_json->{'prereqs'}) {
          # package type: perl, native
          for my $type (keys %{$pakket_json->{'prereqs'}}) {
              # phase: runtime, configure
              for my $phase (keys %{$pakket_json->{'prereqs'}{$type}}) {
                  for my $module (keys %{$pakket_json->{'prereqs'}{$type}{$phase}}) {
                      $spec->{'Prereqs'}{$type}{$phase}{$module}{'version'} =
                              $pakket_json->{'prereqs'}{$type}{$phase}{$module};
                  }
              }
          }
      }
  
      if ($pakket_json->{'build_opts'}) {
          $spec->{'build_opts'} =  $pakket_json->{'build_opts'};
      }
  }
  
  sub get_source_archive_path {
      my ($self, $name, $ver, $rel) = @_;
      $rel //= 1;
      my @possible_paths = (
          path( $self->cache_dir, $name . '-' . $ver . '.' . $rel . '.tar.gz' ),
          path( $self->cache_dir, $name . '-' . $ver . '.tar.gz' ),
      );
      for my $path (@possible_paths) {
          if ($path->exists) {
              $log->debugf( 'Found archive %s', $path->stringify);
              return $path;
          }
      }
      $log->debug("Can't find archive in:\n", join("\n", @possible_paths));
      return 0;
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL

$fatpacked{"Pakket/Scaffolder/Perl/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_CPANFILE';
  package Pakket::Scaffolder::Perl::CPANfile;
  # ABSTRACT: Scffolding Perl cpanfile reader
  
  use Moose;
  use MooseX::StrictConstructor;
  use Module::CPANfile;
  
  has 'cpanfile' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => 1,
  );
  
  has 'prereq_specs' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'lazy'    => 1,
      'builder' => '_build_prereq_specs',
  );
  
  sub _build_prereq_specs {
      my $self = shift;
      my $file = Module::CPANfile->load( $self->cpanfile );
      return $file->prereq_specs;
  }
  
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_CPANFILE

$fatpacked{"Pakket/Scaffolder/Perl/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_MODULE';
  package Pakket::Scaffolder::Perl::Module;
  # ABSTRACT: scaffolder: module config representation
  
  use Moose;
  use MooseX::StrictConstructor;
  
  has 'name' => (
      'is'       => 'ro',
      'isa'      => 'Str',
      'required' => sub {1},
  );
  
  has 'version' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {0},
  );
  
  has 'phase' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'runtime'},
  );
  
  has 'type' => (
      'is'      => 'ro',
      'isa'     => 'Str',
      'default' => sub {'requires'},
  );
  
  sub BUILDARGS {
      my ( $class, @args ) = @_;
      my %args = @args == 1 ? %{ $args[0] } : @args;
  
      if ( $args{'name'} =~ /^ (.+) \@ (.+) $/x ) {
          $args{'name'}    = $1;
          $args{'version'} = "== $2";
      }
      elsif ( $args{'name'} =~ /^ (.+) \~ (.+) $/x ) {
          $args{'name'}    = $1;
          $args{'version'} = $2;
      }
  
      return \%args;
  }
  
  sub prereq_specs {
      my $self = shift;
      return +{
          $self->phase => +{
              $self->type => +{
                  $self->name => $self->version,
              },
          },
      };
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_MODULE

$fatpacked{"Pakket/Scaffolder/Perl/Role/Borked.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_PERL_ROLE_BORKED';
  package Pakket::Scaffolder::Perl::Role::Borked;
  # ABSTRACT: scaffolder: perl: known issues
  
  use Moose::Role;
  
  has 'known_incorrect_name_fixes' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'App::Fatpacker'            => 'App::FatPacker',
              'Test::YAML::Meta::Version' => 'Test::YAML::Meta', # not sure about this
              'Net::Server::SS::Prefork'  => 'Net::Server::SS::PreFork',
          }
      },
  );
  
  has 'known_incorrect_version_fixes' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'Data-Swap'         => '0.08',
              'Encode-HanConvert' => '0.35',
              'ExtUtils-Constant' => '0.23',
              'Frontier-RPC'      => '0.07',
              'IO-Capture'        => '0.05',
              'Memoize-Memcached' => '0.04',
              'Statistics-Regression' => '0.53',
          }
      },
  );
  
  has 'known_incorrect_dependencies' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'Module-Install' => {
                  'libwww-perl' => 1,
                  'PAR-Dist'    => 1,
              },
              'libwww-perl'    => {
                  'NTLM' => 1,
              },
          }
      },
  );
  
  has 'known_modules_to_skip' => (
      'is'      => 'ro',
      'isa'     => 'HashRef',
      'default' => sub {
          +{
              'perl'                    => 1,
              'tinyperl'                => 1,
              'perl_mlb'                => 1,
              'HTTP::GHTTP'             => 1,
              'Text::MultiMarkdown::XS' => 1, # ADOPTME
              'URI::file'               => 1, # in URI, appears with weird version
              'URI::Escape'             => 1, # in URI, appears with weird version
          }
      },
  );
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_PERL_ROLE_BORKED

$fatpacked{"Pakket/Scaffolder/Role/Backend.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_ROLE_BACKEND';
  package Pakket::Scaffolder::Role::Backend;
  # ABSTRACT: scaffolder: role for backend
  
  use Moose::Role;
  
  use HTTP::Tiny;
  
  requires 'run';
  
  has extract => (
      is      => 'ro',
      isa     => 'Bool',
      default => 0,
  );
  
  has ua => (
      is      => 'ro',
      lazy    => 1,
      builder => '_build_ua',
  );
  
  sub _build_ua {
      return HTTP::Tiny->new();
  }
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_ROLE_BACKEND

$fatpacked{"Pakket/Scaffolder/Role/Terminal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_SCAFFOLDER_ROLE_TERMINAL';
  package Pakket::Scaffolder::Role::Terminal;
  # ABSTRACT: scaffolder: role for output handling
  
  use Moose::Role;
  
  has depth => (
      is      => 'ro',
      isa     => 'Num',
      default => 0,
      writer  => 'set_depth',
  );
  
  sub spaces {
      my $self = shift;
      return ' 'x( $self->depth * 2 );
  }
  
  
  no Moose::Role;
  1;
  __END__
PAKKET_SCAFFOLDER_ROLE_TERMINAL

$fatpacked{"Pakket/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_TUTORIAL';
  package Pakket::Tutorial;
  # ABSTRACT: A beginner's tutorial to Pakket
  
  use strict;
  use warnings;
  
  1;
  
  __END__
  
  =pod
  
  =head1 Installing Pakket
  
  First, you will need to install Pakket. There is more than one way to
  do this.
  
  Pakket uses Perl 5.22.2. While it is not required, we recommend having
  it on local installations.
  
  =head2 Install from CPAN
  
  Once Pakket is released to CPAN, you could install it manually using
  using L<cpan>, L<cpanm>, C<cpm>, or any other client.
  
      $ cpan Pakket
      # or
      $ cpanm Pakket
      # or
      $ cpm Pakket
  
  =head2 Carton
  
  =over 4
  
  =item * Install C<Carton>
  
      $ cpan Carton
      # or
      $ cpanm Carton
      # or
      $ cpm Carton
  
  =item * Clone the Pakket repo
  
      $ git clone https://github.com/xsawyerx/pakket.git
  
  =item * Set up carton
  
      $ cd pakket
      $ carton
  
  =back
  
  To run pakket:
  
      carton exec perl -Ilib bin/pakket
  
  =head2 Build it yourself
  
  This is the preferred method for setting up a Pakket build machine. You
  only need to have perl 5.10 and above. It will only be used for setting
  up the initial environment.
  
  Pakket provides a small one-file script which you can run in order to
  build all of Pakket in one go. It doesn't need any dependencies at all,
  other than perl 5.10 and above.
  
  First, clone:
  
      $ git clone https://github.com/xsawyerx/pakket.git
  
  Now build a self-contained instance of Pakket:
  
      $ cd pakket
      $ perl tools/seacan-pakket-packed.pl
  
  (You may need to install openssl-devel as a dependency beforehand.)
  
  This will download perl 5.22.2, all of the Perl dependencies Pakket
  requires, and it will create a single tarball with everything put
  together.
  
  Inside there will be a small I<bin> file that runs everything
  without using C<anything> from your system. Once you run this and build
  everything, you can take this tarball into any machine and use Pakket
  without even having perl installed.
  
  Yes! This is an application that comes with everything included, even
  the interpreter!
  
  =head2 RPM or Deb package
  
  This option is not yet available, but we intend to provide builds of
  Pakket as either an C<.rpm> or C<.deb> packages.
PAKKET_TUTORIAL

$fatpacked{"Pakket/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_TYPES';
  package Pakket::Types;
  # ABSTRACT: Type definitions for Pakket
  
  use strict;
  use warnings;
  
  use Moose::Util::TypeConstraints;
  use Carp     qw< croak >;
  use Log::Any qw< $log >;
  use Ref::Util qw< is_ref is_arrayref is_hashref >;
  use Safe::Isa;
  use Module::Runtime qw< require_module >;
  use Pakket::Constants qw<
      PAKKET_DEFAULT_RELEASE
      PAKKET_VALID_PHASES
  >;
  
  # PakketRepositoryBackend
  
  sub _coerce_backend_from_str {
      my $uri = shift;
      $uri = lc($uri);
  
      my ($scheme) = $uri =~ m{^ ( [a-zA-Z0-9_]+ ) :// }xms;
      my $class    = "Pakket::Repository::Backend::$scheme";
  
      eval { require_module($class); 1; } or do {
          croak( $log->critical("Failed to load backend '$class': $@") );
      };
  
      return $class->new_from_uri($uri);
  }
  
  sub _coerce_backend_from_arrayref {
      my $arrayref = shift;
      my ( $name, $data ) = @{$arrayref};
      $name = lc($name);
      $data //= {};
  
      # TODO: Remove that later.
      # For back compatibility with old config.
      if (!is_hashref($data)) {
          my ( $n, @params ) = @{$arrayref};
          $data = { @params };
      }
  
      is_hashref($data)
          or croak( $log->critical('Second arg to backend is not hashref') );
  
      my $class = "Pakket::Repository::Backend::$name";
  
      eval { require_module($class); 1; } or do {
          croak( $log->critical("Failed to load backend '$class': $@") );
      };
  
      return $class->new($data);
  }
  
  subtype 'PakketRepositoryBackend', as 'Object', where {
      $_->$_does('Pakket::Role::Repository::Backend')
          || is_arrayref($_)
          || ( !is_ref($_) && length )
  }, message {
      'Must be a Pakket::Repository::Backend object or a URI string or arrayref'
  };
  
  coerce 'PakketRepositoryBackend', from 'Str',
      via { return _coerce_backend_from_str($_); };
  
  coerce 'PakketRepositoryBackend', from 'ArrayRef',
      via { return _coerce_backend_from_arrayref($_); };
  
  # PakketRelease
  
  subtype 'PakketRelease', as 'Int';
  
  coerce 'PakketRelease', from 'Undef',
      via { return PAKKET_DEFAULT_RELEASE() };
  
  # PakketVersioning
  
  subtype 'PakketVersioning', as 'Object',
  where { $_->$_does('Pakket::Role::Versioning') };
  
  coerce 'PakketVersioning', from 'Str',
  via {
      my $type  = $_;
      my $class = "Pakket::Versioning::$type";
  
      eval {
          require_module($class);
          1;
      } or do {
          my $error = $@ || 'Zombie error';
          croak( $log->critical("Could not load versioning module ($type)") );
      };
  
      return $class->new();
  };
  
  # PakketPhase
  
  enum 'PakketPhase' => [ keys %{PAKKET_VALID_PHASES()} ];
  
  no Moose::Util::TypeConstraints;
  
  1;
  
  __END__
  
  =pod
PAKKET_TYPES

$fatpacked{"Pakket/Uninstaller.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UNINSTALLER';
  package Pakket::Uninstaller;
  
  # ABSTRACT: Uninstall pakket packages
  
  use Moose;
  use MooseX::StrictConstructor;
  use Carp qw< croak >;
  use Path::Tiny qw< path  >;
  use Types::Path::Tiny qw< Path  >;
  use Log::Any qw< $log >;
  
  use Pakket::Log qw< log_success log_fail >;
  
  with qw<
      Pakket::Role::HasInfoFile
      Pakket::Role::HasLibDir
  >;
  
  has 'packages' => (
      'is'       => 'ro',
      'isa'      => 'ArrayRef',
      'required' => 1,
  );
  
  has 'without_dependencies' => (
      'is'      => 'ro',
      'isa'     => 'Bool',
      'default' => 0,
  );
  
  sub get_list_of_packages_for_uninstall {
      my $self = shift;
  
      @{ $self->packages }
          or croak( $log->critical('Did not receive any packages to uninstall') );
  
      my $info_file  = $self->load_info_file($self->active_dir);
      my @packages_for_uninstall
          = $self->get_packages_available_for_uninstall($info_file);
  
      return @packages_for_uninstall;
  }
  
  sub uninstall {
      my $self = shift;
  
      my $info_file  = $self->load_info_file($self->active_dir);
      my @packages_for_uninstall
          = $self->get_packages_available_for_uninstall($info_file);
      unless ( 0 + @packages_for_uninstall ) {
          $log->notice("Don't have any packages for uninstall");
          return;
      }
  
      foreach my $package (@packages_for_uninstall) {
          $self->delete_package( $info_file, $package );
      }
  
      $self->save_info_file( $self->work_dir, $info_file );
      $self->activate_work_dir;
  
      $log->infof(
          "Finished uninstalling %d packages from %s",
          0 + @packages_for_uninstall,
          $self->pakket_dir
      );
  
      log_success(
          "Finished uninstalling:\n"
              . join( "\n",
              map { $_->{category} . "/" . $_->{name} }
                  @packages_for_uninstall )
      );
  
      $self->remove_old_libraries();
  
      return;
  }
  
  sub get_packages_available_for_uninstall {
      my ( $self, $info_file ) = @_;
  
      # Algorithm
      # Walk through requested packages and their dependency tree and mark them 'to_delete'
      # Walk through all installed packages without 'to_delete' and their dependencies and mark them 'keep_it'
      # Remove all packages which have 'to_delete' and missing 'keep_it'
      #
      # Special case: throw an error if user explicitly wants to remove packages ('delete_by_requirements'),
      # but that packages is required by any packages from the list 'keep_it.
  
      #mark packages for uninstall as 'to_delete' and 'to_delete_by_requerement'
      my $installed_packages = $info_file->{'installed_packages'};
      my @queue;
      my ( %to_delete, %to_delete_by_requirements );
      foreach my $package ( @{ $self->packages } ) {
          $installed_packages->{ $package->{category} }{ $package->{name} }
              or croak( $log->critical(
                  "Package $package->{category}/$package->{name} doesn't exists"
              ) );
  
          $to_delete{ $package->{category} }{ $package->{name} }++ and next;
          push @queue, $package;
          $to_delete_by_requirements{ $package->{category} }
              { $package->{name} }++;
      }
  
      # walk through dependencies and mark them as 'to delete'
      if ( !$self->without_dependencies ) {
          while ( 0 + @queue ) {
              my $package  = shift @queue;
              my $category = $package->{'category'};
              my $name = $package->{'name'};
              exists $installed_packages->{$category}
                  and exists $installed_packages->{$category}{$name}
                      or next;
  
              my $prereqs = $installed_packages->{$category}{$name}{'prereqs'};
  
              for my $category ( keys %$prereqs ) {
                  for my $type ( keys %{ $prereqs->{$category} } ) {
                      for my $name ( keys %{ $prereqs->{$category}{$type} } ) {
                          $to_delete{$category}{$name}++ and next;
                          push @queue,
                              { 'category' => $category, 'name' => $name };
                      }
                  }
              }
          }
      }
  
      #select all package without 'to_delete' and mark them and theirs dependencies as 'keep_it'
      my %keep_it;
      foreach my $category ( keys %$installed_packages ) {
          foreach my $name ( keys %{ $installed_packages->{$category} } ) {
              $to_delete{$category}{$name} and next;
              $keep_it{$category}{$name}++ and next;
  
              # walk through dependencies
              @queue = ( { category => $category, name => $name } );
              while ( 0 + @queue ) {
                  my $package  = shift @queue;
                  my $pr_category = $package->{'category'};
                  my $pr_name = $package->{'name'};
  
                  exists $installed_packages->{$pr_category}
                      and exists $installed_packages->{$pr_category}{$pr_name}
                          or next;
  
                  my $prereqs = $installed_packages->{$pr_category}
                                                      ->{$pr_name}{'prereqs'};
  
                  for my $category ( keys %$prereqs ) {
                      for my $type ( keys %{ $prereqs->{$category} } ) {
                          for my $name (
                              keys %{ $prereqs->{$category}{$type} } )
                          {
                              $keep_it{$category}{$name}++ and next;
                              $to_delete_by_requirements{$category}{$name}
                                  and croak( $log->critical(
                                      "Can't uninstall package $category/$name, "
                                     . "it's required by $pr_category/$pr_name"
                                  ));
                              push @queue,
                                  { 'category' => $category, 'name' => $name };
                              delete $to_delete{$category}{$name};
                          }
                      }
                  }
              }
          }
      }
  
      my @packages_for_uninstall;
      for my $category ( keys %to_delete ) {
          for my $name ( keys %{ $to_delete{$category} } ) {
              push @packages_for_uninstall,
                  { 'category' => $category, 'name' => $name };
          }
      }
      return @packages_for_uninstall;
  }
  
  sub delete_package {
      my ( $self, $info_file, $package ) = @_;
      my $info = delete $info_file->{installed_packages}{ $package->{category} }
          { $package->{name} };
      $log->debugf( "Deleting package %s/%s",
          $package->{category}, $package->{name} );
  
      for my $file ( @{ $info->{files} } ) {
          delete $info_file->{installed_files}{$file};
          my ($file_name) = $file =~ /\w+\/(.+)/;
          my $path = $self->work_dir->child($file_name);
          $log->debugf( "Deleting file %s", $path );
          $path->exists and !$path->remove
              and $log->error("Could not remove $path: $!");
  
          # remove parent dirs while there are no children
          my $parent = $path->parent;
          while ( !( 0 + $parent->children ) ) {
              $log->debugf( "Deleting directory %s", $parent );
              rmdir $parent;
              $parent = $parent->parent;
          }
  
      }
      return;
  }
  
  __PACKAGE__->meta->make_immutable;
  
  no Moose;
  
  1;
  
  __END__
PAKKET_UNINSTALLER

$fatpacked{"Pakket/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS';
  package Pakket::Utils;
  # ABSTRACT: Utilities for Pakket
  
  use strict;
  use warnings;
  use version 0.77;
  
  use Exporter qw< import >;
  use JSON::MaybeXS;
  
  our @EXPORT_OK = qw<
      is_writeable
      generate_env_vars
      canonical_package_name
      encode_json_canonical
      encode_json_pretty
  >;
  
  sub is_writeable {
      my $path = shift; # Path::Tiny objects
  
      while ( !$path->is_rootdir ) {
          $path->exists and return -w $path;
          $path = $path->parent;
      }
  
      return -w $path;
  }
  
  sub generate_env_vars {
      my ( $build_dir, $prefix, $opts, $manual_env_vars ) = @_;
      my $lib_path       = generate_lib_path($prefix);
      my $bin_path       = generate_bin_path($prefix);
      my $pkgconfig_path = generate_pkgconfig_path($prefix);
  
      my $inc = $opts->{'inc'} || '';
      $manual_env_vars //= {};
  
      my @perl5lib = (
          $prefix->child(qw<lib perl5>)->absolute->stringify,
          $inc,
          $build_dir,
      );
  
      my %perl_opts = (
          'PERL5LIB'                  => join( ':', @perl5lib ),
          'PERL_LOCAL_LIB_ROOT'       => '',
          'PERL5_CPAN_IS_RUNNING'     => 1,
          'PERL5_CPANM_IS_RUNNING'    => 1,
          'PERL5_CPANPLUS_IS_RUNNING' => 1,
          'PERL_MM_USE_DEFAULT'       => 1,
          'PERL_MB_OPT'               => '',
          'PERL_MM_OPT'               => '',
      );
  
      return (
          'CPATH'           => generate_cpath($prefix),
          'PKG_CONFIG_PATH' => $pkgconfig_path,
          'LD_LIBRARY_PATH' => $lib_path,
          'LIBRARY_PATH'    => $lib_path,
          'PATH'            => $bin_path,
          %perl_opts,
          %{$manual_env_vars},
      );
  }
  
  sub generate_cpath {
      my $prefix = shift;
      my $cpath = '';
  
      my $include_dir = $prefix->child('include');
      if ( $include_dir->exists ) {
          my @paths = ( $include_dir->stringify );
          push @paths,  map { $_->stringify } grep { $_->is_dir } $include_dir->children();
          $cpath = join(":", @paths);
      }
  
      return $cpath;
  }
  
  sub generate_lib_path {
      my $prefix = shift;
  
      my $lib_path = $prefix->child('lib')->absolute->stringify;
      if ( defined( my $env_library_path = $ENV{'LD_LIBRARY_PATH'} ) ) {
          $lib_path .= ":$env_library_path";
      }
  
      return $lib_path;
  }
  
  sub generate_bin_path {
      my $prefix = shift;
  
      my $bin_path = $prefix->child('bin')->absolute->stringify;
      if ( defined( my $env_bin_path = $ENV{'PATH'} ) ) {
          $bin_path .= ":$env_bin_path";
      }
  
      return $bin_path;
  }
  
  sub generate_pkgconfig_path {
      my $prefix = shift;
  
      my $pkgconfig_path = $prefix->child('lib/pkgconfig')->absolute->stringify;
      if ( defined( my $env_pkgconfig_path = $ENV{'PKG_CONFIG_PATH'} ) ) {
          $pkgconfig_path .= ":$env_pkgconfig_path";
      }
  
      return $pkgconfig_path;
  }
  
  sub canonical_package_name {
      my ( $category, $package, $version, $release ) = @_;
  
      if ( $version && $release ) {
          return sprintf '%s/%s=%s:%s', $category, $package, $version, $release;
      }
  
      if ($version) {
          return sprintf '%s/%s=%s', $category, $package, $version;
      }
  
      return sprintf '%s/%s', $category, $package;
  }
  
  sub encode_json_canonical {
      my $content = shift;
      return JSON::MaybeXS->new->canonical->encode($content);
  }
  
  sub encode_json_pretty {
      my $content = shift;
      return JSON::MaybeXS->new->pretty->canonical->encode($content);
  }
  
  1;
  
  __END__
PAKKET_UTILS

$fatpacked{"Pakket/Utils/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS_PERL';
  package Pakket::Utils::Perl;
  # ABSTRACT: Perl specific utilities for Pakket
  
  use strict;
  use warnings;
  use version 0.77;
  use Exporter   qw< import >;
  use Path::Tiny qw< path   >;
  use Module::CoreList;
  
  our @EXPORT_OK = qw< list_core_modules should_skip_core_module >;
  
  sub list_core_modules {
      ## no critic qw(Variables::ProhibitPackageVars)
      return \%Module::CoreList::upstream;
  }
  
  sub should_skip_core_module {
      my $name = shift;
  
      if ( Module::CoreList::is_core($name) and !${Module::CoreList::upstream}{$name} ) {
          return 1;
      }
  
      return 0;
  }
  
  1;
PAKKET_UTILS_PERL

$fatpacked{"Pakket/Utils/Repository.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_UTILS_REPOSITORY';
  package Pakket::Utils::Repository;
  # ABSTRACT: Repository utility functions
  
  use strict;
  use warnings;
  use parent 'Exporter';
  
  use Carp qw< croak >;
  use Path::Tiny qw< path >;
  
  our @EXPORT_OK = (qw< gen_repo_config >);
  
  my %file_ext = (
      'spec'   => 'ini',
      'source' => 'spkt',
      'parcel' => 'pkt',
  );
  
  sub gen_repo_config {
      my ( $self, $type, $directory ) = @_;
      $directory or return;
  
      if ( $directory =~ m{^(https?)://([^/:]+):?([^/]+)?(/.*)?$} ) {
          my ( $protocol, $host, $port, $base_path ) = ( $1, $2, $3, $4 );
          $port or $port = $protocol eq 'http' ? 80 : 443;
  
          return [
              'HTTP',
              'host'      => $host,
              'port'      => $port,
              'base_path' => $base_path,
          ];
      } else {
          my $path = path($directory);
          $path->exists && $path->is_dir
              or croak("Bad directory for $type repo: $path\n");
  
          return [
              'File',
              'directory'      => $directory,
              'file_extension' => $file_ext{$type},
          ];
  
      }
  
      return;
  }
  
  1;
  __END__
PAKKET_UTILS_REPOSITORY

$fatpacked{"Pakket/Versioning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_VERSIONING';
  package Pakket::Versioning;
  # ABSTRACT: A versioning class
  
  use Moose;
  use MooseX::StrictConstructor;
  use Pakket::Types;
  use Carp            qw< croak >;
  use Log::Any        qw< $log >;
  use Module::Runtime qw< require_module >;
  
  has 'type' => (
      'is'       => 'ro',
      'isa'      => 'PakketVersioning',
      'coerce'   => 1,
      'required' => 1,
      'handles'  => [ 'compare' ],
  );
  
  sub parse_req_string {
      my ( $self, $req_string ) = @_;
  
      # A filter string is a comma-separated list of conditions
      # A condition is of the form "OP VER"
      # OP is >=, <=, !=, ==, >, <
      # VER is a version string valid for the version module
      # Whitespace is ignored
      my @conditions = split /,/xms, $req_string;
      my $cond_regex = qr/^ \s* (>=|<=|==|!=|>|<) \s* (\S*) \s* $/xms;
      my @filters;
      foreach my $condition (@conditions) {
          if ( $condition !~ $cond_regex ) {
              $condition = ">= $condition";
          }
  
          my @filter = $condition =~ $cond_regex;
          push @filters, \@filter;
      }
  
      return \@filters;
  }
  
  my %op_map = (
      '>=' => sub { $_[0] >= 0 },
      '<=' => sub { $_[0] <= 0 },
      '==' => sub { $_[0] == 0 },
      '!=' => sub { $_[0] != 0 },
      '>'  => sub { $_[0] >  0 },
      '<'  => sub { $_[0] <  0 },
  );
  
  sub filter_version {
      my ( $self, $req_string, $versions ) = @_;
  
      foreach my $filter ( @{ $self->parse_req_string($req_string) } ) {
          my ( $op, $req_version ) = @{$filter};
  
          @{$versions}
              = grep +( $op_map{$op}->( $self->compare( $_, $req_version ) ) ),
              @{$versions};
      }
  
      return;
  }
  
  sub latest {
      my ( $self, $category, $name, $req_string, @versions ) = @_;
  
      # Filter all @versions based on $req_string
      $self->filter_version( $req_string, \@versions );
  
      @versions
          or croak( $log->criticalf('No versions provided for %s/%s', $category, $name) );
  
      # latest_version
      my $latest;
      foreach my $version (@versions) {
          if ( !defined $latest ) {
              $latest = $version;
              next;
          }
  
          if ( $self->compare( $latest, $version ) < 0 ) {
              $latest = $version;
          }
      }
  
      return $latest;
  }
  
  sub is_satisfying {
      my ( $self, $req_string, @versions ) = @_;
  
      # Filter all @versions based on $req_string
      $self->filter_version( $req_string, \@versions );
  
      return !!( @versions > 0 );
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_VERSIONING

$fatpacked{"Pakket/Versioning/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_VERSIONING_PERL';
  package Pakket::Versioning::Perl;
  # ABSTRACT: A Perl-style versioning class
  
  use Moose;
  use MooseX::StrictConstructor;
  use version 0.77;
  
  with qw< Pakket::Role::Versioning >;
  
  sub compare {
      my ($ver1, $rel1) = split(/:/, $_[1]);
      my ($ver2, $rel2) = split(/:/, $_[2]);
      $rel1 //= 1;
      $rel2 //= 1;
      return (version->parse($ver1) <=> version->parse($ver2)
              or $rel1 <=> $rel2);
  }
  
  no Moose;
  __PACKAGE__->meta->make_immutable;
  
  1;
PAKKET_VERSIONING_PERL

$fatpacked{"Pakket/Web/App.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_WEB_APP';
  package Pakket::Web::App;
  # ABSTRACT: The Pakket web application
  
  use Dancer2 0.204001 'appname' => 'Pakket::Web'; # decode_json
  use Log::Any qw< $log >;
  use List::Util qw< first >;
  use Path::Tiny ();
  use Pakket::Web::Repo;
  use constant {
      'PATHS' => [
          $ENV{'PAKKET_WEB_CONFIG'} || (),
          '~/.pakket-web.json',
          '/etc/pakket-web.json',
      ],
  };
  
  sub setup {
      my ( $class, $config_file ) = @_;
  
      $config_file //= first { Path::Tiny::path($_)->exists } @{ PATHS() }
          or die $log->fatal(
              'Please specify a config file: PAKKET_WEB_CONFIG, '
            . '~/.pakket-web.json, or /etc/pakket-web.json.',
          );
  
      my $config = decode_json( Path::Tiny::path($config_file)->slurp_utf8 );
  
      foreach my $repo_config ( @{ $config->{'repositories'} } ) {
          Pakket::Web::Repo->create($repo_config);
      }
  }
  
  1;
  
  __END__
PAKKET_WEB_APP

$fatpacked{"Pakket/Web/Repo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_WEB_REPO';
  package Pakket::Web::Repo;
  # ABSTRACT: A web repository app
  
  use Dancer2 'appname' => 'Pakket::Web';
  use Dancer2::Plugin::Pakket::ParamTypes;
  
  use Carp qw< croak >;
  use Log::Any qw< $log >;
  use Pakket::Repository::Spec;
  use Pakket::Repository::Parcel;
  use Pakket::Repository::Source;
  
  ## no critic qw(Modules::RequireExplicitInclusion)
  
  my %repo_types = (
      'spec'   => sub { return Pakket::Repository::Spec->new(@_);   },
      'source' => sub { return Pakket::Repository::Source->new(@_); },
      'parcel' => sub { return Pakket::Repository::Parcel->new(@_); },
  );
  
  sub create {
      my ( $class, $args ) = @_;
  
      my $repo_type    = $args->{'type'}    or croak(q{Missing 'type'});
      my $repo_path    = $args->{'path'}    or croak(q{Missing 'path'});
      my $repo_backend = $args->{'backend'} or croak(q{Missing 'backend'});
  
      my $repo = $repo_types{$repo_type}->( 'backend' => $repo_backend );
  
      prefix $repo_path => sub {
          get '/has_object' => with_types [
              [ 'query', 'id', 'Str', 'MissingID' ],
          ] => sub {
              my $id = query_parameters->get('id');
  
              return encode_json({
                  'has_object' => $repo->has_object($id),
              });
          };
  
          get '/all_object_ids' => sub {
              return encode_json({
                  'object_ids' => $repo->all_object_ids,
              });
          };
  
          get '/all_object_ids_by_name' => with_types [
              [ 'query', 'name',     'Str', 'MissingName' ],
              [ 'query', 'category', 'Str', 'MissingCategory' ],
          ] => sub {
              my $name     = query_parameters->get('name');
              my $category = query_parameters->get('category');
              return encode_json({
                  'object_ids' => $repo->all_object_ids_by_name($name, $category),
              });
          };
  
          prefix '/retrieve' => sub {
              get '/content' => with_types [
                  [ 'query', 'id', 'Str', 'MissingID' ],
              ] => sub {
                  my $id = query_parameters->get('id');
  
                  return encode_json( {
                      'id'      => $id,
                      'content' => $repo->retrieve_content($id),
                  } );
              };
  
              get '/location' => with_types [
                  [ 'query', 'id', 'Str', 'MissingID' ],
              ] => sub {
                  my $id   = query_parameters->get('id');
                  my $file = $repo->retrieve_location($id);
  
                  # This is already anchored to the repo
                  # (And no user input can change the path it will reach)
                  send_file( $file, 'system_path' => 1 );
              };
          };
  
          prefix '/store' => sub {
              # There is no body to check, because the body is JSON content
              # So we manually decode and check
              post '/content' => sub {
                  my $data    = decode_json( request->body );
                  my $id      = $data->{'id'};
                  my $content = $data->{'content'};
  
                  defined && length
                      or send_error( 'Bad input', 400 )
                      for $id, $content;
  
                  $repo->store_content( $id, $content );
                  return encode_json( { 'success' => 1 } );
              };
  
              post '/location' => with_types [
                  [ 'query', 'id', 'Str',  'MissingID' ],
              ] => sub {
                  my $id   = query_parameters->get('id');
                  my $file = Path::Tiny->tempfile;
                  $file->spew_raw( request->body );
                  $repo->store_location( $id, $file );
                  return encode_json( { 'success' => 1 } );
              };
          };
  
          prefix '/remove' => sub {
              get '/location' => with_types [
                  [ 'query', 'id', 'Str',  'MissingID' ],
              ] => sub {
                  my $id = query_parameters->get('id');
                  $repo->remove_location( $id );
                  return encode_json( { 'success' => 1 } );
              };
  
              get '/content' => with_types [
                  [ 'query', 'id', 'Str',  'MissingID' ],
              ] => sub {
                  my $id = query_parameters->get('id');
                  $repo->remove_content( $id );
                  return encode_json( { 'success' => 1 } );
              };
          };
      };
  }
  
  1;
PAKKET_WEB_REPO

$fatpacked{"Pakket/Web/Server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PAKKET_WEB_SERVER';
  package Pakket::Web::Server;
  # ABSTRACT: Start a Pakket server
  
  use Moose;
  use MooseX::StrictConstructor;
  
  use Log::Any qw< $log >;
  use Plack::Runner;
  
  use Pakket::Web::App;
  
  has 'port' => (
      'is'        => 'ro',
      'isa'       => 'Int',
      'predicate' => 'has_port',
  );
  
  sub run {
      my $self = shift;
  
      Pakket::Web::App->setup();
      my $app    = Pakket::Web::App->to_app;
      my $runner = Plack::Runner->new();
  
      my @runner_opts = (
          $self->has_port ? ( '--port', $self->port ) : (),
      );
  
      $runner->parse_options(@runner_opts);
      return $runner->run($app);
  }
  
  __PACKAGE__->meta->make_immutable;
  no Moose;
  
  1;
  
  __END__
PAKKET_WEB_SERVER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# XXX
# This script needs to be fatpacked when done.
# In order to do this, please use the pre-commit hook
# available in the tools/git-hooks directory, as such:
# ( cd .git/hooks && ln -s ../../tools/git-hooks/pre-commit )
# XXX

use strict;
use warnings;
use constant {
    'DEFAULT_PERL_VERSION' => '5.22.2',
};

use English    '-no_match_vars';
use Path::Tiny qw<path tempdir>;
use Getopt::Long qw<:config no_ignore_case>;
use App::Seacan;
use IPC::Open3 qw<open3>;

sub print_help {
    my $error   = shift;
    my $min_ver = DEFAULT_PERL_VERSION();

    $error and print "[ERROR] $error\n\n";

    print << "_END_HELP";
$PROGRAM_NAME [--perl PERL_VER] --app-dir DIR

Options:

--perl        Perl version (default: $min_ver)
--app-dir     Application directory (default: .)
--files       Additional files for inclusion
              (Specify multiple times for each file)

_END_HELP

    exit 2;
}

my $app_dir = path('.');
Getopt::Long::GetOptions(
    'perl=s'    => \( my $perl_version = DEFAULT_PERL_VERSION() ),
    'app-dir=s' => \$app_dir,
    'files=s@'  => \my @additional_files,
    'help'      => \my $help,
);

$help and print_help();

-d $app_dir or print_help('--app-dir must point to a directory');

my $cores = 1;
if ( $OSNAME =~ /linux/xms ) {
    local $SIG{'CHLD'} = 'IGNORE';
    my ( $writer, $reader, $err );
    open3( $writer, $reader, $err, 'nproc' );
    chomp( $cores = <$reader> );
}

if ( $cores > 1 ) {
    $cores -= 1;
}

my @directories  = qw<bin lib>;
my $top_src_dir  = tempdir( 'CLEANUP' => 1 );
my $top_dest_dir = tempdir( 'CLEANUP' => 1 );
my $dest_dir     = $top_dest_dir->child('pakket');
my $source_dir   = $top_src_dir->child('pakket');

$dest_dir->mkpath();
$source_dir->mkpath();

foreach my $dir (@directories) {
    path($dir)->visit(
        sub {
            my $next = shift;

            $next->is_file
                or return;

            my $next_dir  = $next->parent;
            my $next_path = $source_dir->child($next_dir);
            $next_path->mkpath();

            print "Copy $next -> $next_path\n";
            $next->copy($next_path);
        },
        { 'recurse' => 1 },
    );
}

# cpanfile must be there so "cpanm" would work on the app
foreach my $node ( @additional_files, 'cpanfile' ) {
    my $file = path($node);
    print "Copy $file -> $source_dir\n";
    $file->copy( $source_dir->child($file) );
}

my $seacan = App::Seacan->new(
    'config' => {

        'seacan' => {
            'app_name' => 'pakket',
            'output'   => $dest_dir,
            'app'      => $source_dir,
        },

        'perl' => {
            'version'             => $perl_version,
                'installed_as'    => 'seacan',
                'notest'          => 1,
                'noman'           => 1,
                'relocatable_INC' => 1,
                'parallel'        => $cores,
        },
    },
);

$seacan->run;

print "Finished!\n";
my @cmd = ( 'tar', '--create', '--gzip', '--exclude-vcs', "--directory=$top_dest_dir",
    '--file=' . path('pakket.tar.gz')->absolute, '.', );
print join(" ", @cmd, "\n");
system(@cmd);
