#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Seacan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_SEACAN';
  package App::Seacan;
  use strict;
  use warnings;
  use constant { 'EXEC_MODE' => '0755' };

  # Semantic Vesioning: http://semver.org/
  # Not sure if I want to use v-string, but I do want to follow
  # semvar as a convention.
  our $VERSION = "0.1.0";

  use English qw<-no_match_vars>;
  use Mo qw<required coerce>;
  use TOML qw<from_toml>;
  use Path::Tiny qw<path>;

  has config => (
      required => 1,
      coerce   => sub {
          my $c = $_[0];

          if ( !ref($c) && -f $c ) {
              $c = from_toml( path($c)->slurp_utf8 );
          }

          $c->{perl}{installed_as} //= "seacan";

          return $c;
      }
  );

  sub seacan_perlbrew_root {
      my $self = shift;
      return path($self->config->{seacan}{output}, "perlbrew");
  }

  sub seacan_perl {
      my $self = shift;
      return $self->seacan_perlbrew_root->child(
          'perls',
          $self->config->{perl}{installed_as},
          'bin',
          'perl',
     );
  }

  sub perl_is_installed {
      my $self = shift;

      my $perlbrew_root_path
          = path( $self->config->{seacan}{output}, 'perlbrew' );

      $perlbrew_root_path->is_dir
          or return 0;

      my $perl_executable = $perlbrew_root_path->child(
          'perls',
          $self->config->{perl}{installed_as},
          'bin',
          'perl',
      );

      if ( $perl_executable->is_file ) {
          print STDERR "perl is installed: $perl_executable\n";
          return 1;
      }

      return 0;
  }

  sub install_perl {
      my $self = shift;

      my $perlbrew_root_path = $self->seacan_perlbrew_root;

      # FIXME: Shouldn't this use 'safe' => 0 ?
      $perlbrew_root_path->is_dir
          or $perlbrew_root_path->mkpath();

      for (keys %ENV) {
          delete $ENV{$_} if /\APERLBREW_/;
      }
      delete $ENV{PERL_CPANM_OPT};
      delete $ENV{PERL_LOCAL_LIB_ROOT};
      delete $ENV{PERL_MB_OPT};
      delete $ENV{PERL_MM_OPT};
      delete $ENV{PERL5LIB};

      $ENV{PERLBREW_ROOT} = $perlbrew_root_path;

      system("curl -L https://install.perlbrew.pl | bash") == 0 or die $!;
      my $perlbrew_command = path($perlbrew_root_path, "bin", "perlbrew");

      my @perl_install_cmd = (
          $perlbrew_command,
          "install", $self->config->{perl}{version},
          "--as",    $self->config->{perl}{installed_as},

          $self->config->{perl}{relocatable_INC}
              ? ("-Duserelocatableinc")
              : (),

          $self->config->{perl}{noman}
              ? ("--noman")
              : (),

          $self->config->{perl}{notest}
              ? ("--notest")
              : (),

          $self->config->{perl}{parallel}
              ? ("-j", $self->config->{perl}{parallel})
              : (),
      );
      system(@perl_install_cmd) == 0 or die $!;

      system($perlbrew_command, "install-cpanm", "--force");

      system($perlbrew_command, "clean");
  }

  sub install_cpan {
      my $self = shift;
      my $cpanm_command = $self->seacan_perlbrew_root->child( "bin", "cpanm");
      my $perl_command = $self->seacan_perl;

      local $OUTPUT_FIELD_SEPARATOR = q{ };
      system($perl_command, $cpanm_command, "--notest", "-L", path($self->config->{seacan}{output}, "local"), "--installdeps", $self->config->{seacan}{app} ) == 0 or die $!;
  }

  sub copy_app {
      my $self = shift;
      my $target_directory = path($self->config->{seacan}{output}, "app", $self->config->{seacan}{app_name});
      my $source_directory = $self->config->{seacan}{app};

      $target_directory->mkpath();

      unless ( $source_directory =~ m{/$} ) {
          # this is telling rsync to copy the contents of $source_directory
          # instead of $source_directory itself
          $source_directory .= "/";
      }

      system("rsync", "-8vPa", $source_directory, $target_directory) == 0 or die;
  }

  sub create_launcher {
      # Instead of giving a very long command to the user
      # a launcher script is generated.
      # app_name and main_script could be added to the configuration
      # so we can add the info directly instead of "guessing" it
      # through a regex.

      my $self = shift;
      my $output = $self->config->{seacan}{output};

      # The launcher script goes into bin of the target directory
      my $target_directory = path($output, 'bin');

      my $app_name = $self->config->{seacan}{app_name};
      if ( !$app_name ) {
          # This is a hack to determine the application name from the
          # output value of the config in case it wasn't provided

          $app_name = $output;
          $app_name =~ s/^.+\/(.+?)$/$1/;
      }

      # Apps following the CPAN guidelines have a lib directory with the
      # modules. Adding this to the PERL5LIB allows to run this distributions
      # without installing them.
      my $launcher_path = $target_directory->child($app_name);
      $target_directory->mkpath();

      $launcher_path->spew_utf8(
          "#!/bin/bash\n",
          'CURRDIR=$(dirname $(readlink -f $0))' . "\n",
          "PERL5LIB=\$CURRDIR/../local/lib/perl5:\$CURRDIR/../app/$app_name/lib\n",
          "export PERL5LIB\n",

          # String "app" shouldn't be hardcoded and be part of the config
          # app.pl will not be the likely name of the main script.
          "\$CURRDIR/../perlbrew/perls/seacan/bin/perl \$CURRDIR/../app/$app_name/bin/$app_name \$@\n",
      );

      $launcher_path->chmod( EXEC_MODE() );
  }

  sub run {
      my $self = shift;
      $self->install_perl unless $self->perl_is_installed;
      $self->install_cpan;
      $self->copy_app;
      $self->create_launcher;
  }

  1;

  =encoding utf-8

  =head1 NAME

  Seacan - A tool to prepare a self-contained app directory.

  =head1 USAGE

  Let's say I want to make a distribution for my app named "CoffeeChair".

  First, prepare a configuration file in TOML format, named C<coffeechair_seacan.toml>

      [seacan]
      output = "/opt/CoffeeChair"
      app = "/src/CoffeeChair"
      app_name = "CoffeeChair.pl"

      [perl]
      version = "5.20.0"
      configure_args = "-Dusethreads"

  Noted that The source code of the CoffeeChair must be placed at C<"/src/CoffeeChair"> first.

  Now, build the the distribution with this, the output directory
  C</opt/CoffeeChair> will be filled by this process:

      seacan coffeechair_seacan.toml

  Here's how the directyr looks like:

      - /opt/CoffeeChair
        - perlbrew/perls/seacan-perl
        - local/
        - app/CoffeeChair

  Afterwards, invoking commands like this:

      PERL5LIB=/opt/Coffeechair/local/lib/perl5 /opt/CoffeeChair/perlbrew/perls/seacan-perl/bin/perl /opt/CoffeeChair/app/CoffeeChair/bin/app.pl

  Or alternatively, a launcher script with the that command can be found at:

       /opt/CoffeeChair/bin/CoffeeChair

  =head1 AUTHORS

  Kang-min Liu C<< <gugod@gugod.org> >>

  =head1 LICENCE

  The MIT License

  =head1 DISCLAIMER OF WARRANTY

  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.

  =cut
APP_SEACAN

$fatpacked{"Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO';
  package Mo;
  $Mo::VERSION = '0.40';
  $VERSION='0.40';
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{my$c=shift;my$s=bless{@_},$c;my%n=%{$c.'::'.':E'};map{$s->{$_}=$n{$_}->()if!exists$s->{$_}}keys%n;$s};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};
MO

$fatpacked{"Mo/Golf.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_GOLF';
  ##
  # name:      Mo::Golf
  # abstract:  Module for Compacting Mo Modules
  # author:    Ingy dÃ¶t Net <ingy@ingy.net>
  # license:   perl
  # copyright: 2011
  # see:
  # - Mo

  use strict;
  use warnings;
  package Mo::Golf;

  our $VERSION='0.40';

  use PPI;

  # This is the mapping of common names to shorter forms that still make some
  # sense.
  my %short_names = (
      (
          map {($_, substr($_, 0, 1))}
          qw(
              args builder class default exports features
              generator import is_lazy method MoPKG name
              nonlazy_defaults options reftype self
          )
      ),
      build_subs => 'B',
      old_constructor => 'C',
      caller_pkg => 'P',
  );

  my %short_barewords = ( EAGERINIT => q{':E'}, NONLAZY => q{':N'} );

  my %hands_off = map {($_,1)} qw'&import *import';

  sub import {
      return unless @_ == 2 and $_[1] eq 'golf';
      binmode STDOUT;
      my $text = do { local $/; <> };
      print STDOUT golf( $text );
  };

  sub golf {
      my ( $text ) = @_;

      my $tree = PPI::Document->new( \$text );

      my %finder_subs = _finder_subs();

      my @order = qw( comments duplicate_whitespace whitespace trailing_whitespace );

      for my $name ( @order ) {
          my $elements = $tree->find( $finder_subs{$name} );
          die $@ if !defined $elements;
          $_->delete for @{ $elements || [] };
      }

      $tree->find( $finder_subs{$_} )
        for qw( del_superfluous_concat del_last_semicolon_in_block separate_version shorten_var_names shorten_barewords );
      die $@ if $@;

      for my $name ( 'double_semicolon' ) {
          my $elements = $tree->find( $finder_subs{$name} );
          die $@ if !defined $elements;
          $_->delete for @{ $elements || [] };
      }

      return $tree->serialize . "\n";
  }

  sub tok { "PPI::Token::$_[0]" }

  sub _finder_subs {
      return (
          comments => sub { $_[1]->isa( tok 'Comment' ) },

          duplicate_whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );

              $current->set_content(' ') if 1 < length $current->content;

              return 0 if !$current->next_token;
              return 0 if !$current->next_token->isa( tok 'Whitespace' );
              return 1;
          },

          whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );
              my $prev = $current->previous_token;
              my $next = $current->next_token;

              return 1 if $prev->isa( tok 'Number' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # my $P
              return 1 if $prev->isa( tok 'Word' )   and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # my $P
              return 1 if $prev->isa( tok 'Symbol' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; # $VERSION =  but not $v and

              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Single' ) and $next->content =~ /^\W/; # eq ''
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Double' ) and $next->content =~ /^\W/; # eq ""
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Symbol' )        and $next->content =~ /^\W/; # eq $v
              return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Structure' )     and $next->content =~ /^\W/; # eq (

              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Symbol' );           # my $P
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Structure' );        # sub {
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Quote::Double' );    # eval "
              return 1 if $prev->isa( tok 'Symbol' )     and $next->isa( tok 'Structure' );        # %a )
              return 1 if $prev->isa( tok 'ArrayIndex' ) and $next->isa( tok 'Operator' );         # $#_ ?
              return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Cast' );             # exists &$_
              return 0;
          },

          trailing_whitespace => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Whitespace' );
              my $prev = $current->previous_token;

              return 1 if $prev->isa( tok 'Structure' );                                           # ;[\n\s]
              return 1 if $prev->isa( tok 'Operator' ) and $prev->content =~ /\W$/;                # = 0.24
              return 1 if $prev->isa( tok 'Quote::Double' );                                       # " .
              return 1 if $prev->isa( tok 'Quote::Single' );                                       # ' }

              return 0;
          },

          double_semicolon => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Structure' );
              return 0 if $current->content ne ';';

              my $prev = $current->previous_token;

              return 0 if !$prev->isa( tok 'Structure' );
              return 0 if $prev->content ne ';';

              return 1;
          },

          del_last_semicolon_in_block => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( 'PPI::Structure::Block' );

              my $last = $current->last_token;

              return 0 if !$last->isa( tok 'Structure' );
              return 0 if $last->content ne '}';

              my $maybe_semi = $last->previous_token;

              return 0 if !$maybe_semi->isa( tok 'Structure' );
              return 0 if $maybe_semi->content ne ';';

              $maybe_semi->delete;

              return 1;
          },

          del_superfluous_concat => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Operator' );

              my $prev = $current->previous_token;
              my $next = $current->next_token;

              return 0 if $current->content ne '.';
              return 0 if !$prev->isa( tok 'Quote::Double' );
              return 0 if !$next->isa( tok 'Quote::Double' );

              $current->delete;
              $prev->set_content( $prev->{separator} . $prev->string . $next->string . $prev->{separator} );
              $next->delete;

              return 1;
          },

          separate_version => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( 'PPI::Statement' );

              my $first = $current->first_token;
              return 0 if $first->content ne '$VERSION';

              $current->$_( PPI::Token::Whitespace->new( "\n" ) ) for qw( insert_before insert_after );

              return 1;
          },

          shorten_var_names => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Symbol' );

              my $long_name = $current->canonical;

              return 1 if $hands_off{$long_name};
              (my $name = $long_name) =~ s/^([\$\@\%])// or die $long_name;
              my $sigil = $1;
              die "variable $long_name conflicts with shortened var name"
                  if grep {
                      $name eq $_
                  } values %short_names;

              my $short_name = $short_names{$name};
              $current->set_content( "$sigil$short_name" ) if $short_name;

              return 1;
          },

          shorten_barewords => sub {
              my ( $top, $current ) = @_;
              return 0 if !$current->isa( tok 'Word' );

              my $name = $current->content;

              die "bareword $name conflicts with shortened bareword"
                  if grep {
                      $name eq $_
                  } values %short_barewords;

              my $short_name = $short_barewords{$name};
              $current->set_content( $short_name ) if $short_name;

              return 1;
          },
      );
  }

  =head1 SYNOPSIS

      perl -MMo::Golf=golf < src/Mo/foo.pm > lib/Mo/foo.pm

  =head1 DESCRIPTION

  This is the module that is responsible for taking Mo code (which is
  documented and fairly readable) and reducing it to a single undecipherable
  line.
MO_GOLF

$fatpacked{"Mo/Inline.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_INLINE';
  ##
  # name:      Mo::Inline
  # abstract:  Inline Mo and Features into your package
  # author:    Ingy dÃ¶t Net <ingy@ingy.net>
  # license:   perl
  # copyright: 2011
  # see:
  # - Mo

  package Mo::Inline;
  use Mo;

  our $VERSION='0.40';

  use IO::All;

  my $matcher = qr/((?m:^#\s*use Mo(\s.*)?;.*\n))(?:#.*\n)*(?:.{400,}\n)?/;

  sub run {
      my $self = shift;
      my @files;
      if (not @_ and -d 'lib') {
          print "Searching the 'lib' directory for a Mo to inline:\n";
          @_ = 'lib';
      }
      if (not @_ or @_ == 1 and $_[0] =~ /^(?:-\?|-h|--help)$/) {
          print usage();
          return 0;
      }
      for my $name (@_) {
          die "No file or directory called '$name'"
              unless -e $name;
          die "'$name' is not a Perl module"
              if -f $name and $name !~ /\.pm$/;
          if (-f $name) {
              push @files, $name;
          }
          elsif (-d $name) {
              push @_, grep /\.pm$/, map { "$_" } io($name)->All_Files;
          }
      }

      die "No .pm files specified"
          unless @files;

      for my $file (@files) {
          my $text = io($file)->all;
          if ($text !~ $matcher) {
              print "Ignoring $file - No Mo to Inline!\n";
              next;
          }
          $self->inline($file, 1);
      }
  }

  sub inline {
      my ($self, $file, $noisy) = @_;
      my $text = io($file)->all;
      $text =~ s/$matcher/"$1" . &inliner($2)/eg;
      io($file)->print($text);
      print "Mo Inlined $file\n"
          if $noisy;
  }

  sub inliner {
      my $mo = shift;
      require Mo;
      my @features = grep {$_ ne 'qw'} ($mo =~ /(\w+)/g);
      for (@features) {
          eval "require Mo::$_; 1" or die $@;
      }
      my $inline = '';
      $inline .= $_ for map {
          my $module = $_;
          $module .= '.pm';
          my @lines = io($INC{$module})->chomp->getlines;
          $lines[-1];
      } ('Mo', map { s!::!/!g; "Mo/$_" } @features);
      return <<"...";
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version $VERSION
  $inline\@f=qw[@features];use strict;use warnings;
  ...
  }

  sub usage {
      <<'...';
  Usage: mo-linline <perl module files or directories>

  ...
  }

  1;

  =head1 SYNOPSIS

  In your Mo module:

      # This is effectively your own private Mo(ose) setup
      package MyModule::Mo;
      # use Mo qw'build builder default import';
      1;

  From the command line:

      > mo-inline lib/MyModule/Mo.pm

  or:

      > mo-inline lib/

  or (if you are really lazy):

      > mo-inline

  Then from another module:

      package MyModule::Foo;
      use MyModule::Mo;       # gets build, builder and default automatically

  =head1 DESCRIPTION

  Mo is so small that you can easily inline it, along with any feature modules.
  Mo provides a script called C<mo-inline> that will do it for you.

  All you need to do is comment out the line that uses Mo, and run C<mo-inline>
  on the file. C<mo-inline> will find such comments and do the inlining for you.
  It will also replace any old inlined Mo with the latest version.

  What Mo could you possibly want?

  =head1 AUTOMATIC FEATURES

  By using the L<Mo::import> feature, all uses of your Mo class will turn on all
  the features you specified. You can override it if you want, but that will be
  the default.

  =head1 REAL WORLD EXAMPLES

  For real world examples of Mo inlined using C<mo-inline>, see L<YAML::Mo>,
  L<Pegex::Mo> and L<TestML::Mo>.
MO_INLINE

$fatpacked{"Mo/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_MOOSE';
  package Mo::Moose;
  $Mo::Moose::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'Moose::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Moose;Moose->import({into=>$P});Moose::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
  $Attr::Trait::VERSION = '0.40';use Moose::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
MO_MOOSE

$fatpacked{"Mo/Mouse.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_MOUSE';
  package Mo::Mouse;
  $Mo::Mouse::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'Mouse::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Mouse;require Mouse::Util::MetaRole;Mouse->import({into=>$P});Mouse::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
  $Attr::Trait::VERSION = '0.40';use Mouse::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
MO_MOUSE

$fatpacked{"Mo/build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_BUILD';
  package Mo::build;
  $Mo::build::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'build::e'}=sub{my($P,$e)=@_;$e->{new}=sub{$c=shift;my$s=&{$M.Object::new}($c,@_);my@B;do{@B=($c.::BUILD,@B)}while($c)=@{$c.::ISA};exists&$_&&&$_($s)for@B;$s}};
MO_BUILD

$fatpacked{"Mo/builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_BUILDER';
  package Mo::builder;
  $Mo::builder::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=\&{$P.$b}and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};
MO_BUILDER

$fatpacked{"Mo/chain.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_CHAIN';
  package Mo::chain;
  $Mo::chain::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'chain::e'}=sub{my($P,$e,$o)=@_;$o->{chain}=sub{my($m,$n,%a)=@_;$a{chain}or return$m;sub{$#_?($m->(@_),return$_[0]):$m->(@_)}}};
MO_CHAIN

$fatpacked{"Mo/coerce.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_COERCE';
  package Mo::coerce;
  $Mo::coerce::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'coerce::e'}=sub{my($P,$e,$o)=@_;$o->{coerce}=sub{my($m,$n,%a)=@_;$a{coerce}or return$m;sub{$#_?$m->($_[0],$a{coerce}->($_[1])):$m->(@_)}};my$C=$e->{new}||*{$M.Object::new}{CODE};$e->{new}=sub{my$s=$C->(@_);$s->$_($s->{$_})for keys%$s;$s}};
MO_COERCE

$fatpacked{"Mo/default.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_DEFAULT';
  package Mo::default;
  $Mo::default::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=$g and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}};
MO_DEFAULT

$fatpacked{"Mo/exporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_EXPORTER';
  package Mo::exporter;
  $Mo::exporter::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'exporter::e'}=sub{my($P)=@_;if(@{$M.EXPORT}){*{$P.$_}=\&{$M.$_}for@{$M.EXPORT}}};
MO_EXPORTER

$fatpacked{"Mo/import.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IMPORT';
  package Mo::import;
  $Mo::import::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  my$i=\&import;*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};
MO_IMPORT

$fatpacked{"Mo/importer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IMPORTER';
  package Mo::importer;
  $Mo::importer::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'importer::e'}=sub{my($P,$e,$o,$f)=@_;(my$pkg=$P)=~s/::$//;&{$P.'importer'}($pkg,@$f)if defined&{$P.'importer'}};
MO_IMPORTER

$fatpacked{"Mo/is.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_IS';
  package Mo::is;
  $Mo::is::VERSION = '0.40';$M="Mo::";
  $VERSION='0.40';
  *{$M.'is::e'}=sub{my($P,$e,$o)=@_;$o->{is}=sub{my($m,$n,%a)=@_;$a{is}or return$m;sub{$#_&&$a{is}eq'ro'&&caller ne'Mo::coerce'?die$n.' is ro':$m->(@_)}}};
MO_IS

$fatpacked{"Mo/nonlazy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_NONLAZY';
  package Mo::nonlazy;
  $Mo::nonlazy::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'nonlazy::e'}=sub{${shift().':N'}=1};
MO_NONLAZY

$fatpacked{"Mo/option.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_OPTION';
  package Mo::option;
  $Mo::option::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'option::e'}=sub{my($P,$e,$o)=@_;$o->{option}=sub{my($m,$n,%a)=@_;$a{option}or return$m;my$n2=$n;*{$P."read_$n2"}=sub{$_[0]->{$n2}};sub{$#_?$m->(@_):$m->(@_,1);$_[0]}}};
MO_OPTION

$fatpacked{"Mo/required.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_REQUIRED';
  package Mo::required;
  $Mo::required::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  *{$M.'required::e'}=sub{my($P,$e,$o)=@_;$o->{required}=sub{my($m,$n,%a)=@_;if($a{required}){my$C=*{$P."new"}{CODE}||*{$M.Object::new}{CODE};no warnings 'redefine';*{$P."new"}=sub{my$s=$C->(@_);my%a=@_[1..$#_];die$n." required"if!exists$a{$n};$s}}$m}};
MO_REQUIRED

$fatpacked{"Mo/xs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MO_XS';
  package Mo::xs;
  $Mo::xs::VERSION = '0.40';my$M="Mo::";
  $VERSION='0.40';
  require Class::XSAccessor;*{$M.'xs::e'}=sub{my($P,$e,$o,$f)=@_;$P=~s/::$//;$e->{has}=sub{my($n,%a)=@_;Class::XSAccessor->import(class=>$P,accessors=>{$n=>$n})}if!grep!/^xs$/,@$f};
MO_XS

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;

  package Path::Tiny;
  # ABSTRACT: File path utility

  our $VERSION = '0.144';

  # Dependencies
  use Config;
  use Exporter 5.57   (qw/import/);
  use File::Spec 0.86 ();          # shipped with 5.8.1
  use Carp ();

  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;

  use constant {
      PATH     => 0,
      CANON    => 1,
      VOL      => 2,
      DIR      => 3,
      FILE     => 4,
      TEMP     => 5,
      IS_WIN32 => ( $^O eq 'MSWin32' ),
  };

  use overload (
      q{""}    => 'stringify',
      bool     => sub () { 1 },
      fallback => 1,
  );

  # FREEZE/THAW per Sereal/CBOR/Types::Serialiser protocol
  sub THAW   { return path( $_[2] ) }
  { no warnings 'once'; *TO_JSON = *FREEZE = \&stringify };

  my $HAS_UU; # has Unicode::UTF8; lazily populated

  sub _check_UU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          require Unicode::UTF8;
          Unicode::UTF8->VERSION(0.58);
          1;
      };
  }

  my $HAS_PU;              # has PerlIO::utf8_strict; lazily populated

  sub _check_PU {
      local $SIG{__DIE__}; # prevent outer handler from being called
      !!eval {
          # MUST preload Encode or $SIG{__DIE__} localization fails
          # on some Perl 5.8.8 (maybe other 5.8.*) compiled with -O2.
          require Encode;
          require PerlIO::utf8_strict;
          PerlIO::utf8_strict->VERSION(0.003);
          1;
      };
  }

  my $HAS_FLOCK = $Config{d_flock} || $Config{d_fcntl_can_lock} || $Config{d_lockf};

  # notions of "root" directories differ on Win32: \\server\dir\ or C:\ or \
  my $SLASH      = qr{[\\/]};
  my $NOTSLASH   = qr{[^\\/]};
  my $DRV_VOL    = qr{[a-z]:}i;
  my $UNC_VOL    = qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;
  my $WIN32_ROOT = qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;

  sub _win32_vol {
      my ( $path, $drv ) = @_;
      require Cwd;
      my $dcwd = eval { Cwd::getdcwd($drv) }; # C: -> C:\some\cwd
      # getdcwd on non-existent drive returns empty string
      # so just use the original drive Z: -> Z:
      $dcwd = "$drv" unless defined $dcwd && length $dcwd;
      # normalize dwcd to end with a slash: might be C:\some\cwd or D:\ or Z:
      $dcwd =~ s{$SLASH?\z}{/};
      # make the path absolute with dcwd
      $path =~ s{^$DRV_VOL}{$dcwd};
      return $path;
  }

  # This is a string test for before we have the object; see is_rootdir for well-formed
  # object test
  sub _is_root {
      return IS_WIN32() ? ( $_[0] =~ /^$WIN32_ROOT\z/ ) : ( $_[0] eq '/' );
  }

  BEGIN {
      *_same = IS_WIN32() ? sub { lc( $_[0] ) eq lc( $_[1] ) } : sub { $_[0] eq $_[1] };
  }

  # mode bits encoded for chmod in symbolic mode
  my %MODEBITS = ( om => 0007, gm => 0070, um => 0700 ); ## no critic
  { my $m = 0; $MODEBITS{$_} = ( 1 << $m++ ) for qw/ox ow or gx gw gr ux uw ur/ };

  sub _symbolic_chmod {
      my ( $mode, $symbolic ) = @_;
      for my $clause ( split /,\s*/, $symbolic ) {
          if ( $clause =~ m{\A([augo]+)([=+-])([rwx]+)\z} ) {
              my ( $who, $action, $perms ) = ( $1, $2, $3 );
              $who =~ s/a/ugo/g;
              for my $w ( split //, $who ) {
                  my $p = 0;
                  $p |= $MODEBITS{"$w$_"} for split //, $perms;
                  if ( $action eq '=' ) {
                      $mode = ( $mode & ~$MODEBITS{"${w}m"} ) | $p;
                  }
                  else {
                      $mode = $action eq "+" ? ( $mode | $p ) : ( $mode & ~$p );
                  }
              }
          }
          else {
              Carp::croak("Invalid mode clause '$clause' for chmod()");
          }
      }
      return $mode;
  }

  # flock doesn't work on NFS on BSD or on some filesystems like lustre.
  # Since program authors often can't control or detect that, we warn once
  # instead of being fatal if we can detect it and people who need it strict
  # can fatalize the 'flock' category

  #<<< No perltidy
  { package flock; use warnings::register }
  #>>>

  my $WARNED_NO_FLOCK = 0;

  sub _throw {
      my ( $self, $function, $file, $msg ) = @_;
      if (   $function =~ /^flock/
          && $! =~ /operation not supported|function not implemented/i
          && !warnings::fatal_enabled('flock') )
      {
          if ( !$WARNED_NO_FLOCK ) {
              warnings::warn( flock => "Flock not available: '$!': continuing in unsafe mode" );
              $WARNED_NO_FLOCK++;
          }
      }
      else {
          $msg = $! unless defined $msg;
          Path::Tiny::Error->throw( $function, ( defined $file ? $file : $self->[PATH] ),
              $msg );
      }
      return;
  }

  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      if ( defined($raw) && ref($raw) ne 'HASH' ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak("Options for $called_as must be a hash reference");
      }
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      if ( keys %$raw ) {
          my ( undef, undef, undef, $called_as ) = caller(1);
          $called_as =~ s{^.*::}{};
          Carp::croak( "Invalid option(s) for $called_as: " . join( ", ", keys %$raw ) );
      }
      return $cooked;
  }

  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#

  #pod =construct path
  #pod
  #pod     $path = path("foo/bar");
  #pod     $path = path("/tmp", "file.txt"); # list
  #pod     $path = path(".");                # cwd
  #pod
  #pod Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  #pod directory path.  It's still up to you to call directory-like methods only on
  #pod directories and file-like methods only on files.  This function is exported
  #pod automatically by default.
  #pod
  #pod The first argument must be defined and have non-zero length or an exception
  #pod will be thrown.  This prevents subtle, dangerous errors with code like
  #pod C<< path( maybe_undef() )->remove_tree >>.
  #pod
  #pod B<DEPRECATED>: If and only if the B<first> character of the B<first> argument
  #pod to C<path> is a tilde ('~'), then tilde replacement will be applied to the
  #pod first path segment. A single tilde will be replaced with C<glob('~')> and a
  #pod tilde followed by a username will be replaced with output of
  #pod C<glob('~username')>. B<No other method does tilde expansion on its arguments>.
  #pod See L</Tilde expansion (deprecated)> for more.
  #pod
  #pod On Windows, if the path consists of a drive identifier without a path component
  #pod (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  #pod directory on that volume using C<Cwd::getdcwd()>.
  #pod
  #pod If called with a single C<Path::Tiny> argument, the original is returned unless
  #pod the original is holding a temporary file or directory reference in which case a
  #pod stringified copy is made.
  #pod
  #pod     $path = path("foo/bar");
  #pod     $temp = Path::Tiny->tempfile;
  #pod
  #pod     $p2 = path($path); # like $p2 = $path
  #pod     $t2 = path($temp); # like $t2 = path( "$temp" )
  #pod
  #pod This optimizes copies without proliferating references unexpectedly if a copy is
  #pod made by code outside your control.
  #pod
  #pod Current API available since 0.017.
  #pod
  #pod =cut

  sub path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;

      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }

      # stringify objects
      $path = "$path";

      # do any tilde expansions
      my ($tilde) = $path =~ m{^(~[^/]*)};
      if ( defined $tilde ) {
          # Escape File::Glob metacharacters
          (my $escaped = $tilde) =~ s/([\[\{\*\?\\])/\\$1/g;
          require File::Glob;
          my ($homedir) = File::Glob::bsd_glob($escaped);
          if (defined $homedir && ! $File::Glob::ERROR) {
              $homedir =~ tr[\\][/] if IS_WIN32();
              $path =~ s{^\Q$tilde\E}{$homedir};
          }
      }

      unshift @_, $path;
      goto &_pathify;
  }

  # _path is like path but without tilde expansion
  sub _path {
      my $path = shift;
      Carp::croak("Path::Tiny paths require defined, positive-length parts")
        unless 1 + @_ == grep { defined && length } $path, @_;

      # non-temp Path::Tiny objects are effectively immutable and can be reused
      if ( !@_ && ref($path) eq __PACKAGE__ && !$path->[TEMP] ) {
          return $path;
      }

      # stringify objects
      $path = "$path";

      unshift @_, $path;
      goto &_pathify;
  }

  # _pathify expects one or more string arguments, then joins and canonicalizes
  # them into an object.
  sub _pathify {
      my $path = shift;

      # expand relative volume paths on windows; put trailing slash on UNC root
      if ( IS_WIN32() ) {
          $path = _win32_vol( $path, $1 ) if $path =~ m{^($DRV_VOL)(?:$NOTSLASH|\z)};
          $path .= "/" if $path =~ m{^$UNC_VOL\z};
      }

      # concatenations stringifies objects, too
      if (@_) {
          $path .= ( _is_root($path) ? "" : "/" ) . join( "/", @_ );
      }


      # canonicalize, but with unix slashes and put back trailing volume slash
      my $cpath = $path = File::Spec->canonpath($path);
      $path =~ tr[\\][/] if IS_WIN32();
      $path = "/" if $path eq '/..'; # for old File::Spec
      $path .= "/" if IS_WIN32() && $path =~ m{^$UNC_VOL\z};

      # root paths must always have a trailing slash, but other paths must not
      if ( _is_root($path) ) {
          $path =~ s{/?\z}{/};
      }
      else {
          $path =~ s{/\z}{};
      }

      bless [ $path, $cpath ], __PACKAGE__;
  }

  #pod =construct new
  #pod
  #pod     $path = Path::Tiny->new("foo/bar");
  #pod
  #pod This is just like C<path>, but with method call overhead.  (Why would you
  #pod do that?)
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub new { shift; path(@_) }

  #pod =construct cwd
  #pod
  #pod     $path = Path::Tiny->cwd; # path( Cwd::getcwd )
  #pod     $path = cwd; # optional export
  #pod
  #pod Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  #pod This is slightly faster than C<< path(".")->absolute >>.
  #pod
  #pod C<cwd> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut

  sub cwd {
      require Cwd;
      return _path( Cwd::getcwd() );
  }

  #pod =construct rootdir
  #pod
  #pod     $path = Path::Tiny->rootdir; # /
  #pod     $path = rootdir;             # optional export
  #pod
  #pod Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  #pod picky for C<path("/")>.
  #pod
  #pod C<rootdir> may be exported on request and used as a function instead of as a
  #pod method.
  #pod
  #pod Current API available since 0.018.
  #pod
  #pod =cut

  sub rootdir { _path( File::Spec->rootdir ) }

  #pod =construct tempfile, tempdir
  #pod
  #pod     $temp = Path::Tiny->tempfile( @options );
  #pod     $temp = Path::Tiny->tempdir( @options );
  #pod     $temp = $dirpath->tempfile( @options );
  #pod     $temp = $dirpath->tempdir( @options );
  #pod     $temp = tempfile( @options ); # optional export
  #pod     $temp = tempdir( @options );  # optional export
  #pod
  #pod C<tempfile> passes the options to C<< File::Temp->new >> and returns a
  #pod C<Path::Tiny> object with the file name.  The C<TMPDIR> option will be enabled
  #pod by default, but you can override that by passing C<< TMPDIR => 0 >> along with
  #pod the options.  (If you use an absolute C<TEMPLATE> option, you will want to
  #pod disable C<TMPDIR>.)
  #pod
  #pod The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  #pod destroyed, the C<File::Temp> object will be as well.
  #pod
  #pod C<File::Temp> annoyingly requires you to specify a custom template in slightly
  #pod different ways depending on which function or method you call, but
  #pod C<Path::Tiny> lets you ignore that and can take either a leading template or a
  #pod C<TEMPLATE> option and does the right thing.
  #pod
  #pod     $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
  #pod     $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  #pod
  #pod The tempfile path object will be normalized to have an absolute path, even if
  #pod created in a relative directory using C<DIR>.  If you want it to have
  #pod the C<realpath> instead, pass a leading options hash like this:
  #pod
  #pod     $real_temp = tempfile({realpath => 1}, @options);
  #pod
  #pod C<tempdir> is just like C<tempfile>, except it calls
  #pod C<< File::Temp->newdir >> instead.
  #pod
  #pod Both C<tempfile> and C<tempdir> may be exported on request and used as
  #pod functions instead of as methods.
  #pod
  #pod The methods can be called on an instances representing a
  #pod directory. In this case, the directory is used as the base to create the
  #pod temporary file/directory, setting the C<DIR> option in File::Temp.
  #pod
  #pod     my $target_dir = path('/to/destination');
  #pod     my $tempfile = $target_dir->tempfile('foobarXXXXXX');
  #pod     $tempfile->spew('A lot of data...');  # not atomic
  #pod     $tempfile->move($target_dir->child('foobar')); # hopefully atomic
  #pod
  #pod In this case, any value set for option C<DIR> is ignored.
  #pod
  #pod B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  #pod reused.  This is not as secure as using File::Temp handles directly, but is
  #pod less prone to deadlocks or access problems on some platforms.  Think of what
  #pod C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  #pod up.
  #pod
  #pod B<Note 2>: if you don't want these cleaned up automatically when the object
  #pod is destroyed, File::Temp requires different options for directories and
  #pod files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  #pod files.
  #pod
  #pod B<Note 3>: Don't lose the temporary object by chaining a method call instead
  #pod of storing it:
  #pod
  #pod     my $lost = tempdir()->child("foo"); # tempdir cleaned up right away
  #pod
  #pod B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  #pod Keeping a reference to, or modifying the cached object may break the
  #pod behavior documented above and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.119.
  #pod
  #pod =cut

  sub tempfile {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempfile => @_);

      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;

      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = $opts->{realpath} ? _path($temp)->realpath : _path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      return $self;
  }

  sub tempdir {
      my ( $opts, $maybe_template, $args )
          = _parse_file_temp_args(tempdir => @_);

      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = $opts->{realpath} ? _path($temp)->realpath : _path($temp)->absolute;
      $self->[TEMP] = $temp;                # keep object alive while we are
      # Some ActiveState Perls for Windows break Cwd in ways that lead
      # File::Temp to get confused about what path to remove; this
      # monkey-patches the object with our own view of the absolute path
      $temp->{REALNAME} = $self->[CANON] if IS_WIN32;
      return $self;
  }

  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $called_as = shift;
      if ( @_ && $_[0] eq 'Path::Tiny' ) { shift } # class method
      elsif ( @_ && eval{$_[0]->isa('Path::Tiny')} ) {
          my $dir = shift;
          if (! $dir->is_dir) {
              $dir->_throw( $called_as, $dir, "is not a directory object" );
          }
          push @_, DIR => $dir->stringify; # no overriding
      }
      my $opts = ( @_ && ref $_[0] eq 'HASH' ) ? shift @_ : {};
      $opts = _get_args( $opts, qw/realpath/ );

      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );

      return ( $opts, \@template, \%args );
  }

  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#

  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }

  sub _resolve_symlinks {
      my ($self) = @_;
      my $new = $self;
      my ( $count, %seen ) = 0;
      while ( -l $new->[PATH] ) {
          if ( $seen{ $new->[PATH] }++ ) {
              $self->_throw( 'readlink', $self->[PATH], "symlink loop detected" );
          }
          if ( ++$count > 100 ) {
              $self->_throw( 'readlink', $self->[PATH], "maximum symlink depth exceeded" );
          }
          my $resolved = readlink $new->[PATH];
          $new->_throw( 'readlink', $new->[PATH] ) unless defined $resolved;
          $resolved = _path($resolved);
          $new = $resolved->is_absolute ? $resolved : $new->sibling($resolved);
      }
      return $new;
  }

  sub _replacment_path {
      my ($self) = @_;

      my $unique_suffix = $$ . int( rand( 2**31 ) );
      my $temp          = _path( $self . $unique_suffix );

      # If filename with process+random suffix is too long, use a shorter
      # version that doesn't preserve the basename.
      if ( length $temp->basename > 255 ) {
          $temp = $self->sibling( "temp" . $unique_suffix );
      }

      return $temp;
  }

  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#

  #pod =method absolute
  #pod
  #pod     $abs = path("foo/bar")->absolute;
  #pod     $abs = path("foo/bar")->absolute("/tmp");
  #pod
  #pod Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  #pod absolute).  If no argument is given, the current directory is used as the
  #pod absolute base path.  If an argument is given, it will be converted to an
  #pod absolute path (if it is not already) and used as the absolute base path.
  #pod
  #pod This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  #pod in L<File::Spec> would normally do so on your platform.  If you need them
  #pod resolved, you must call the more expensive C<realpath> method instead.
  #pod
  #pod On Windows, an absolute path without a volume component will have it added
  #pod based on the current drive.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut

  sub absolute {
      my ( $self, $base ) = @_;

      # absolute paths handled differently by OS
      if (IS_WIN32) {
          return $self if length $self->volume;
          # add missing volume
          if ( $self->is_absolute ) {
              require Cwd;
              # use Win32::GetCwd not Cwd::getdcwd because we're sure
              # to have the former but not necessarily the latter
              my ($drv) = Win32::GetCwd() =~ /^($DRV_VOL | $UNC_VOL)/x;
              return _path( $drv . $self->[PATH] );
          }
      }
      else {
          return $self if $self->is_absolute;
      }

      # no base means use current directory as base
      require Cwd;
      return _path( Cwd::getcwd(), $_[0]->[PATH] ) unless defined $base;

      # relative base should be made absolute; we check is_absolute rather
      # than unconditionally make base absolute so that "/foo" doesn't become
      # "C:/foo" on Windows.
      $base = _path($base);
      return _path( ( $base->is_absolute ? $base : $base->absolute ), $_[0]->[PATH] );
  }

  #pod =method append, append_raw, append_utf8
  #pod
  #pod     path("foo.txt")->append(@data);
  #pod     path("foo.txt")->append(\@data);
  #pod     path("foo.txt")->append({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->append_raw(@data);
  #pod     path("foo.txt")->append_utf8(@data);
  #pod
  #pod Appends data to a file.  The file is locked with C<flock> prior to writing
  #pod and closed afterwards.  An optional hash reference may be used to pass
  #pod options.  Valid options are:
  #pod
  #pod =for :list
  #pod * C<binmode>: passed to C<binmode()> on the handle used for writing.
  #pod * C<truncate>: truncates the file after locking and before appending
  #pod
  #pod The C<truncate> option is a way to replace the contents of a file
  #pod B<in place>, unlike L</spew> which writes to a temporary file and then
  #pod replaces the original (if it exists).
  #pod
  #pod C<append_raw> is like C<append> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<append_utf8> is like C<append> with an unbuffered C<binmode>
  #pod C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
  #pod L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, an
  #pod unbuffered, raw append will be done instead on the data encoded with
  #pod C<Unicode::UTF8>.
  #pod
  #pod Current API available since 0.060.
  #pod
  #pod =cut

  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $mode = $args->{truncate} ? ">" : ">>";
      my $fh = $self->filehandle( { locked => 1 }, $mode, $binmode );
      print( {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data ) or self->_throw('print');
      close $fh or $self->_throw('close');
  }

  sub append_raw {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      $args->{binmode} = ':unix';
      append( $self, $args, @data );
  }

  sub append_utf8 {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode truncate/ );
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          $args->{binmode} = ":unix";
          append( $self, $args, map { Unicode::UTF8::encode_utf8($_) } @data );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":unix:utf8_strict";
          append( $self, $args, @data );
      }
      else {
          $args->{binmode} = ":unix:encoding(UTF-8)";
          append( $self, $args, @data );
      }
  }

  #pod =method assert
  #pod
  #pod     $path = path("foo.txt")->assert( sub { $_->exists } );
  #pod
  #pod Returns the invocant after asserting that a code reference argument returns
  #pod true.  When the assertion code reference runs, it will have the invocant
  #pod object in the C<$_> variable.  If it returns false, an exception will be
  #pod thrown.  The assertion code reference may also throw its own exception.
  #pod
  #pod If no assertion is provided, the invocant is returned without error.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut

  sub assert {
      my ( $self, $assertion ) = @_;
      return $self unless $assertion;
      if ( ref $assertion eq 'CODE' ) {
          local $_ = $self;
          $assertion->()
            or Path::Tiny::Error->throw( "assert", $self->[PATH], "failed assertion" );
      }
      else {
          Carp::croak("argument to assert must be a code reference argument");
      }
      return $self;
  }

  #pod =method basename
  #pod
  #pod     $name = path("foo/bar.txt")->basename;        # bar.txt
  #pod     $name = path("foo.txt")->basename('.txt');    # foo
  #pod     $name = path("foo.txt")->basename(qr/.txt/);  # foo
  #pod     $name = path("foo.txt")->basename(@suffixes);
  #pod
  #pod Returns the file portion or last directory portion of a path.
  #pod
  #pod Given a list of suffixes as strings or regular expressions, any that match at
  #pod the end of the file portion or last directory portion will be removed before
  #pod the result is returned.
  #pod
  #pod Current API available since 0.054.
  #pod
  #pod =cut

  sub basename {
      my ( $self, @suffixes ) = @_;
      $self->_splitpath unless defined $self->[FILE];
      my $file = $self->[FILE];
      for my $s (@suffixes) {
          my $re = ref($s) eq 'Regexp' ? qr/$s\z/ : qr/\Q$s\E\z/;
          last if $file =~ s/$re//;
      }
      return $file;
  }

  #pod =method canonpath
  #pod
  #pod     $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  #pod
  #pod Returns a string with the canonical format of the path name for
  #pod the platform.  In particular, this means directory separators
  #pod will be C<\> on Windows.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub canonpath { $_[0]->[CANON] }

  #pod =method cached_temp
  #pod
  #pod Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  #pod C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  #pod If there is no such object, this method throws.
  #pod
  #pod B<WARNING>: Keeping a reference to, or modifying the cached object may
  #pod break the behavior documented for temporary files and directories created
  #pod with C<Path::Tiny> and is not supported.  Use at your own risk.
  #pod
  #pod Current API available since 0.101.
  #pod
  #pod =cut

  sub cached_temp {
      my $self = shift;
      $self->_throw( "cached_temp", $self, "has no cached File::Temp object" )
        unless defined $self->[TEMP];
      return $self->[TEMP];
  }

  #pod =method child
  #pod
  #pod     $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
  #pod     $file = path("/tmp")->child(@parts);
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the original.  Works
  #pod like C<catfile> or C<catdir> from File::Spec, but without caring about
  #pod file or directories.
  #pod
  #pod B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  #pod there is no guarantee that the new path refers to an actual descendent of
  #pod the original.  If this is important to you, transform parent and child with
  #pod L</realpath> and check them with L</subsumes>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub child {
      my ( $self, @parts ) = @_;
      return _path( $self->[PATH], @parts );
  }

  #pod =method children
  #pod
  #pod     @paths = path("/tmp")->children;
  #pod     @paths = path("/tmp")->children( qr/\.txt\z/ );
  #pod
  #pod Returns a list of C<Path::Tiny> objects for all files and directories
  #pod within a directory.  Excludes "." and ".." automatically.
  #pod
  #pod If an optional C<qr//> argument is provided, it only returns objects for child
  #pod names that match the given regular expression.  Only the base name is used
  #pod for matching:
  #pod
  #pod     @paths = path("/tmp")->children( qr/^foo/ );
  #pod     # matches children like the glob foo*
  #pod
  #pod Current API available since 0.028.
  #pod
  #pod =cut

  sub children {
      my ( $self, $filter ) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or $self->_throw('opendir');
      my @children = readdir $dh;
      closedir $dh or $self->_throw('closedir');

      if ( not defined $filter ) {
          @children = grep { $_ ne '.' && $_ ne '..' } @children;
      }
      elsif ( $filter && ref($filter) eq 'Regexp' ) {
          @children = grep { $_ ne '.' && $_ ne '..' && $_ =~ $filter } @children;
      }
      else {
          Carp::croak("Invalid argument '$filter' for children()");
      }

      return map { _path( $self->[PATH], $_ ) } @children;
  }

  #pod =method chmod
  #pod
  #pod     path("foo.txt")->chmod(0777);
  #pod     path("foo.txt")->chmod("0755");
  #pod     path("foo.txt")->chmod("go-w");
  #pod     path("foo.txt")->chmod("a=r,u+wx");
  #pod
  #pod Sets file or directory permissions.  The argument can be a numeric mode, a
  #pod octal string beginning with a "0" or a limited subset of the symbolic mode use
  #pod by F</bin/chmod>.
  #pod
  #pod The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  #pod match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  #pod "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  #pod are required for each clause, multiple ops are not allowed and permissions
  #pod C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut

  sub chmod {
      my ( $self, $new_mode ) = @_;

      my $mode;
      if ( $new_mode =~ /\d/ ) {
          $mode = ( $new_mode =~ /^0/ ? oct($new_mode) : $new_mode );
      }
      elsif ( $new_mode =~ /[=+-]/ ) {
          $mode = _symbolic_chmod( $self->stat->mode & 07777, $new_mode ); ## no critic
      }
      else {
          Carp::croak("Invalid mode argument '$new_mode' for chmod()");
      }

      CORE::chmod( $mode, $self->[PATH] ) or $self->_throw("chmod");

      return 1;
  }

  #pod =method copy
  #pod
  #pod     path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  #pod
  #pod Copies the current path to the given destination using L<File::Copy>'s
  #pod C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly copied file.
  #pod
  #pod Current API available since 0.070.
  #pod
  #pod =cut

  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");

      return -d $dest ? _path( $dest, $self->basename ) : _path($dest);
  }

  #pod =method digest
  #pod
  #pod     $obj = path("/tmp/foo.txt")->digest;        # SHA-256
  #pod     $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
  #pod     $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );
  #pod
  #pod Returns a hexadecimal digest for a file.  An optional hash reference of options may
  #pod be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  #pod bytes will be read at a time.  If not provided, the entire file will be slurped
  #pod into memory to compute the digest.
  #pod
  #pod Any subsequent arguments are passed to the constructor for L<Digest> to select
  #pod an algorithm.  If no arguments are given, the default is SHA-256.
  #pod
  #pod Current API available since 0.056.
  #pod
  #pod =cut

  sub digest {
      my ( $self, @opts ) = @_;
      my $args = ( @opts && ref $opts[0] eq 'HASH' ) ? shift @opts : {};
      $args = _get_args( $args, qw/chunk_size/ );
      unshift @opts, 'SHA-256' unless @opts;
      require Digest;
      my $digest = Digest->new(@opts);
      if ( $args->{chunk_size} ) {
          my $fh = $self->filehandle( { locked => 1 }, "<", ":unix" );
          my $buf;
          while (!eof($fh)) {
              my $rc = read $fh, $buf, $args->{chunk_size};
              $self->_throw('read') unless defined $rc;
              $digest->add($buf);
          }
      }
      else {
          $digest->add( $self->slurp_raw );
      }
      return $digest->hexdigest;
  }

  #pod =method dirname (deprecated)
  #pod
  #pod     $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  #pod
  #pod Returns the directory portion you would get from calling
  #pod C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  #pod parent directory portion.  Because L<File::Spec> is inconsistent, the result
  #pod might or might not have a trailing slash.  Because of this, this method is
  #pod B<deprecated>.
  #pod
  #pod A better, more consistently approach is likely C<< $path->parent->stringify >>,
  #pod which will not have a trailing slash except for a root directory.
  #pod
  #pod Deprecated in 0.056.
  #pod
  #pod =cut

  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }

  #pod =method edit, edit_raw, edit_utf8
  #pod
  #pod     path("foo.txt")->edit( \&callback, $options );
  #pod     path("foo.txt")->edit_utf8( \&callback );
  #pod     path("foo.txt")->edit_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file using a single
  #pod callback argument. They slurp the file using C<slurp>, place the contents
  #pod inside a localized C<$_> variable, call the callback function (without
  #pod arguments), and then write C<$_> (presumably mutated) back to the
  #pod file with C<spew>.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to C<slurp> and C<spew>.
  #pod
  #pod C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  #pod C<spew_*> methods.
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut

  sub edit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';

      local $_ =
        $self->slurp( exists( $args->{binmode} ) ? { binmode => $args->{binmode} } : () );
      $cb->();
      $self->spew( $args, $_ );

      return;
  }

  # this is done long-hand to benefit from slurp_utf8 optimizations
  sub edit_utf8 {
      my ( $self, $cb ) = @_;
      Carp::croak("Callback for edit_utf8() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';

      local $_ = $self->slurp_utf8;
      $cb->();
      $self->spew_utf8($_);

      return;
  }

  sub edit_raw { $_[2] = { binmode => ":unix" }; goto &edit }

  #pod =method edit_lines, edit_lines_utf8, edit_lines_raw
  #pod
  #pod     path("foo.txt")->edit_lines( \&callback, $options );
  #pod     path("foo.txt")->edit_lines_utf8( \&callback );
  #pod     path("foo.txt")->edit_lines_raw( \&callback );
  #pod
  #pod These are convenience methods that allow "editing" a file's lines using a
  #pod single callback argument.  They iterate over the file: for each line, the
  #pod line is put into a localized C<$_> variable, the callback function is
  #pod executed (without arguments) and then C<$_> is written to a temporary file.
  #pod When iteration is finished, the temporary file is atomically renamed over
  #pod the original.
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<binmode>, which is passed to the method that open handles for reading and
  #pod writing.
  #pod
  #pod C<edit_lines_raw> is like C<edit_lines> with a buffered C<binmode> of
  #pod C<:raw>.
  #pod
  #pod C<edit_lines_utf8> is like C<edit_lines> with a buffered C<binmode>
  #pod C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
  #pod L<PerlIO::utf8_strict>).
  #pod
  #pod Current API available since 0.077.
  #pod
  #pod =cut

  sub edit_lines {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/binmode/ );
      Carp::croak("Callback for edit_lines() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';

      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;

      # writing needs to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = $resolved_path->_replacment_path;

      my $temp_fh = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      my $in_fh = $self->filehandle( { locked => 1 }, '<', $binmode );

      local $_;
      while (! eof($in_fh) ) {
          defined( $_ = readline($in_fh) ) or $self->_throw('readline');
          $cb->();
          $temp_fh->print($_) or self->_throw('print', $temp);
      }

      close $temp_fh or $self->_throw( 'close', $temp );
      close $in_fh or $self->_throw('close');

      return $temp->move($resolved_path);
  }

  sub edit_lines_raw { $_[2] = { binmode => ":raw" }; goto &edit_lines }

  sub edit_lines_utf8 {
      if ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[2] = { binmode => ":raw:utf8_strict" };
      }
      else {
          $_[2] = { binmode => ":raw:encoding(UTF-8)" };
      }
      goto &edit_lines;
  }

  #pod =method exists, is_file, is_dir
  #pod
  #pod     if ( path("/tmp")->exists ) { ... }     # -e
  #pod     if ( path("/tmp")->is_dir ) { ... }     # -d
  #pod     if ( path("/tmp")->is_file ) { ... }    # -e && ! -d
  #pod
  #pod Implements file test operations, this means the file or directory actually has
  #pod to exist on the filesystem.  Until then, it's just a path.
  #pod
  #pod B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  #pod C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  #pod read just like files.
  #pod
  #pod Use C<-f> instead if you really mean to check for a plain file.
  #pod
  #pod Current API available since 0.053.
  #pod
  #pod =cut

  sub exists { -e $_[0]->[PATH] }

  sub is_file { -e $_[0]->[PATH] && !-d _ }

  sub is_dir { -d $_[0]->[PATH] }

  #pod =method filehandle
  #pod
  #pod     $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
  #pod     $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);
  #pod
  #pod Returns an open file handle.  The C<$mode> argument must be a Perl-style
  #pod read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  #pod is given, it is set during the C<open> call.
  #pod
  #pod An optional hash reference may be used to pass options.
  #pod
  #pod The C<locked> option governs file locking; if true, handles opened for writing,
  #pod appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  #pod locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  #pod truncation until after the lock is acquired.
  #pod
  #pod The C<exclusive> option causes the open() call to fail if the file already
  #pod exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  #pod C<exclusive> implies C<locked> and will set it for you if you forget it.
  #pod
  #pod See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  #pod
  #pod Current API available since 0.066.
  #pod
  #pod =cut

  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added

  sub filehandle {
      my ( $self, @args ) = @_;
      my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
      $args = _get_args( $args, qw/locked exclusive/ );
      $args->{locked} = 1 if $args->{exclusive};
      my ( $opentype, $binmode ) = @args;

      $opentype = "<" unless defined $opentype;
      Carp::croak("Invalid file mode '$opentype'")
        unless grep { $opentype eq $_ } qw/< +< > +> >> +>>/;

      $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $opentype, -1, 1 ) }
        unless defined $binmode;
      $binmode = "" unless defined $binmode;

      my ( $fh, $lock, $trunc );
      if ( $HAS_FLOCK && $args->{locked} && !$ENV{PERL_PATH_TINY_NO_FLOCK} ) {
          require Fcntl;
          # truncating file modes shouldn't truncate until lock acquired
          if ( grep { $opentype eq $_ } qw( > +> ) ) {
              # sysopen in write mode without truncation
              my $flags = $opentype eq ">" ? Fcntl::O_WRONLY() : Fcntl::O_RDWR();
              $flags |= Fcntl::O_CREAT();
              $flags |= Fcntl::O_EXCL() if $args->{exclusive};
              sysopen( $fh, $self->[PATH], $flags ) or $self->_throw("sysopen");

              # fix up the binmode since sysopen() can't specify layers like
              # open() and binmode() can't start with just :unix like open()
              if ( $binmode =~ s/^:unix// ) {
                  # eliminate pseudo-layers
                  binmode( $fh, ":raw" ) or $self->_throw("binmode (:raw)");
                  # strip off real layers until only :unix is left
                  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
                      binmode( $fh, ":pop" ) or $self->_throw("binmode (:pop)");
                  }
              }

              # apply any remaining binmode layers
              if ( length $binmode ) {
                  binmode( $fh, $binmode ) or $self->_throw("binmode ($binmode)");
              }

              # ask for lock and truncation
              $lock  = Fcntl::LOCK_EX();
              $trunc = 1;
          }
          elsif ( $^O eq 'aix' && $opentype eq "<" ) {
              # AIX can only lock write handles, so upgrade to RW and LOCK_EX if
              # the file is writable; otherwise give up on locking.  N.B.
              # checking -w before open to determine the open mode is an
              # unavoidable race condition
              if ( -w $self->[PATH] ) {
                  $opentype = "+<";
                  $lock     = Fcntl::LOCK_EX();
              }
          }
          else {
              $lock = $opentype eq "<" ? Fcntl::LOCK_SH() : Fcntl::LOCK_EX();
          }
      }

      unless ($fh) {
          my $mode = $opentype . $binmode;
          open $fh, $mode, $self->[PATH] or $self->_throw("open ($mode)");
      }

      do { flock( $fh, $lock ) or $self->_throw("flock ($lock)") } if $lock;
      do { truncate( $fh, 0 ) or $self->_throw("truncate") } if $trunc;

      return $fh;
  }

  #pod =method has_same_bytes
  #pod
  #pod     if ( path("foo.txt")->has_same_bytes("bar.txt") ) {
  #pod        # ...
  #pod     }
  #pod
  #pod This method returns true if both the invocant and the argument can be opened as
  #pod file handles and the handles contain the same bytes.  It returns false if their
  #pod contents differ.  If either can't be opened as a file (e.g. a directory or
  #pod non-existent file), the method throws an exception.  If both can be opened and
  #pod both have the same C<realpath>, the method returns true without scanning any
  #pod data.
  #pod
  #pod Current API available since 0.125.
  #pod
  #pod =cut

  sub has_same_bytes {
      my ($self, $other_path) = @_;
      my $other = _path($other_path);

      my $fh1 = $self->openr_raw({ locked => 1 });
      my $fh2 = $other->openr_raw({ locked => 1 });

      # check for directories
      if (-d $fh1) {
          $self->_throw('has_same_bytes', $self->[PATH], "directory not allowed");
      }
      if (-d $fh2) {
          $self->_throw('has_same_bytes', $other->[PATH], "directory not allowed");
      }

      # Now that handles are open, we know the inputs are readable files that
      # exist, so it's safe to compare via realpath
      if ($self->realpath eq $other->realpath) {
          return 1
      }

      # result is 0 for equal, 1 for unequal, -1 for error
      require File::Compare;
      my $res = File::Compare::compare($fh1, $fh2, 65536);
      if ($res < 0) {
          $self->_throw('has_same_bytes')
      }

      return $res == 0;
  }

  #pod =method is_absolute, is_relative
  #pod
  #pod     if ( path("/tmp")->is_absolute ) { ... }
  #pod     if ( path("/tmp")->is_relative ) { ... }
  #pod
  #pod Booleans for whether the path appears absolute or relative.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }

  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }

  #pod =method is_rootdir
  #pod
  #pod     while ( ! $path->is_rootdir ) {
  #pod         $path = $path->parent;
  #pod         ...
  #pod     }
  #pod
  #pod Boolean for whether the path is the root directory of the volume.  I.e. the
  #pod C<dirname> is C<q[/]> and the C<basename> is C<q[]>.
  #pod
  #pod This works even on C<MSWin32> with drives and UNC volumes:
  #pod
  #pod     path("C:/")->is_rootdir;             # true
  #pod     path("//server/share/")->is_rootdir; #true
  #pod
  #pod Current API available since 0.038.
  #pod
  #pod =cut

  sub is_rootdir {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return $self->[DIR] eq '/' && $self->[FILE] eq '';
  }

  #pod =method iterator
  #pod
  #pod     $iter = path("/tmp")->iterator( \%options );
  #pod
  #pod Returns a code reference that walks a directory lazily.  Each invocation
  #pod returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  #pod
  #pod     $iter = path("/tmp")->iterator;
  #pod     while ( $path = $iter->() ) {
  #pod         ...
  #pod     }
  #pod
  #pod The current and parent directory entries ("." and "..") will not
  #pod be included.
  #pod
  #pod If the C<recurse> option is true, the iterator will walk the directory
  #pod recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  #pod directory links will be followed recursively.  There is no protection against
  #pod loops when following links. If a directory is not readable, it will not be
  #pod followed.
  #pod
  #pod The default is the same as:
  #pod
  #pod     $iter = path("/tmp")->iterator( {
  #pod         recurse         => 0,
  #pod         follow_symlinks => 0,
  #pod     } );
  #pod
  #pod For a more powerful, recursive iterator with built-in loop avoidance, see
  #pod L<Path::Iterator::Rule>.
  #pod
  #pod See also L</visit>.
  #pod
  #pod Current API available since 0.016.
  #pod
  #pod =cut

  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  if ( !-r $dirs[0] ) {
                      # Directory is missing or not readable, so skip it.  There
                      # is still a race condition possible between the check and
                      # the opendir, but we can't easily differentiate between
                      # error cases that are OK to skip and those that we want
                      # to be exceptions, so we live with the race and let opendir
                      # be fatal.
                      shift @dirs and next;
                  }
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or $self->_throw( 'opendir', $current->[PATH] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }

  #pod =method lines, lines_raw, lines_utf8
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines;
  #pod     @contents = path("/tmp/foo.txt")->lines(\%options);
  #pod     @contents = path("/tmp/foo.txt")->lines_raw;
  #pod     @contents = path("/tmp/foo.txt")->lines_utf8;
  #pod
  #pod     @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );
  #pod
  #pod Returns a list of lines from a file.  Optionally takes a hash-reference of
  #pod options.  Valid options are C<binmode>, C<count> and C<chomp>.
  #pod
  #pod If C<binmode> is provided, it will be set on the handle prior to reading.
  #pod
  #pod If a positive C<count> is provided, that many lines will be returned from the
  #pod start of the file.  If a negative C<count> is provided, the entire file will be
  #pod read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  #pod exceeds the number of lines in the file, all lines will be returned.
  #pod
  #pod If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  #pod C<LF>) will be removed from the lines returned.
  #pod
  #pod Because the return is a list, C<lines> in scalar context will return the number
  #pod of lines (and throw away the data).
  #pod
  #pod     $number_of_lines = path("/tmp/foo.txt")->lines;
  #pod
  #pod C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  #pod instead of C<:unix> so PerlIO buffering can manage reading by line.
  #pod
  #pod C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  #pod (or C<:raw:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw, unbuffered UTF-8 slurp will be done and then the
  #pod lines will be split.  This is actually faster than relying on
  #pod IO layers, though a bit memory intensive.  If memory use is a
  #pod concern, consider C<openr_utf8> and iterating directly on the handle.
  #pod
  #pod Current API available since 0.065.
  #pod
  #pod =cut

  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my ( $counter, $mod, @result ) = ( 0, abs( $args->{count} ) );
          my $line;
          while ( !eof($fh) ) {
              defined( $line = readline($fh) ) or $self->_throw('readline');

              $line =~ s/(?:\x{0d}?\x{0a}|\x{0d})\z// if $chomp;
              $result[ $counter++ ] = $line;
              # for positive count, terminate after right number of lines
              last if $counter == $args->{count};
              # for negative count, eventually wrap around in the result array
              $counter %= $mod;
          }
          # reorder results if full and wrapped somewhere in the middle
          splice( @result, 0, 0, splice( @result, $counter ) )
            if @result == $mod && $counter % $mod;
          return @result;
      }
      elsif ($chomp) {
          local $!;
          my @lines = map { s/(?:\x{0d}?\x{0a}|\x{0d})\z//; $_ } <$fh>; ## no critic
          $self->_throw('readline') if $!;
          return @lines;
      }
      else {
          if ( wantarray ) {
              local $!;
              my @lines = <$fh>;
              $self->_throw('readline') if $!;
              return @lines;
          } else {
              local $!;
              my $count =()= <$fh>;
              $self->_throw('readline') if $!;
              return $count;
          }
      }
  }

  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self);                    ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }

  my $CRLF = qr/(?:\x{0d}?\x{0a}|\x{0d})/;

  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) )
          && $args->{chomp}
          && !$args->{count} )
      {
          my $slurp = slurp_utf8($self);
          $slurp =~ s/$CRLF\z//; # like chomp, but full CR?LF|CR
          return split $CRLF, $slurp, -1; ## no critic
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $args->{binmode} = ":raw:utf8_strict";
          return lines( $self, $args );
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }

  #pod =method mkdir
  #pod
  #pod     path("foo/bar/baz")->mkdir;
  #pod     path("foo/bar/baz")->mkdir( \%options );
  #pod
  #pod Like calling C<make_path> from L<File::Path>.  An optional hash reference
  #pod is passed through to C<make_path>.  Errors will be trapped and an exception
  #pod thrown.  Returns the the path object to facilitate chaining.
  #pod
  #pod B<NOTE>: unlike Perl's builtin C<mkdir>, this will create intermediate paths
  #pod similar to the Unix C<mkdir -p> command.  It will not error if applied to an
  #pod existing directory.
  #pod
  #pod Current API available since 0.125.
  #pod
  #pod =cut

  sub mkdir {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs;
      my $ok = eval {
          File::Path::make_path( $self->[PATH], $args );
          1;
      };
      if (!$ok) {
          $self->_throw('mkdir', $self->[PATH], "error creating path: $@");
      }
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          $self->_throw('mkdir', $file, $message);
      }
      return $self;
  }

  #pod =method mkpath (deprecated)
  #pod
  #pod Like calling C<mkdir>, but returns the list of directories created or an empty list if
  #pod the directories already exist, just like C<make_path>.
  #pod
  #pod Deprecated in 0.125.
  #pod
  #pod =cut

  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }

  #pod =method move
  #pod
  #pod     path("foo.txt")->move("bar.txt");
  #pod
  #pod Moves the current path to the given destination using L<File::Copy>'s
  #pod C<move> function. Upon success, returns the C<Path::Tiny> object for the
  #pod newly moved file.
  #pod
  #pod If the destination already exists and is a directory, and the source is not a
  #pod directory, then the source file will be renamed into the directory
  #pod specified by the destination.
  #pod
  #pod If possible, move() will simply rename the file. Otherwise, it
  #pod copies the file to the new location and deletes the original. If an
  #pod error occurs during this copy-and-delete process, you may be left
  #pod with a (possibly partial) copy of the file under the destination
  #pod name.
  #pod
  #pod Current API available since 0.124. Prior versions used Perl's
  #pod -built-in (and less robust) L<rename|perlfunc/rename> function
  #pod and did not return an object.
  #pod
  #pod =cut

  sub move {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::move( $self->[PATH], $dest )
        or $self->_throw( 'move', $self->[PATH] . "' -> '$dest" );

      return -d $dest ? _path( $dest, $self->basename ) : _path($dest);
  }

  #pod =method openr, openw, openrw, opena
  #pod
  #pod     $fh = path("foo.txt")->openr($binmode);  # read
  #pod     $fh = path("foo.txt")->openr_raw;
  #pod     $fh = path("foo.txt")->openr_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openw($binmode);  # write
  #pod     $fh = path("foo.txt")->openw_raw;
  #pod     $fh = path("foo.txt")->openw_utf8;
  #pod
  #pod     $fh = path("foo.txt")->opena($binmode);  # append
  #pod     $fh = path("foo.txt")->opena_raw;
  #pod     $fh = path("foo.txt")->opena_utf8;
  #pod
  #pod     $fh = path("foo.txt")->openrw($binmode); # read/write
  #pod     $fh = path("foo.txt")->openrw_raw;
  #pod     $fh = path("foo.txt")->openrw_utf8;
  #pod
  #pod Returns a file handle opened in the specified mode.  The C<openr> style methods
  #pod take a single C<binmode> argument.  All of the C<open*> methods have
  #pod C<open*_raw> and C<open*_utf8> equivalents that use buffered I/O layers C<:raw>
  #pod and C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
  #pod L<PerlIO::utf8_strict>).
  #pod
  #pod An optional hash reference may be used to pass options.  The only option is
  #pod C<locked>.  If true, handles opened for writing, appending or read-write are
  #pod locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.
  #pod
  #pod     $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );
  #pod
  #pod See L</filehandle> for more on locking.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut

  # map method names to corresponding open mode
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );

  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my ($binmode) = @args;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $args, $v, $binmode );
      };
      *{ $k . "_raw" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          $self->filehandle( $args, $v, ":raw" );
      };
      *{ $k . "_utf8" } = sub {
          my ( $self, @args ) = @_;
          my $args = ( @args && ref $args[0] eq 'HASH' ) ? shift @args : {};
          $args = _get_args( $args, qw/locked/ );
          my $layer;
          if ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
              $layer = ":raw:utf8_strict";
          }
          else {
              $layer = ":raw:encoding(UTF-8)";
          }
          $self->filehandle( $args, $v, $layer );
      };
  }

  #pod =method parent
  #pod
  #pod     $parent = path("foo/bar/baz")->parent; # foo/bar
  #pod     $parent = path("foo/wibble.txt")->parent; # foo
  #pod
  #pod     $parent = path("foo/bar/baz")->parent(2); # foo
  #pod
  #pod Returns a C<Path::Tiny> object corresponding to the parent directory of the
  #pod original directory or file. An optional positive integer argument is the number
  #pod of parent directories upwards to return.  C<parent> by itself is equivalent to
  #pod C<parent(1)>.
  #pod
  #pod Current API available since 0.014.
  #pod
  #pod =cut

  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] eq ".." ) {
              $parent = _path( $self->[PATH] . "/.." );
          }
          else {
              $parent = _path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          # because of symlinks, any internal updir requires us to
          # just add more updirs at the end
          if ( $self->[DIR] =~ m{(?:^\.\./|/\.\./|/\.\.\z)} ) {
              $parent = _path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/\z}{/};
              $parent = _path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = _path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }

  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }

  #pod =method realpath
  #pod
  #pod     $real = path("/baz/foo/../bar")->realpath;
  #pod     $real = path("foo/../bar")->realpath;
  #pod
  #pod Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  #pod parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  #pod more expensive as it must actually consult the filesystem.
  #pod
  #pod If the parent path can't be resolved (e.g. if it includes directories that
  #pod don't exist), an exception will be thrown:
  #pod
  #pod     $real = path("doesnt_exist/foo")->realpath; # dies
  #pod
  #pod However, if the parent path exists and only the last component (e.g. filename)
  #pod doesn't exist, the realpath will be the realpath of the parent plus the
  #pod non-existent last component:
  #pod
  #pod     $real = path("./aasdlfasdlf")->realpath; # works
  #pod
  #pod The underlying L<Cwd> module usually worked this way on Unix, but died on
  #pod Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  #pod it's safe to use anywhere.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  # Win32 and some Unixes need parent path resolved separately so realpath
  # doesn't throw an error resolving non-existent basename
  sub realpath {
      my $self = shift;
      $self = $self->_resolve_symlinks;
      require Cwd;
      $self->_splitpath if !defined $self->[FILE];
      my $check_parent =
        length $self->[FILE] && $self->[FILE] ne '.' && $self->[FILE] ne '..';
      my $realpath = eval {
          # pure-perl Cwd can carp
          local $SIG{__WARN__} = sub { };
          Cwd::realpath( $check_parent ? $self->parent->[PATH] : $self->[PATH] );
      };
      # parent realpath must exist; not all Cwd::realpath will error if it doesn't
      $self->_throw("resolving realpath")
        unless defined $realpath && length $realpath && -e $realpath;
      return ( $check_parent ? _path( $realpath, $self->[FILE] ) : _path($realpath) );
  }

  #pod =method relative
  #pod
  #pod     $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  #pod
  #pod Returns a C<Path::Tiny> object with a path relative to a new base path
  #pod given as an argument.  If no argument is given, the current directory will
  #pod be used as the new base path.
  #pod
  #pod If either path is already relative, it will be made absolute based on the
  #pod current directly before determining the new relative path.
  #pod
  #pod The algorithm is roughly as follows:
  #pod
  #pod =for :list
  #pod * If the original and new base path are on different volumes, an exception
  #pod   will be thrown.
  #pod * If the original and new base are identical, the relative path is C<".">.
  #pod * If the new base subsumes the original, the relative path is the original
  #pod   path with the new base chopped off the front
  #pod * If the new base does not subsume the original, a common prefix path is
  #pod   determined (possibly the root directory) and the relative path will
  #pod   consist of updirs (C<"..">) to reach the common prefix, followed by the
  #pod   original path less the common prefix.
  #pod
  #pod Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  #pod on a common prefix takes into account symlinks that could affect the updir
  #pod process.  Given an original path "/A/B" and a new base "/A/C",
  #pod (where "A", "B" and "C" could each have multiple path components):
  #pod
  #pod =for :list
  #pod * Symlinks in "A" don't change the result unless the last component of A is
  #pod   a symlink and the first component of "C" is an updir.
  #pod * Symlinks in "B" don't change the result and will exist in the result as
  #pod   given.
  #pod * Symlinks and updirs in "C" must be resolved to actual paths, taking into
  #pod   account the possibility that not all path components might exist on the
  #pod   filesystem.
  #pod
  #pod Current API available since 0.001.  New algorithm (that accounts for
  #pod symlinks) available since 0.079.
  #pod
  #pod =cut

  sub relative {
      my ( $self, $base ) = @_;
      $base = _path( defined $base && length $base ? $base : '.' );

      # relative paths must be converted to absolute first
      $self = $self->absolute if $self->is_relative;
      $base = $base->absolute if $base->is_relative;

      # normalize volumes if they exist
      $self = $self->absolute if !length $self->volume && length $base->volume;
      $base = $base->absolute if length $self->volume  && !length $base->volume;

      # can't make paths relative across volumes
      if ( !_same( $self->volume, $base->volume ) ) {
          Carp::croak("relative() can't cross volumes: '$self' vs '$base'");
      }

      # if same absolute path, relative is current directory
      return _path(".") if _same( $self->[PATH], $base->[PATH] );

      # if base is a prefix of self, chop prefix off self
      if ( $base->subsumes($self) ) {
          $base = "" if $base->is_rootdir;
          my $relative = "$self";
          $relative =~ s{\A\Q$base/}{};
          return _path(".", $relative);
      }

      # base is not a prefix, so must find a common prefix (even if root)
      my ( @common, @self_parts, @base_parts );
      @base_parts = split /\//, $base->_just_filepath;

      # if self is rootdir, then common directory is root (shown as empty
      # string for later joins); otherwise, must be computed from path parts.
      if ( $self->is_rootdir ) {
          @common = ("");
          shift @base_parts;
      }
      else {
          @self_parts = split /\//, $self->_just_filepath;

          while ( @self_parts && @base_parts && _same( $self_parts[0], $base_parts[0] ) ) {
              push @common, shift @base_parts;
              shift @self_parts;
          }
      }

      # if there are any symlinks from common to base, we have a problem, as
      # you can't guarantee that updir from base reaches the common prefix;
      # we must resolve symlinks and try again; likewise, any updirs are
      # a problem as it throws off calculation of updirs needed to get from
      # self's path to the common prefix.
      if ( my $new_base = $self->_resolve_between( \@common, \@base_parts ) ) {
          return $self->relative($new_base);
      }

      # otherwise, symlinks in common or from common to A don't matter as
      # those don't involve updirs
      my @new_path = ( ("..") x ( 0+ @base_parts ), @self_parts );
      return _path(@new_path);
  }

  sub _just_filepath {
      my $self     = shift;
      my $self_vol = $self->volume;
      return "$self" if !length $self_vol;

      ( my $self_path = "$self" ) =~ s{\A\Q$self_vol}{};

      return $self_path;
  }

  sub _resolve_between {
      my ( $self, $common, $base ) = @_;
      my $path = $self->volume . join( "/", @$common );
      my $changed = 0;
      for my $p (@$base) {
          $path .= "/$p";
          if ( $p eq '..' ) {
              $changed = 1;
              if ( -e $path ) {
                  $path = _path($path)->realpath->[PATH];
              }
              else {
                  $path =~ s{/[^/]+/..\z}{/};
              }
          }
          if ( -l $path ) {
              $changed = 1;
              $path    = _path($path)->realpath->[PATH];
          }
      }
      return $changed ? _path($path) : undef;
  }

  #pod =method remove
  #pod
  #pod     path("foo.txt")->remove;
  #pod
  #pod This is just like C<unlink>, except for its error handling: if the path does
  #pod not exist, it returns false; if deleting the file fails, it throws an
  #pod exception.
  #pod
  #pod Current API available since 0.012.
  #pod
  #pod =cut

  sub remove {
      my $self = shift;

      return 0 if !-e $self->[PATH] && !-l $self->[PATH];

      return unlink( $self->[PATH] ) || $self->_throw('unlink');
  }

  #pod =method remove_tree
  #pod
  #pod     # directory
  #pod     path("foo/bar/baz")->remove_tree;
  #pod     path("foo/bar/baz")->remove_tree( \%options );
  #pod     path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  #pod
  #pod Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  #pod An optional hash reference is passed through to C<remove_tree>.  Errors will be
  #pod trapped and an exception thrown.  Returns the number of directories deleted,
  #pod just like C<remove_tree>.
  #pod
  #pod If you want to remove a directory only if it is empty, use the built-in
  #pod C<rmdir> function instead.
  #pod
  #pod     rmdir path("foo/bar/baz/");
  #pod
  #pod Current API available since 0.013.
  #pod
  #pod =cut

  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{error} = \$err unless defined $args->{error};
      $args->{safe}  = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );

      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }

  #pod =method sibling
  #pod
  #pod     $foo = path("/tmp/foo.txt");
  #pod     $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
  #pod     $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt
  #pod
  #pod Returns a new C<Path::Tiny> object relative to the parent of the original.
  #pod This is slightly more efficient than C<< $path->parent->child(...) >>.
  #pod
  #pod Current API available since 0.058.
  #pod
  #pod =cut

  sub sibling {
      my $self = shift;
      return _path( $self->parent->[PATH], @_ );
  }

  #pod =method size, size_human
  #pod
  #pod     my $p = path("foo"); # with size 1025 bytes
  #pod
  #pod     $p->size;                            # "1025"
  #pod     $p->size_human;                      # "1.1 K"
  #pod     $p->size_human( {format => "iec"} ); # "1.1 KiB"
  #pod
  #pod Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.
  #pod
  #pod The C<size_human> method provides a human-readable string similar to
  #pod C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  #pod single-digit sizes and no decimal places for larger sizes.  The only available
  #pod option is C<format>, which has three valid values:
  #pod
  #pod =for :list
  #pod * 'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)
  #pod * 'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)
  #pod * 'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)
  #pod
  #pod If C<-s> would return C<undef>, C<size_human> returns the empty string.
  #pod
  #pod Current API available since 0.122.
  #pod
  #pod =cut

  sub size { -s $_[0]->[PATH] }

  my %formats = (
      'ls'  => [ 1024, log(1024), [ "", map { " $_" } qw/K M G T/ ] ],
      'iec' => [ 1024, log(1024), [ "", map { " $_" } qw/KiB MiB GiB TiB/ ] ],
      'si'  => [ 1000, log(1000), [ "", map { " $_" } qw/kB MB GB TB/ ] ],
  );

  sub _formats { return $formats{$_[0]} }

  sub size_human {
      my $self     = shift;
      my $args     = _get_args( shift, qw/format/ );
      my $format   = defined $args->{format} ? $args->{format} : "ls";
      my $fmt_opts = $formats{$format}
        or Carp::croak("Invalid format '$format' for size_human()");
      my $size = -s $self->[PATH];
      return defined $size ? _human_size( $size, @$fmt_opts ) : "";
  }

  sub _ceil {
      return $_[0] == int($_[0]) ? $_[0] : int($_[0]+1);
  }

  sub _human_size {
      my ( $size, $base, $log_base, $suffixes ) = @_;
      return "0" if $size == 0;

      my $mag = int( log($size) / $log_base );
      $size /= $base**$mag;
      $size =
          $mag == 0               ? $size
        : length( int($size) ) == 1 ? _ceil( $size * 10 ) / 10
        :                             _ceil($size);
      if ( $size >= $base ) {
          $size /= $base;
          $mag++;
      }

      my $fmt = ( $mag == 0 || length( int($size) ) > 1 ) ? "%.0f%s" : "%.1f%s";
      return sprintf( $fmt, $size, $suffixes->[$mag] );
  }

  #pod =method slurp, slurp_raw, slurp_utf8
  #pod
  #pod     $data = path("foo.txt")->slurp;
  #pod     $data = path("foo.txt")->slurp( {binmode => ":raw"} );
  #pod     $data = path("foo.txt")->slurp_raw;
  #pod     $data = path("foo.txt")->slurp_utf8;
  #pod
  #pod Reads file contents into a scalar.  Takes an optional hash reference which may
  #pod be used to pass options.  The only available option is C<binmode>, which is
  #pod passed to C<binmode()> on the handle used for reading.
  #pod
  #pod C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  #pod a fast, unbuffered, raw read.
  #pod
  #pod C<slurp_utf8> is like C<slurp> with a C<binmode> of
  #pod C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
  #pod L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a
  #pod unbuffered, raw slurp will be done instead and the result decoded with
  #pod C<Unicode::UTF8>. This is just as strict and is roughly an order of
  #pod magnitude faster than using C<:encoding(UTF-8)>.
  #pod
  #pod B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  #pod you plan to slurp from a file created with L<File::Temp>, be sure to
  #pod close other handles or open without locking to avoid a deadlock:
  #pod
  #pod     my $tempfile = File::Temp->new(EXLOCK => 0);
  #pod     my $guts = path($tempfile)->slurp;
  #pod
  #pod Current API available since 0.004.
  #pod
  #pod =cut

  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( { locked => 1 }, "<", $binmode );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          my $rc = read $fh, $buf, $size; # File::Slurp in a nutshell
          $self->_throw('read') unless defined $rc;
          return $buf;
      }
      else {
          local $/;
          my $buf = scalar <$fh>;
          $self->_throw('read') unless defined $buf;
          return $buf;
      }
  }

  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }

  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          $_[1] = { binmode => ":unix:utf8_strict" };
          goto &slurp;
      }
      else {
          $_[1] = { binmode => ":unix:encoding(UTF-8)" };
          goto &slurp;
      }
  }

  #pod =method spew, spew_raw, spew_utf8
  #pod
  #pod     path("foo.txt")->spew(@data);
  #pod     path("foo.txt")->spew(\@data);
  #pod     path("foo.txt")->spew({binmode => ":raw"}, @data);
  #pod     path("foo.txt")->spew_raw(@data);
  #pod     path("foo.txt")->spew_utf8(@data);
  #pod
  #pod Writes data to a file atomically.  The file is written to a temporary file in
  #pod the same directory, then renamed over the original.  An optional hash reference
  #pod may be used to pass options.  The only option is C<binmode>, which is passed to
  #pod C<binmode()> on the handle used for writing.
  #pod
  #pod C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  #pod unbuffered, raw write.
  #pod
  #pod C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  #pod (or C<:unix:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  #pod 0.58+ is installed, a raw, unbuffered spew will be done instead on the data
  #pod encoded with C<Unicode::UTF8>.
  #pod
  #pod B<NOTE>: because the file is written to a temporary file and then renamed, the
  #pod new file will wind up with permissions based on your current umask.  This is a
  #pod feature to protect you from a race condition that would otherwise give
  #pod different permissions than you might expect.  If you really want to keep the
  #pod original mode flags, use L</append> with the C<truncate> option.
  #pod
  #pod Current API available since 0.011.
  #pod
  #pod =cut

  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      # get default binmode from caller's lexical scope (see "perldoc open")
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;

      # writing needs to follow the link and create the tempfile in the same
      # dir for later atomic rename
      my $resolved_path = $self->_resolve_symlinks;
      my $temp          = $resolved_path->_replacment_path;

      my $fh   = $temp->filehandle( { exclusive => 1, locked => 1 }, ">", $binmode );
      print( {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data) or self->_throw('print', $temp->[PATH]);
      close $fh or $self->_throw( 'close', $temp->[PATH] );

      return $temp->move($resolved_path);
  }

  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }

  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : ( $HAS_UU = _check_UU() ) ) {
          my $self = shift;
          spew(
              $self,
              { binmode => ":unix" },
              map { Unicode::UTF8::encode_utf8($_) } map { ref eq 'ARRAY' ? @$_ : $_ } @_
          );
      }
      elsif ( defined($HAS_PU) ? $HAS_PU : ( $HAS_PU = _check_PU() ) ) {
          splice @_, 1, 0, { binmode => ":unix:utf8_strict" };
          goto &spew;
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }

  #pod =method stat, lstat
  #pod
  #pod     $stat = path("foo.txt")->stat;
  #pod     $stat = path("/some/symlink")->lstat;
  #pod
  #pod Like calling C<stat> or C<lstat> from L<File::stat>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || $self->_throw('stat');
  }

  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || $self->_throw('lstat');
  }

  #pod =method stringify
  #pod
  #pod     $path = path("foo.txt");
  #pod     say $path->stringify; # same as "$path"
  #pod
  #pod Returns a string representation of the path.  Unlike C<canonpath>, this method
  #pod returns the path standardized with Unix-style C</> directory separators.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub stringify { $_[0]->[PATH] =~ /^~/ ? './' . $_[0]->[PATH] : $_[0]->[PATH] }

  #pod =method subsumes
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/baz"); # true
  #pod     path("/foo/bar")->subsumes("/foo/baz");   # false
  #pod
  #pod Returns true if the first path is a prefix of the second path at a directory
  #pod boundary.
  #pod
  #pod This B<does not> resolve parent directory entries (C<..>) or symlinks:
  #pod
  #pod     path("foo/bar")->subsumes("foo/bar/../baz"); # true
  #pod
  #pod If such things are important to you, ensure that both paths are resolved to
  #pod the filesystem with C<realpath>:
  #pod
  #pod     my $p1 = path("foo/bar")->realpath;
  #pod     my $p2 = path("foo/bar/../baz")->realpath;
  #pod     if ( $p1->subsumes($p2) ) { ... }
  #pod
  #pod Current API available since 0.048.
  #pod
  #pod =cut

  sub subsumes {
      my $self = shift;
      Carp::croak("subsumes() requires a defined, positive-length argument")
        unless defined $_[0];
      my $other = _path(shift);

      # normalize absolute vs relative
      if ( $self->is_absolute && !$other->is_absolute ) {
          $other = $other->absolute;
      }
      elsif ( $other->is_absolute && !$self->is_absolute ) {
          $self = $self->absolute;
      }

      # normalize volume vs non-volume; do this after absolute path
      # adjustments above since that might add volumes already
      if ( length $self->volume && !length $other->volume ) {
          $other = $other->absolute;
      }
      elsif ( length $other->volume && !length $self->volume ) {
          $self = $self->absolute;
      }

      if ( $self->[PATH] eq '.' ) {
          return !!1; # cwd subsumes everything relative
      }
      elsif ( $self->is_rootdir ) {
          # a root directory ("/", "c:/") already ends with a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E};
      }
      else {
          # exact match or prefix breaking at a separator
          return $other->[PATH] =~ m{^\Q$self->[PATH]\E(?:/|\z)};
      }
  }

  #pod =method touch
  #pod
  #pod     path("foo.txt")->touch;
  #pod     path("foo.txt")->touch($epoch_secs);
  #pod
  #pod Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  #pod changes the modification and access times to the current time.  If the first
  #pod argument is the epoch seconds then it will be used.
  #pod
  #pod Returns the path object so it can be easily chained with other methods:
  #pod
  #pod     # won't die if foo.txt doesn't exist
  #pod     $content = path("foo.txt")->touch->slurp;
  #pod
  #pod Current API available since 0.015.
  #pod
  #pod =cut

  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or $self->_throw('close');
      }
      if ( defined $epoch ) {
          utime $epoch, $epoch, $self->[PATH]
            or $self->_throw("utime ($epoch)");
      }
      else {
          # literal undef prevents warnings :-(
          utime undef, undef, $self->[PATH]
            or $self->_throw("utime ()");
      }
      return $self;
  }

  #pod =method touchpath
  #pod
  #pod     path("bar/baz/foo.txt")->touchpath;
  #pod
  #pod Combines C<mkdir> and C<touch>.  Creates the parent directory if it doesn't exist,
  #pod before touching the file.  Returns the path object like C<touch> does.
  #pod
  #pod If you need to pass options, use C<mkdir> and C<touch> separately:
  #pod
  #pod     path("bar/baz")->mkdir( \%options )->child("foo.txt")->touch($epoch_secs);
  #pod
  #pod Current API available since 0.022.
  #pod
  #pod =cut

  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkdir unless $parent->exists;
      $self->touch;
  }

  #pod =method visit
  #pod
  #pod     path("/tmp")->visit( \&callback, \%options );
  #pod
  #pod Executes a callback for each child of a directory.  It returns a hash
  #pod reference with any state accumulated during iteration.
  #pod
  #pod The options are the same as for L</iterator> (which it uses internally):
  #pod C<recurse> and C<follow_symlinks>.  Both default to false.
  #pod
  #pod The callback function will receive a C<Path::Tiny> object as the first argument
  #pod and a hash reference to accumulate state as the second argument.  For example:
  #pod
  #pod     # collect files sizes
  #pod     my $sizes = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             return if $path->is_dir;
  #pod             $state->{$path} = -s $path;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod For convenience, the C<Path::Tiny> object will also be locally aliased as the
  #pod C<$_> global variable:
  #pod
  #pod     # print paths matching /foo/
  #pod     path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );
  #pod
  #pod If the callback returns a B<reference> to a false scalar value, iteration will
  #pod terminate.  This is not the same as "pruning" a directory search; this just
  #pod stops all iteration and returns the state hash reference.
  #pod
  #pod     # find up to 10 files larger than 100K
  #pod     my $files = path("/tmp")->visit(
  #pod         sub {
  #pod             my ($path, $state) = @_;
  #pod             $state->{$path}++ if -s $path > 102400
  #pod             return \0 if keys %$state == 10;
  #pod         },
  #pod         { recurse => 1 }
  #pod     );
  #pod
  #pod If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.
  #pod
  #pod Current API available since 0.062.
  #pod
  #pod =cut

  sub visit {
      my $self = shift;
      my $cb   = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      Carp::croak("Callback for visit() must be a code reference")
        unless defined($cb) && ref($cb) eq 'CODE';
      my $next  = $self->iterator($args);
      my $state = {};
      while ( my $file = $next->() ) {
          local $_ = $file;
          my $r = $cb->( $file, $state );
          last if ref($r) eq 'SCALAR' && !$$r;
      }
      return $state;
  }

  #pod =method volume
  #pod
  #pod     $vol = path("/tmp/foo.txt")->volume;   # ""
  #pod     $vol = path("C:/tmp/foo.txt")->volume; # "C:"
  #pod
  #pod Returns the volume portion of the path.  This is equivalent
  #pod to what L<File::Spec> would give from C<splitpath> and thus
  #pod usually is the empty string on Unix-like operating systems or the
  #pod drive letter for an absolute path on C<MSWin32>.
  #pod
  #pod Current API available since 0.001.
  #pod
  #pod =cut

  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }

  package Path::Tiny::Error;

  our @CARP_NOT = qw/Path::Tiny/;

  use overload ( q{""} => sub { (shift)->{msg} }, fallback => 1 );

  sub throw {
      my ( $class, $op, $file, $err ) = @_;
      chomp( my $trace = Carp::shortmess );
      my $msg = "Error $op on '$file': $err$trace\n";
      die bless { op => $op, file => $file, err => $err, msg => $msg }, $class;
  }

  1;


  # vim: ts=4 sts=4 sw=4 et:

  __END__

  =pod

  =encoding UTF-8

  =head1 NAME

  Path::Tiny - File path utility

  =head1 VERSION

  version 0.144

  =head1 SYNOPSIS

    use Path::Tiny;

    # Creating Path::Tiny objects

    my $dir = path("/tmp");
    my $foo = path("foo.txt");

    my $subdir = $dir->child("foo");
    my $bar = $subdir->child("bar.txt");

    # Stringifies as cleaned up path

    my $file = path("./foo.txt");
    print $file; # "foo.txt"

    # Reading files

    my $guts = $file->slurp;
       $guts = $file->slurp_utf8;

    my @lines = $file->lines;
       @lines = $file->lines_utf8;

    my ($head) = $file->lines( {count => 1} );
    my ($tail) = $file->lines( {count => -1} );

    # Writing files

    $bar->spew( @data );
    $bar->spew_utf8( @data );

    # Reading directories

    for ( $dir->children ) { ... }

    my $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }

  =head1 DESCRIPTION

  This module provides a small, fast utility for working with file paths.  It is
  friendlier to use than L<File::Spec> and provides easy access to functions from
  several other core file handling modules.  It aims to be smaller and faster
  than many alternatives on CPAN, while helping people do many common things in
  consistent and less error-prone ways.

  Path::Tiny does not try to work for anything except Unix-like and Win32
  platforms.  Even then, it might break if you try something particularly obscure
  or tortuous.  (Quick!  What does this mean:
  C<< ///../../..//./././a//b/.././c/././ >>?  And how does it differ on Win32?)

  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).

  File input/output methods C<flock> handles before reading or writing,
  as appropriate (if supported by the platform and/or filesystem).

  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode.  On Windows, that means they will not have CRLF translation from the
  C<:crlf> IO layer.  Installing L<Unicode::UTF8> 0.58 or later will speed up
  C<*_utf8> situations in many cases and is highly recommended.
  Alternatively, installing L<PerlIO::utf8_strict> 0.003 or later will be
  used in place of the default C<:encoding(UTF-8)>.

  This module depends heavily on PerlIO layers for correct operation and thus
  requires Perl 5.008001 or later.

  =head1 CONSTRUCTORS

  =head2 path

      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd

  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.

  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.

  B<DEPRECATED>: If and only if the B<first> character of the B<first> argument
  to C<path> is a tilde ('~'), then tilde replacement will be applied to the
  first path segment. A single tilde will be replaced with C<glob('~')> and a
  tilde followed by a username will be replaced with output of
  C<glob('~username')>. B<No other method does tilde expansion on its arguments>.
  See L</Tilde expansion (deprecated)> for more.

  On Windows, if the path consists of a drive identifier without a path component
  (C<C:> or C<D:>), it will be expanded to the absolute path of the current
  directory on that volume using C<Cwd::getdcwd()>.

  If called with a single C<Path::Tiny> argument, the original is returned unless
  the original is holding a temporary file or directory reference in which case a
  stringified copy is made.

      $path = path("foo/bar");
      $temp = Path::Tiny->tempfile;

      $p2 = path($path); # like $p2 = $path
      $t2 = path($temp); # like $t2 = path( "$temp" )

  This optimizes copies without proliferating references unexpectedly if a copy is
  made by code outside your control.

  Current API available since 0.017.

  =head2 new

      $path = Path::Tiny->new("foo/bar");

  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)

  Current API available since 0.001.

  =head2 cwd

      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export

  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.

  C<cwd> may be exported on request and used as a function instead of as a
  method.

  Current API available since 0.018.

  =head2 rootdir

      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export

  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.

  C<rootdir> may be exported on request and used as a function instead of as a
  method.

  Current API available since 0.018.

  =head2 tempfile, tempdir

      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = $dirpath->tempfile( @options );
      $temp = $dirpath->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export

  C<tempfile> passes the options to C<< File::Temp->new >> and returns a
  C<Path::Tiny> object with the file name.  The C<TMPDIR> option will be enabled
  by default, but you can override that by passing C<< TMPDIR => 0 >> along with
  the options.  (If you use an absolute C<TEMPLATE> option, you will want to
  disable C<TMPDIR>.)

  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.

  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.

      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok

  The tempfile path object will be normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.  If you want it to have
  the C<realpath> instead, pass a leading options hash like this:

      $real_temp = tempfile({realpath => 1}, @options);

  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.

  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.

  The methods can be called on an instances representing a
  directory. In this case, the directory is used as the base to create the
  temporary file/directory, setting the C<DIR> option in File::Temp.

      my $target_dir = path('/to/destination');
      my $tempfile = $target_dir->tempfile('foobarXXXXXX');
      $tempfile->spew('A lot of data...');  # not atomic
      $tempfile->move($target_dir->child('foobar')); # hopefully atomic

  In this case, any value set for option C<DIR> is ignored.

  B<Note>: for tempfiles, the filehandles from File::Temp are closed and not
  reused.  This is not as secure as using File::Temp handles directly, but is
  less prone to deadlocks or access problems on some platforms.  Think of what
  C<Path::Tiny> gives you to be just a temporary file B<name> that gets cleaned
  up.

  B<Note 2>: if you don't want these cleaned up automatically when the object
  is destroyed, File::Temp requires different options for directories and
  files.  Use C<< CLEANUP => 0 >> for directories and C<< UNLINK => 0 >> for
  files.

  B<Note 3>: Don't lose the temporary object by chaining a method call instead
  of storing it:

      my $lost = tempdir()->child("foo"); # tempdir cleaned up right away

  B<Note 4>: The cached object may be accessed with the L</cached_temp> method.
  Keeping a reference to, or modifying the cached object may break the
  behavior documented above and is not supported.  Use at your own risk.

  Current API available since 0.119.

  =head1 METHODS

  =head2 absolute

      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");

  Returns a new C<Path::Tiny> object with an absolute path (or itself if already
  absolute).  If no argument is given, the current directory is used as the
  absolute base path.  If an argument is given, it will be converted to an
  absolute path (if it is not already) and used as the absolute base path.

  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.

  On Windows, an absolute path without a volume component will have it added
  based on the current drive.

  Current API available since 0.101.

  =head2 append, append_raw, append_utf8

      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);

  Appends data to a file.  The file is locked with C<flock> prior to writing
  and closed afterwards.  An optional hash reference may be used to pass
  options.  Valid options are:

  =over 4

  =item *

  C<binmode>: passed to C<binmode()> on the handle used for writing.

  =item *

  C<truncate>: truncates the file after locking and before appending

  =back

  The C<truncate> option is a way to replace the contents of a file
  B<in place>, unlike L</spew> which writes to a temporary file and then
  replaces the original (if it exists).

  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.

  C<append_utf8> is like C<append> with an unbuffered C<binmode>
  C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
  L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, an
  unbuffered, raw append will be done instead on the data encoded with
  C<Unicode::UTF8>.

  Current API available since 0.060.

  =head2 assert

      $path = path("foo.txt")->assert( sub { $_->exists } );

  Returns the invocant after asserting that a code reference argument returns
  true.  When the assertion code reference runs, it will have the invocant
  object in the C<$_> variable.  If it returns false, an exception will be
  thrown.  The assertion code reference may also throw its own exception.

  If no assertion is provided, the invocant is returned without error.

  Current API available since 0.062.

  =head2 basename

      $name = path("foo/bar.txt")->basename;        # bar.txt
      $name = path("foo.txt")->basename('.txt');    # foo
      $name = path("foo.txt")->basename(qr/.txt/);  # foo
      $name = path("foo.txt")->basename(@suffixes);

  Returns the file portion or last directory portion of a path.

  Given a list of suffixes as strings or regular expressions, any that match at
  the end of the file portion or last directory portion will be removed before
  the result is returned.

  Current API available since 0.054.

  =head2 canonpath

      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows

  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.

  Current API available since 0.001.

  =head2 cached_temp

  Returns the cached C<File::Temp> or C<File::Temp::Dir> object if the
  C<Path::Tiny> object was created with C</tempfile> or C</tempdir>.
  If there is no such object, this method throws.

  B<WARNING>: Keeping a reference to, or modifying the cached object may
  break the behavior documented for temporary files and directories created
  with C<Path::Tiny> and is not supported.  Use at your own risk.

  Current API available since 0.101.

  =head2 child

      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);

  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.

  B<WARNING>: because the argument could contain C<..> or refer to symlinks,
  there is no guarantee that the new path refers to an actual descendent of
  the original.  If this is important to you, transform parent and child with
  L</realpath> and check them with L</subsumes>.

  Current API available since 0.001.

  =head2 children

      @paths = path("/tmp")->children;
      @paths = path("/tmp")->children( qr/\.txt\z/ );

  Returns a list of C<Path::Tiny> objects for all files and directories
  within a directory.  Excludes "." and ".." automatically.

  If an optional C<qr//> argument is provided, it only returns objects for child
  names that match the given regular expression.  Only the base name is used
  for matching:

      @paths = path("/tmp")->children( qr/^foo/ );
      # matches children like the glob foo*

  Current API available since 0.028.

  =head2 chmod

      path("foo.txt")->chmod(0777);
      path("foo.txt")->chmod("0755");
      path("foo.txt")->chmod("go-w");
      path("foo.txt")->chmod("a=r,u+wx");

  Sets file or directory permissions.  The argument can be a numeric mode, a
  octal string beginning with a "0" or a limited subset of the symbolic mode use
  by F</bin/chmod>.

  The symbolic mode must be a comma-delimited list of mode clauses.  Clauses must
  match C<< qr/\A([augo]+)([=+-])([rwx]+)\z/ >>, which defines "who", "op" and
  "perms" parameters for each clause.  Unlike F</bin/chmod>, all three parameters
  are required for each clause, multiple ops are not allowed and permissions
  C<stugoX> are not supported.  (See L<File::chmod> for more complex needs.)

  Current API available since 0.053.

  =head2 copy

      path("/tmp/foo.txt")->copy("/tmp/bar.txt");

  Copies the current path to the given destination using L<File::Copy>'s
  C<copy> function. Upon success, returns the C<Path::Tiny> object for the
  newly copied file.

  Current API available since 0.070.

  =head2 digest

      $obj = path("/tmp/foo.txt")->digest;        # SHA-256
      $obj = path("/tmp/foo.txt")->digest("MD5"); # user-selected
      $obj = path("/tmp/foo.txt")->digest( { chunk_size => 1e6 }, "MD5" );

  Returns a hexadecimal digest for a file.  An optional hash reference of options may
  be given.  The only option is C<chunk_size>.  If C<chunk_size> is given, that many
  bytes will be read at a time.  If not provided, the entire file will be slurped
  into memory to compute the digest.

  Any subsequent arguments are passed to the constructor for L<Digest> to select
  an algorithm.  If no arguments are given, the default is SHA-256.

  Current API available since 0.056.

  =head2 dirname (deprecated)

      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"

  Returns the directory portion you would get from calling
  C<< File::Spec->splitpath( $path->stringify ) >> or C<"."> for a path without a
  parent directory portion.  Because L<File::Spec> is inconsistent, the result
  might or might not have a trailing slash.  Because of this, this method is
  B<deprecated>.

  A better, more consistently approach is likely C<< $path->parent->stringify >>,
  which will not have a trailing slash except for a root directory.

  Deprecated in 0.056.

  =head2 edit, edit_raw, edit_utf8

      path("foo.txt")->edit( \&callback, $options );
      path("foo.txt")->edit_utf8( \&callback );
      path("foo.txt")->edit_raw( \&callback );

  These are convenience methods that allow "editing" a file using a single
  callback argument. They slurp the file using C<slurp>, place the contents
  inside a localized C<$_> variable, call the callback function (without
  arguments), and then write C<$_> (presumably mutated) back to the
  file with C<spew>.

  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<slurp> and C<spew>.

  C<edit_utf8> and C<edit_raw> act like their respective C<slurp_*> and
  C<spew_*> methods.

  Current API available since 0.077.

  =head2 edit_lines, edit_lines_utf8, edit_lines_raw

      path("foo.txt")->edit_lines( \&callback, $options );
      path("foo.txt")->edit_lines_utf8( \&callback );
      path("foo.txt")->edit_lines_raw( \&callback );

  These are convenience methods that allow "editing" a file's lines using a
  single callback argument.  They iterate over the file: for each line, the
  line is put into a localized C<$_> variable, the callback function is
  executed (without arguments) and then C<$_> is written to a temporary file.
  When iteration is finished, the temporary file is atomically renamed over
  the original.

  An optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to the method that open handles for reading and
  writing.

  C<edit_lines_raw> is like C<edit_lines> with a buffered C<binmode> of
  C<:raw>.

  C<edit_lines_utf8> is like C<edit_lines> with a buffered C<binmode>
  C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
  L<PerlIO::utf8_strict>).

  Current API available since 0.077.

  =head2 exists, is_file, is_dir

      if ( path("/tmp")->exists ) { ... }     # -e
      if ( path("/tmp")->is_dir ) { ... }     # -d
      if ( path("/tmp")->is_file ) { ... }    # -e && ! -d

  Implements file test operations, this means the file or directory actually has
  to exist on the filesystem.  Until then, it's just a path.

  B<Note>: C<is_file> is not C<-f> because C<-f> is not the opposite of C<-d>.
  C<-f> means "plain file", excluding symlinks, devices, etc. that often can be
  read just like files.

  Use C<-f> instead if you really mean to check for a plain file.

  Current API available since 0.053.

  =head2 filehandle

      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ locked => 1 }, $mode, $binmode);
      $fh = path("/tmp/foo.txt")->filehandle({ exclusive => 1  }, $mode, $binmode);

  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", ">>", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.

  An optional hash reference may be used to pass options.

  The C<locked> option governs file locking; if true, handles opened for writing,
  appending or read-write are locked with C<LOCK_EX>; otherwise, they are
  locked with C<LOCK_SH>.  When using C<locked>, ">" or "+>" modes will delay
  truncation until after the lock is acquired.

  The C<exclusive> option causes the open() call to fail if the file already
  exists.  This corresponds to the O_EXCL flag to sysopen / open(2).
  C<exclusive> implies C<locked> and will set it for you if you forget it.

  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.

  Current API available since 0.066.

  =head2 has_same_bytes

      if ( path("foo.txt")->has_same_bytes("bar.txt") ) {
         # ...
      }

  This method returns true if both the invocant and the argument can be opened as
  file handles and the handles contain the same bytes.  It returns false if their
  contents differ.  If either can't be opened as a file (e.g. a directory or
  non-existent file), the method throws an exception.  If both can be opened and
  both have the same C<realpath>, the method returns true without scanning any
  data.

  Current API available since 0.125.

  =head2 is_absolute, is_relative

      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }

  Booleans for whether the path appears absolute or relative.

  Current API available since 0.001.

  =head2 is_rootdir

      while ( ! $path->is_rootdir ) {
          $path = $path->parent;
          ...
      }

  Boolean for whether the path is the root directory of the volume.  I.e. the
  C<dirname> is C<q[/]> and the C<basename> is C<q[]>.

  This works even on C<MSWin32> with drives and UNC volumes:

      path("C:/")->is_rootdir;             # true
      path("//server/share/")->is_rootdir; #true

  Current API available since 0.038.

  =head2 iterator

      $iter = path("/tmp")->iterator( \%options );

  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.

      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }

  The current and parent directory entries ("." and "..") will not
  be included.

  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links. If a directory is not readable, it will not be
  followed.

  The default is the same as:

      $iter = path("/tmp")->iterator( {
          recurse         => 0,
          follow_symlinks => 0,
      } );

  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.

  See also L</visit>.

  Current API available since 0.016.

  =head2 lines, lines_raw, lines_utf8

      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;

      @contents = path("/tmp/foo.txt")->lines( { chomp => 1, count => 4 } );

  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.

  If C<binmode> is provided, it will be set on the handle prior to reading.

  If a positive C<count> is provided, that many lines will be returned from the
  start of the file.  If a negative C<count> is provided, the entire file will be
  read, but only C<abs(count)> will be kept and returned.  If C<abs(count)>
  exceeds the number of lines in the file, all lines will be returned.

  If C<chomp> is set, any end-of-line character sequences (C<CR>, C<CRLF>, or
  C<LF>) will be removed from the lines returned.

  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).

      $number_of_lines = path("/tmp/foo.txt")->lines;

  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.

  C<lines_utf8> is like C<lines> with a C<binmode> of C<:raw:encoding(UTF-8)>
  (or C<:raw:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw, unbuffered UTF-8 slurp will be done and then the
  lines will be split.  This is actually faster than relying on
  IO layers, though a bit memory intensive.  If memory use is a
  concern, consider C<openr_utf8> and iterating directly on the handle.

  Current API available since 0.065.

  =head2 mkdir

      path("foo/bar/baz")->mkdir;
      path("foo/bar/baz")->mkdir( \%options );

  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the the path object to facilitate chaining.

  B<NOTE>: unlike Perl's builtin C<mkdir>, this will create intermediate paths
  similar to the Unix C<mkdir -p> command.  It will not error if applied to an
  existing directory.

  Current API available since 0.125.

  =head2 mkpath (deprecated)

  Like calling C<mkdir>, but returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.

  Deprecated in 0.125.

  =head2 move

      path("foo.txt")->move("bar.txt");

  Moves the current path to the given destination using L<File::Copy>'s
  C<move> function. Upon success, returns the C<Path::Tiny> object for the
  newly moved file.

  If the destination already exists and is a directory, and the source is not a
  directory, then the source file will be renamed into the directory
  specified by the destination.

  If possible, move() will simply rename the file. Otherwise, it
  copies the file to the new location and deletes the original. If an
  error occurs during this copy-and-delete process, you may be left
  with a (possibly partial) copy of the file under the destination
  name.

  Current API available since 0.124. Prior versions used Perl's
  -built-in (and less robust) L<rename|perlfunc/rename> function
  and did not return an object.

  =head2 openr, openw, openrw, opena

      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;

      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;

      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;

      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;

  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use buffered I/O layers C<:raw>
  and C<:raw:encoding(UTF-8)> (or C<:raw:utf8_strict> with
  L<PerlIO::utf8_strict>).

  An optional hash reference may be used to pass options.  The only option is
  C<locked>.  If true, handles opened for writing, appending or read-write are
  locked with C<LOCK_EX>; otherwise, they are locked for C<LOCK_SH>.

      $fh = path("foo.txt")->openrw_utf8( { locked => 1 } );

  See L</filehandle> for more on locking.

  Current API available since 0.011.

  =head2 parent

      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo

      $parent = path("foo/bar/baz")->parent(2); # foo

  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.

  Current API available since 0.014.

  =head2 realpath

      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;

  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.

  If the parent path can't be resolved (e.g. if it includes directories that
  don't exist), an exception will be thrown:

      $real = path("doesnt_exist/foo")->realpath; # dies

  However, if the parent path exists and only the last component (e.g. filename)
  doesn't exist, the realpath will be the realpath of the parent plus the
  non-existent last component:

      $real = path("./aasdlfasdlf")->realpath; # works

  The underlying L<Cwd> module usually worked this way on Unix, but died on
  Windows (and some Unixes) if the full path didn't exist.  As of version 0.064,
  it's safe to use anywhere.

  Current API available since 0.001.

  =head2 relative

      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar

  Returns a C<Path::Tiny> object with a path relative to a new base path
  given as an argument.  If no argument is given, the current directory will
  be used as the new base path.

  If either path is already relative, it will be made absolute based on the
  current directly before determining the new relative path.

  The algorithm is roughly as follows:

  =over 4

  =item *

  If the original and new base path are on different volumes, an exception will be thrown.

  =item *

  If the original and new base are identical, the relative path is C<".">.

  =item *

  If the new base subsumes the original, the relative path is the original path with the new base chopped off the front

  =item *

  If the new base does not subsume the original, a common prefix path is determined (possibly the root directory) and the relative path will consist of updirs (C<"..">) to reach the common prefix, followed by the original path less the common prefix.

  =back

  Unlike C<File::Spec::abs2rel>, in the last case above, the calculation based
  on a common prefix takes into account symlinks that could affect the updir
  process.  Given an original path "/A/B" and a new base "/A/C",
  (where "A", "B" and "C" could each have multiple path components):

  =over 4

  =item *

  Symlinks in "A" don't change the result unless the last component of A is a symlink and the first component of "C" is an updir.

  =item *

  Symlinks in "B" don't change the result and will exist in the result as given.

  =item *

  Symlinks and updirs in "C" must be resolved to actual paths, taking into account the possibility that not all path components might exist on the filesystem.

  =back

  Current API available since 0.001.  New algorithm (that accounts for
  symlinks) available since 0.079.

  =head2 remove

      path("foo.txt")->remove;

  This is just like C<unlink>, except for its error handling: if the path does
  not exist, it returns false; if deleting the file fails, it throws an
  exception.

  Current API available since 0.012.

  =head2 remove_tree

      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove

  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.

  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.

      rmdir path("foo/bar/baz/");

  Current API available since 0.013.

  =head2 sibling

      $foo = path("/tmp/foo.txt");
      $sib = $foo->sibling("bar.txt");        # /tmp/bar.txt
      $sib = $foo->sibling("baz", "bam.txt"); # /tmp/baz/bam.txt

  Returns a new C<Path::Tiny> object relative to the parent of the original.
  This is slightly more efficient than C<< $path->parent->child(...) >>.

  Current API available since 0.058.

  =head2 size, size_human

      my $p = path("foo"); # with size 1025 bytes

      $p->size;                            # "1025"
      $p->size_human;                      # "1.1 K"
      $p->size_human( {format => "iec"} ); # "1.1 KiB"

  Returns the size of a file.  The C<size> method is just a wrapper around C<-s>.

  The C<size_human> method provides a human-readable string similar to
  C<ls -lh>.  Like C<ls>, it rounds upwards and provides one decimal place for
  single-digit sizes and no decimal places for larger sizes.  The only available
  option is C<format>, which has three valid values:

  =over 4

  =item *

  'ls' (the default): base-2 sizes, with C<ls> style single-letter suffixes (K, M, etc.)

  =item *

  'iec': base-2 sizes, with IEC binary suffixes (KiB, MiB, etc.)

  =item *

  'si': base-10 sizes, with SI decimal suffixes (kB, MB, etc.)

  =back

  If C<-s> would return C<undef>, C<size_human> returns the empty string.

  Current API available since 0.122.

  =head2 slurp, slurp_raw, slurp_utf8

      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;

  Reads file contents into a scalar.  Takes an optional hash reference which may
  be used to pass options.  The only available option is C<binmode>, which is
  passed to C<binmode()> on the handle used for reading.

  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.

  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)> (or C<:unix:utf8_strict> with
  L<PerlIO::utf8_strict>).  If L<Unicode::UTF8> 0.58+ is installed, a
  unbuffered, raw slurp will be done instead and the result decoded with
  C<Unicode::UTF8>. This is just as strict and is roughly an order of
  magnitude faster than using C<:encoding(UTF-8)>.

  B<Note>: C<slurp> and friends lock the filehandle before slurping.  If
  you plan to slurp from a file created with L<File::Temp>, be sure to
  close other handles or open without locking to avoid a deadlock:

      my $tempfile = File::Temp->new(EXLOCK => 0);
      my $guts = path($tempfile)->slurp;

  Current API available since 0.004.

  =head2 spew, spew_raw, spew_utf8

      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);

  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.

  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.

  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>
  (or C<:unix:utf8_strict> with L<PerlIO::utf8_strict>).  If L<Unicode::UTF8>
  0.58+ is installed, a raw, unbuffered spew will be done instead on the data
  encoded with C<Unicode::UTF8>.

  B<NOTE>: because the file is written to a temporary file and then renamed, the
  new file will wind up with permissions based on your current umask.  This is a
  feature to protect you from a race condition that would otherwise give
  different permissions than you might expect.  If you really want to keep the
  original mode flags, use L</append> with the C<truncate> option.

  Current API available since 0.011.

  =head2 stat, lstat

      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;

  Like calling C<stat> or C<lstat> from L<File::stat>.

  Current API available since 0.001.

  =head2 stringify

      $path = path("foo.txt");
      say $path->stringify; # same as "$path"

  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.

  Current API available since 0.001.

  =head2 subsumes

      path("foo/bar")->subsumes("foo/bar/baz"); # true
      path("/foo/bar")->subsumes("/foo/baz");   # false

  Returns true if the first path is a prefix of the second path at a directory
  boundary.

  This B<does not> resolve parent directory entries (C<..>) or symlinks:

      path("foo/bar")->subsumes("foo/bar/../baz"); # true

  If such things are important to you, ensure that both paths are resolved to
  the filesystem with C<realpath>:

      my $p1 = path("foo/bar")->realpath;
      my $p2 = path("foo/bar/../baz")->realpath;
      if ( $p1->subsumes($p2) ) { ... }

  Current API available since 0.048.

  =head2 touch

      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);

  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.

  Returns the path object so it can be easily chained with other methods:

      # won't die if foo.txt doesn't exist
      $content = path("foo.txt")->touch->slurp;

  Current API available since 0.015.

  =head2 touchpath

      path("bar/baz/foo.txt")->touchpath;

  Combines C<mkdir> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.

  If you need to pass options, use C<mkdir> and C<touch> separately:

      path("bar/baz")->mkdir( \%options )->child("foo.txt")->touch($epoch_secs);

  Current API available since 0.022.

  =head2 visit

      path("/tmp")->visit( \&callback, \%options );

  Executes a callback for each child of a directory.  It returns a hash
  reference with any state accumulated during iteration.

  The options are the same as for L</iterator> (which it uses internally):
  C<recurse> and C<follow_symlinks>.  Both default to false.

  The callback function will receive a C<Path::Tiny> object as the first argument
  and a hash reference to accumulate state as the second argument.  For example:

      # collect files sizes
      my $sizes = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              return if $path->is_dir;
              $state->{$path} = -s $path;
          },
          { recurse => 1 }
      );

  For convenience, the C<Path::Tiny> object will also be locally aliased as the
  C<$_> global variable:

      # print paths matching /foo/
      path("/tmp")->visit( sub { say if /foo/ }, { recurse => 1} );

  If the callback returns a B<reference> to a false scalar value, iteration will
  terminate.  This is not the same as "pruning" a directory search; this just
  stops all iteration and returns the state hash reference.

      # find up to 10 files larger than 100K
      my $files = path("/tmp")->visit(
          sub {
              my ($path, $state) = @_;
              $state->{$path}++ if -s $path > 102400
              return \0 if keys %$state == 10;
          },
          { recurse => 1 }
      );

  If you want more flexible iteration, use a module like L<Path::Iterator::Rule>.

  Current API available since 0.062.

  =head2 volume

      $vol = path("/tmp/foo.txt")->volume;   # ""
      $vol = path("C:/tmp/foo.txt")->volume; # "C:"

  Returns the volume portion of the path.  This is equivalent
  to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems or the
  drive letter for an absolute path on C<MSWin32>.

  Current API available since 0.001.

  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  IS_WIN32 FREEZE THAW TO_JSON abs2rel

  =head1 EXCEPTION HANDLING

  Simple usage errors will generally croak.  Failures of underlying Perl
  functions will be thrown as exceptions in the class
  C<Path::Tiny::Error>.

  A C<Path::Tiny::Error> object will be a hash reference with the following fields:

  =over 4

  =item *

  C<op> â a description of the operation, usually function call and any extra info

  =item *

  C<file> â the file or directory relating to the error

  =item *

  C<err> â hold C<$!> at the time the error was thrown

  =item *

  C<msg> â a string combining the above data and a Carp-like short stack trace

  =back

  Exception objects will stringify as the C<msg> field.

  =head1 ENVIRONMENT

  =head2 PERL_PATH_TINY_NO_FLOCK

  If the environment variable C<PERL_PATH_TINY_NO_FLOCK> is set to a true
  value then flock will NOT be used when accessing files (this is not
  recommended).

  =head1 CAVEATS

  =head2 Subclassing not supported

  For speed, this class is implemented as an array based object and uses many
  direct function calls internally.  You must not subclass it and expect
  things to work properly.

  =head2 Tilde expansion (deprecated)

  Tilde expansion was a nice idea, but it can't easily be applied consistently
  across the entire API.  This was a source of bugs and confusion for users.
  Therefore, it is B<deprecated> and its use is discouraged.  Limitations to the
  existing, legacy behavior follow.

  Tilde expansion will only occur if the B<first> argument to C<path> begins with
  a tilde. B<No other method does tilde expansion on its arguments>.  If you want
  tilde expansion on arguments, you must explicitly wrap them in a call to
  C<path>.

      path( "~/foo.txt" )->copy( path( "~/bar.txt" ) );

  If you need a literal leading tilde, use C<path("./~whatever")> so that the
  argument to C<path> doesn't start with a tilde, but the path still resolves to
  the current directory.

  Behaviour of tilde expansion with a username for non-existent users depends on
  the output of C<glob> on the system.

  =head2 File locking

  If flock is not supported on a platform, it will not be used, even if
  locking is requested.

  In situations where a platform normally would support locking, but the
  flock fails due to a filesystem limitation, Path::Tiny has some heuristics
  to detect this and will warn once and continue in an unsafe mode.  If you
  want this failure to be fatal, you can fatalize the 'flock' warnings
  category:

      use warnings FATAL => 'flock';

  See additional caveats below.

  =head3 NFS and BSD

  On BSD, Perl's flock implementation may not work to lock files on an
  NFS filesystem.  If detected, this situation will warn once, as described
  above.

  =head3 Lustre

  The Lustre filesystem does not support flock.  If detected, this situation
  will warn once, as described above.

  =head3 AIX and locking

  AIX requires a write handle for locking.  Therefore, calls that normally
  open a read handle and take a shared lock instead will open a read-write
  handle and take an exclusive lock.  If the user does not have write
  permission, no lock will be used.

  =head2 utf8 vs UTF-8

  All the C<*_utf8> methods by default use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered, for whole file operations) or
  C<:raw:encoding(UTF-8)> (buffered, for line-by-line operations). These are
  strict against the Unicode spec and disallows illegal Unicode codepoints or
  UTF-8 sequences.

  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.  Alternatively, if you install L<PerlIO::utf8_strict>,
  that will be used instead of C<:encoding(UTF-8)> and is also very fast.

  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).

  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:

    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF

  =head2 Default IO layers and the open pragma

  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<filehandle>, C<openr>,
  C<openw>, etc. ) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8> or
  L<PerlIP::utf8_strict>.

  =head1 TYPE CONSTRAINTS AND COERCION

  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.  A L<Type::Tiny> equivalent is available as
  L<Types::Path::Tiny>.

  =head1 SEE ALSO

  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.

  =over 4

  =item *

  L<File::chmod>

  =item *

  L<File::Fu>

  =item *

  L<IO::All>

  =item *

  L<Path::Class>

  =back

  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:

  =over 4

  =item *

  L<Path::Iterator::Rule>

  =item *

  L<File::Next>

  =back

  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.

  This module was featured in the L<2013 Perl Advent Calendar|http://www.perladvent.org/2013/2013-12-18.html>.

  =for :stopwords cpan testmatrix url bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan

  =head1 SUPPORT

  =head2 Bugs / Feature Requests

  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/Path-Tiny/issues>.
  You will be notified automatically of any progress on your issue.

  =head2 Source Code

  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.

  L<https://github.com/dagolden/Path-Tiny>

    git clone https://github.com/dagolden/Path-Tiny.git

  =head1 AUTHOR

  David Golden <dagolden@cpan.org>

  =head1 CONTRIBUTORS

  =for stopwords Alex Efros Aristotle Pagaltzis Chris Williams Dan Book Dave Rolsky David Steinbrunner Doug Bell Elvin Aslanov Flavio Poletti Gabor Szabo Gabriel Andrade George Hartzell Geraud Continsouzas Goro Fuji Graham Knop Ollis Ian Sillitoe James Hunt John Karr Karen Etheridge Mark Ellis Martin H. Sluka Kjeldsen Mary Ehlers Michael G. Schwern Nicolas R Rochelemagne Nigel Gregoire Philippe Bruhat (BooK) regina-verbae Roy Ivy III Shlomi Fish Smylers Tatsuhiko Miyagawa Toby Inkster Yanick Champoux ê¹ëí - Keedi Kim

  =over 4

  =item *

  Alex Efros <powerman@powerman.name>

  =item *

  Aristotle Pagaltzis <pagaltzis@gmx.de>

  =item *

  Chris Williams <bingos@cpan.org>

  =item *

  Dan Book <grinnz@grinnz.com>

  =item *

  Dave Rolsky <autarch@urth.org>

  =item *

  David Steinbrunner <dsteinbrunner@pobox.com>

  =item *

  Doug Bell <madcityzen@gmail.com>

  =item *

  Elvin Aslanov <rwp.primary@gmail.com>

  =item *

  Flavio Poletti <flavio@polettix.it>

  =item *

  Gabor Szabo <szabgab@cpan.org>

  =item *

  Gabriel Andrade <gabiruh@gmail.com>

  =item *

  George Hartzell <hartzell@cpan.org>

  =item *

  Geraud Continsouzas <geraud@scsi.nc>

  =item *

  Goro Fuji <gfuji@cpan.org>

  =item *

  Graham Knop <haarg@haarg.org>

  =item *

  Graham Ollis <plicease@cpan.org>

  =item *

  Ian Sillitoe <ian@sillit.com>

  =item *

  James Hunt <james@niftylogic.com>

  =item *

  John Karr <brainbuz@brainbuz.org>

  =item *

  Karen Etheridge <ether@cpan.org>

  =item *

  Mark Ellis <mark.ellis@cartridgesave.co.uk>

  =item *

  Martin H. Sluka <fany@cpan.org>

  =item *

  Martin Kjeldsen <mk@bluepipe.dk>

  =item *

  Mary Ehlers <regina.verb.ae@gmail.com>

  =item *

  Michael G. Schwern <mschwern@cpan.org>

  =item *

  Nicolas R <nicolas@atoomic.org>

  =item *

  Nicolas Rochelemagne <rochelemagne@cpanel.net>

  =item *

  Nigel Gregoire <nigelgregoire@gmail.com>

  =item *

  Philippe Bruhat (BooK) <book@cpan.org>

  =item *

  regina-verbae <regina-verbae@users.noreply.github.com>

  =item *

  Roy Ivy III <rivy@cpan.org>

  =item *

  Shlomi Fish <shlomif@shlomifish.org>

  =item *

  Smylers <Smylers@stripey.com>

  =item *

  Tatsuhiko Miyagawa <miyagawa@bulknews.net>

  =item *

  Toby Inkster <tobyink@cpan.org>

  =item *

  Yanick Champoux <yanick@babyl.dyndns.org>

  =item *

  ê¹ëí - Keedi Kim <keedi@cpan.org>

  =back

  =head1 COPYRIGHT AND LICENSE

  This software is Copyright (c) 2014 by David Golden.

  This is free software, licensed under:

    The Apache License, Version 2.0, January 2004

  =cut
PATH_TINY

$fatpacked{"TOML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML';
  package TOML;

  # -------------------------------------------------------------------
  # TOML - Parser for Tom's Obvious, Minimal Language.
  #
  # Copyright (C) 2013 Darren Chamberlain <darren@cpan.org>
  # -------------------------------------------------------------------

  use 5.008005;
  use strict;
  use warnings;
  use Exporter 'import';

  our ($VERSION, @EXPORT, @_NAMESPACE, $PARSER);

  use B;
  use Carp qw(croak);
  use TOML::Parser 0.03;

  $VERSION = "0.97";
  @EXPORT = qw(from_toml to_toml);
  $PARSER = TOML::Parser->new(inflate_boolean  => sub { $_[0] });

  sub to_toml {
      my $stuff = shift;
      local @_NAMESPACE = ();
      _to_toml($stuff);
  }

  sub _to_toml {
      my ($stuff) = @_;

      if (ref $stuff eq 'HASH') {
          my $res = '';
          my @keys = sort keys %$stuff;
          for my $key (grep { ref $stuff->{$_} ne 'HASH' } @keys) {
              my $val = $stuff->{$key};
              $res .= "$key = " . _serialize($val) . "\n";
          }
          for my $key (grep { ref $stuff->{$_} eq 'HASH' } @keys) {
              my $val = $stuff->{$key};
              local @_NAMESPACE = (@_NAMESPACE, $key);
              $res .= sprintf("[%s]\n", join(".", @_NAMESPACE));
              $res .= _to_toml($val);
          }
          return $res;
      } else {
          croak("You cannot convert non-HashRef values to TOML");
      }
  }

  sub _serialize {
      my $value = shift;
      my $b_obj = B::svref_2object(\$value);
      my $flags = $b_obj->FLAGS;

      return $value
          if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?

      my $type = ref($value);
      if (!$type) {
          return string_to_json($value);
      } elsif ($type eq 'ARRAY') {
          return sprintf('[%s]', join(", ", map { _serialize($_) } @$value));
      } elsif ($type eq 'SCALAR') {
          if (defined $$value) {
              if ($$value eq '0') {
                  return 'false';
              } elsif ($$value eq '1') {
                  return 'true';
              } else {
                  croak("cannot encode reference to scalar");
              }
          }
          croak("cannot encode reference to scalar");
      }
      croak("Bad type in to_toml: $type");
  }

  my %esc = (
      "\n" => '\n',
      "\r" => '\r',
      "\t" => '\t',
      "\f" => '\f',
      "\b" => '\b',
      "\"" => '\"',
      "\\" => '\\\\',
      "\'" => '\\\'',
  );
  sub string_to_json {
      my ($arg) = @_;

      $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
      $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;

      return '"' . $arg . '"';
  }

  sub from_toml {
      my $string = shift;
      local $@;
      my $toml = eval { $PARSER->parse($string) };
      return wantarray ? ($toml, $@) : $toml;
  }

  1;

  __END__

  =encoding utf-8

  =for stopwords versa

  =head1 NAME

  TOML - Parser for Tom's Obvious, Minimal Language.

  =head1 SYNOPSIS

      use TOML qw(from_toml to_toml);

      # Parsing toml
      my $toml = slurp("~/.foo.toml");
      my $data = from_toml($toml);

      # With error checking
      my ($data, $err) = from_toml($toml);
      unless ($data) {
          die "Error parsing toml: $err";
      }

      # Creating toml
      my $toml = to_toml($data);

  =head1 DESCRIPTION

  C<TOML> implements a parser for Tom's Obvious, Minimal Language, as
  defined at L<https://github.com/mojombo/toml>. C<TOML> exports two
  subroutines, C<from_toml> and C<to_toml>,

  =head1 FAQ

  =over 4

  =item How change how to de-serialize?

  You can change C<$TOML::PARSER> for change how to de-serialize.

  example:

      use TOML;
      use TOML::Parser;

      local $TOML::PARSER = TOML::Parser->new(
          inflate_boolean => sub { $_[0] eq 'true' ? \1 : \0 },
      );

      my $data = TOML::from_toml('foo = true');

  =back

  =head1 FUNCTIONS

  =over 4

  =item from_toml

  C<from_toml> transforms a string containing toml to a perl data
  structure or vice versa. This data structure complies with the tests
  provided at L<https://github.com/mojombo/toml/tree/master/tests>.

  If called in list context, C<from_toml> produces a (C<hash>,
  C<error_string>) tuple, where C<error_string> is C<undef> on
  non-errors. If there is an error, then C<hash> will be undefined and
  C<error_string> will contains (scant) details about said error.

  =item to_toml

  C<to_toml> transforms a perl data structure into toml-formatted
  string.

  =back

  =head1 SEE ALSO

  L<TOML::Parser>

  =head1 LICENSE

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License as
  published by the Free Software Foundation; version 2.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  02111-1301 USA

  =head1 AUTHOR

  Darren Chamberlain <darren@cpan.org>

  =head1 CONTRIBUTORS

  =over 4

  =item Tokuhiro Matsuno <tokuhirom@cpan.org>

  =item Matthias Bethke <matthias@towiski.de>

  =item Sergey Romanov <complefor@rambler.ru>

  =item karupanerura <karupa@cpan.org>

  =back
TOML

$fatpacked{"TOML/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER';
  package TOML::Parser;
  use 5.010000;
  use strict;
  use warnings;
  use Encode;

  our $VERSION = "0.91";

  use TOML::Parser::Tokenizer qw/:constant/;
  use TOML::Parser::Tokenizer::Strict;
  use TOML::Parser::Util qw/unescape_str/;
  use Types::Serialiser;

  sub new {
      my $class = shift;
      my $args  = (@_ == 1 and ref $_[0] eq 'HASH') ? +shift : +{ @_ };
      return bless +{
          inflate_datetime => sub { $_[0] },
          inflate_boolean  => sub { $_[0] eq 'true' ? Types::Serialiser::true : Types::Serialiser::false },
          strict_mode      => 0,
          %$args,
      } => $class;
  }

  sub parse_file {
      my ($self, $file) = @_;
      open my $fh, '<:encoding(utf-8)', $file or die $!;
      return $self->parse_fh($fh);
  }

  sub parse_fh {
      my ($self, $fh) = @_;
      my $src = do { local $/; <$fh> };
      return $self->parse($src);
  }

  sub _tokenizer_class {
      my $self = shift;
      return $self->{strict_mode} ? 'TOML::Parser::Tokenizer::Strict' : 'TOML::Parser::Tokenizer';
  }

  our @TOKENS;
  our $ROOT;
  our $CONTEXT;
  sub parse {
      my ($self, $src) = @_;

      local $ROOT    = {};
      local $CONTEXT = $ROOT;
      local @TOKENS  = $self->_tokenizer_class->tokenize($src);
      while (my $token = shift @TOKENS) {
          $self->_parse_token($token);
      }
      return $ROOT;
  }

  sub _parse_token {
      my ($self, $token) = @_;

      my ($type, $val) = @$token;
      if ($type eq TOKEN_TABLE) {
          $self->_parse_table($val);
      }
      elsif ($type eq TOKEN_ARRAY_OF_TABLE) {
          $self->_parse_array_of_table($val);
      }
      elsif (my ($key, $value) = $self->_parse_key_and_value($token)) {
          die "Duplicate key. key:$key" if exists $CONTEXT->{$key};
          $CONTEXT->{$key} = $value;
      }
      elsif ($type eq TOKEN_COMMENT) {
          # pass through
      }
      else {
          die "Unknown case. type:$type";
      }
  }

  sub _parse_key_and_value {
      my ($self, $token) = @_;

      my ($type, $val) = @$token;
      if ($type eq TOKEN_KEY) {
          my $token = shift @TOKENS;

          my $key = $val;
          my $value = $self->_parse_value_token($token);
          return ($key, $value);
      }

      return;
  }

  sub _parse_table {
      my ($self, $keys) = @_;
      my @keys = @$keys;

      $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Table`";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }
  }

  sub _parse_array_of_table {
      my ($self, $keys) = @_;
      my @keys     = @$keys;
      my $last_key = pop @keys;

      $CONTEXT = $ROOT;
      for my $k (@keys) {
          if (exists $CONTEXT->{$k}) {
              $CONTEXT = ref $CONTEXT->{$k} eq 'ARRAY' ? $CONTEXT->{$k}->[-1] :
                         ref $CONTEXT->{$k} eq 'HASH'  ? $CONTEXT->{$k}       :
                         die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`.";
          }
          else {
              $CONTEXT = $CONTEXT->{$k} ||= +{};
          }
      }

      $CONTEXT->{$last_key} = [] unless exists $CONTEXT->{$last_key};
      die "invalid structure. @{[ join '.', @keys ]} cannot be `Array of table`" unless ref $CONTEXT->{$last_key} eq 'ARRAY';
      push @{ $CONTEXT->{$last_key} } => $CONTEXT = {};
  }

  sub _parse_value_token {
      my $self  = shift;
      my $token = shift;

      my ($type, $val, @args) = @$token;
      if ($type eq TOKEN_COMMENT) {
          return; # pass through
      }
      elsif ($type eq TOKEN_INTEGER || $type eq TOKEN_FLOAT) {
          $val =~ tr/_//d;
          return 0+$val;
      }
      elsif ($type eq TOKEN_BOOLEAN) {
          return $self->inflate_boolean($val);
      }
      elsif ($type eq TOKEN_DATETIME) {
          return $self->inflate_datetime($val);
      }
      elsif ($type eq TOKEN_STRING) {
          my ($is_raw) = @args;
          return $is_raw ? $val : unescape_str($val);
      }
      elsif ($type eq TOKEN_MULTI_LINE_STRING_BEGIN) {
          my ($is_raw) = @args;
          my $value = $self->_parse_value_token(shift @TOKENS);
          $value =~ s/\A(?:\r\n|[\r\n])//msg;
          $value =~ s/\\\s+//msg;
          if (my $token = shift @TOKENS) {
              my ($type) = @$token;
              return $value if $type eq TOKEN_MULTI_LINE_STRING_END;
              die "Unexpected token: $type";
          }
      }
      elsif ($type eq TOKEN_INLINE_TABLE_BEGIN) {
          my %data;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_INLINE_TABLE_END;
              next if $token->[0] eq TOKEN_COMMENT;
              my ($key, $value) = $self->_parse_key_and_value($token);
              die "Duplicate key. key:$key" if exists $data{$key};
              $data{$key} = $value;
          }
          return \%data;
      }
      elsif ($type eq TOKEN_ARRAY_BEGIN) {
          my @data;

          my $last_token;
          while (my $token = shift @TOKENS) {
              last if $token->[0] eq TOKEN_ARRAY_END;
              next if $token->[0] eq TOKEN_COMMENT;
              if ($self->{strict_mode}) {
                  die "Unexpected token: $token->[0]" if defined $last_token && $token->[0] ne $last_token->[0];
              }
              push @data => $self->_parse_value_token($token);
              $last_token = $token;
          }
          return \@data;
      }

      die "Unexpected token: $type";
  }

  sub inflate_datetime {
      my $self = shift;
      return $self->{inflate_datetime}->(@_);
  }

  sub inflate_boolean {
      my $self = shift;
      return $self->{inflate_boolean}->(@_);
  }

  1;
  __END__

  =encoding utf-8

  =for stopwords versa

  =head1 NAME

  TOML::Parser - simple toml parser

  =head1 SYNOPSIS

      use TOML::Parser;

      my $parser = TOML::Parser->new;
      my $data   = $parser->parse($toml);

  =head1 DESCRIPTION

  TOML::Parser is a simple toml parser.

  This data structure complies with the tests
  provided at L<https://github.com/toml-lang/toml/tree/v0.4.0/tests>.

  The v0.4.0 specification is supported.

  =head1 METHODS

  =over

  =item my $parser = TOML::Parser->new(\%args)

  Creates a new TOML::Parser instance.

      use TOML::Parser;

      # create new parser
      my $parser = TOML::Parser->new();

  Arguments can be:

  =over

  =item * C<inflate_datetime>

  If use it, You can replace inflate C<datetime> process.
  The subroutine of default is C<identity>. C<e.g.) sub { $_[0] }>

      use TOML::Parser;
      use DateTime;
      use DateTime::Format::ISO8601;

      # create new parser
      my $parser = TOML::Parser->new(
          inflate_datetime => sub {
              my $dt = shift;
              return DateTime::Format::ISO8601->parse_datetime($dt);
          },
      );

  =item * C<inflate_boolean>

  If use it, You can replace inflate boolean process.
  The return value of default subroutine is C<Types::Serialiser::true> or C<Types::Serialiser::false>.

      use TOML::Parser;

      # create new parser
      my $parser = TOML::Parser->new(
          inflate_boolean => sub {
              my $boolean = shift;
              return $boolean eq 'true' ? 1 : 0;
          },
      );

  =item * C<strict_mode>

  TOML::Parser is using a more flexible rule for compatibility with old TOML of default.
  If make this option true value, You can parse a toml with strict rule.

      use TOML::Parser;

      # create new parser
      my $parser = TOML::Parser->new(
          strict_mode => 1
      );

  =back

  =item my $data = $parser->parse_file($path)

  =item my $data = $parser->parse_fh($fh)

  =item my $data = $parser->parse($src)

  Transforms a string containing toml to a perl data structure or vice versa.

  =back

  =head1 SEE ALSO

  L<TOML>

  =head1 LICENSE

  Copyright (C) karupanerura.

  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.

  =head1 AUTHOR

  karupanerura E<lt>karupa@cpan.orgE<gt>

  =head1 CONTRIBUTOR

  Olivier MenguÃ© E<lt>dolmen@cpan.orgE<gt>
  yowcow E<lt>yowcow@cpan.orgE<gt>
  Syohei YOSHIDA E<lt>syohex@gmail.comE<gt>

  =cut
TOML_PARSER

$fatpacked{"TOML/Parser/Tokenizer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER';
  package TOML::Parser::Tokenizer;
  use 5.010000;
  use strict;
  use warnings;

  use Exporter 5.57 'import';

  use constant DEBUG => $ENV{TOML_PARSER_TOKENIZER_DEBUG} ? 1 : 0;

  BEGIN {
      my @TOKENS = map uc, qw/
          comment
          table
          array_of_table
          key
          integer
          float
          boolean
          datetime
          string
          multi_line_string_begin
          multi_line_string_end
          inline_table_begin
          inline_table_end
          array_begin
          array_end
      /;
      my %CONSTANTS = map {
          ("TOKEN_$_" => $_)
      } @TOKENS;

      require constant;
      constant->import(\%CONSTANTS);

      # Exporter
      our @EXPORT_OK   = keys %CONSTANTS;
      our %EXPORT_TAGS = (
          constant => [keys %CONSTANTS],
      );
  };

  sub grammar_regexp {
      return +{
          comment        => qr{#(.*)},
          table          => {
              start => qr{\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]},
          },
          array_of_table => {
              start => qr{\[\[},
              key   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^.\s\\\]]+))},
              sep   => qr{\.},
              end   => qr{\]\]},
          },
          key            => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\'|([^\s=]+))\s*=},
          value          => {
              datetime => qr{([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.[0-9]+)?(?:Z|[-+][0-9]{2}:[0-9]{2}))},
              float    => qr{([-+]?(?:[0-9_]+(?:\.[0-9_]+)?[eE][-+]?[0-9_]+|[0-9_]*\.[0-9_]+))},
              integer  => qr{([-+]?[0-9_]+)},
              boolean  => qr{(true|false)},
              string   => qr{(?:"(.*?)(?<!(?<!\\)\\)"|\'(.*?)(?<!(?<!\\)\\)\')},
              mlstring => qr{("""|''')},
              inline   => {
                  start => qr{\{},
                  sep   => qr{\s*,\s*},
                  end   => qr{\}},
              },
              array    => {
                  start => qr{\[},
                  sep   => qr{\s*,\s*},
                  end   => qr{\]},
              },
          },
      };
  }

  sub tokenize {
      my ($class, $src) = @_;

      local $_ = $src;
      return $class->_tokenize();
  }

  sub _tokenize {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();

      my @tokens;
      until (/\G\z/mgco) {
          if (/\G$grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              $class->_skip_whitespace();
              push @tokens => [TOKEN_COMMENT, $1 || ''];
          }
          elsif (/\G$grammar_regexp->{array_of_table}->{start}/mgc) {
              push @tokens => $class->_tokenize_array_of_table();
          }
          elsif (/\G$grammar_regexp->{table}->{start}/mgc) {
              push @tokens => $class->_tokenize_table();
          }
          elsif (my @t = $class->_tokenize_key_and_value()) {
              push @tokens => @t;
          }
          elsif (/\G\s+/mgco) {
              # pass through
              $class->_skip_whitespace();
          }
          else {
              $class->_syntax_error();
          }
      }
      return @tokens;
  }

  sub _tokenize_key_and_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();

      my @tokens;
      if (/\G$grammar_regexp->{key}/mgc) {
          my $key = $1 || $2 || $3;
          warn "[TOKEN] KEY: $key" if DEBUG;
          $class->_skip_whitespace();
          push @tokens => [TOKEN_KEY, $key];
          push @tokens => $class->_tokenize_value();
          return @tokens;
      }

      return;
  }

  sub _tokenize_value {
      my $class = shift;
      my $grammar_regexp = $class->grammar_regexp();
      warn "[CALL] _tokenize_value" if DEBUG;

      if (/\G$grammar_regexp->{comment}/mgc) {
          warn "[TOKEN] COMMENT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_COMMENT, $1 || ''];
      }
      elsif (/\G$grammar_regexp->{value}->{datetime}/mgc) {
          warn "[TOKEN] DATETIME: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_DATETIME, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{float}/mgc) {
          warn "[TOKEN] FLOAT: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_FLOAT, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{integer}/mgc) {
          warn "[TOKEN] INTEGER: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_INTEGER, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{boolean}/mgc) {
          warn "[TOKEN] BOOLEAN: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_BOOLEAN, $1];
      }
      elsif (/\G$grammar_regexp->{value}->{mlstring}/mgc) {
          warn "[TOKEN] MULTI LINE STRING: $1" if DEBUG;
          return (
              [TOKEN_MULTI_LINE_STRING_BEGIN],
              $class->_extract_multi_line_string($1),
              [TOKEN_MULTI_LINE_STRING_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{string}/mgc) {
          warn "[TOKEN] STRING: $1" if DEBUG;
          $class->_skip_whitespace();

          my $is_raw = defined $2;
          return [TOKEN_STRING, defined $1 ? $1 : defined $2 ? $2 : '', $is_raw];
      }
      elsif (/\G$grammar_regexp->{value}->{inline}->{start}/mgc) {
          warn "[TOKEN] INLINE TABLE" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_INLINE_TABLE_BEGIN],
              $class->_tokenize_inline_table(),
              [TOKEN_INLINE_TABLE_END],
          );
      }
      elsif (/\G$grammar_regexp->{value}->{array}->{start}/mgc) {
          warn "[TOKEN] ARRAY" if DEBUG;
          $class->_skip_whitespace();
          return (
              [TOKEN_ARRAY_BEGIN],
              $class->_tokenize_array(),
              [TOKEN_ARRAY_END],
          );
      }

      $class->_syntax_error();
  }

  sub _tokenize_table {
      my $class = shift;

      my $grammar_regexp = $class->grammar_regexp()->{table};
      warn "[CALL] _tokenize_table" if DEBUG;

      $class->_skip_whitespace();

      my @expected = ($grammar_regexp->{key});

      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }

          $class->_syntax_error();
      }

      warn "[TOKEN] TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_TABLE, \@keys];
  }

  sub _tokenize_array_of_table {
      my $class = shift;

      my $grammar_regexp = $class->grammar_regexp()->{array_of_table};
      warn "[CALL] _tokenize_array_of_table" if DEBUG;

      $class->_skip_whitespace();

      my @expected = ($grammar_regexp->{key});

      my @keys;
   LOOP:
      while (1) {
          for my $rx (@expected) {
              if (/\G$rx/smgc) {
                  if ($rx eq $grammar_regexp->{key}) {
                      my $key = $1 || $2 || $3;
                      warn "[TOKEN] table key: $key" if DEBUG;
                      push @keys => $key;
                      @expected = ($grammar_regexp->{sep}, $grammar_regexp->{end});
                  }
                  elsif ($rx eq $grammar_regexp->{sep}) {
                      warn "[TOKEN] table key separator" if DEBUG;
                      @expected = ($grammar_regexp->{key});
                  }
                  elsif ($rx eq $grammar_regexp->{end}) {
                      warn "[TOKEN] table key end" if DEBUG;
                      @expected = ();
                      last LOOP;
                  }
                  $class->_skip_whitespace();
                  next LOOP;
              }
          }

          $class->_syntax_error();
      }

      warn "[TOKEN] ARRAY_OF_TABLE: @{[ join '.', @keys ]}" if DEBUG;
      return [TOKEN_ARRAY_OF_TABLE, \@keys];
  }

  sub _extract_multi_line_string {
      my ($class, $delimiter) = @_;
      my $is_raw = $delimiter eq q{'''};
      if (/\G(.+?)\Q$delimiter/smgc) {
          warn "[TOKEN] MULTI LINE STRING: $1" if DEBUG;
          $class->_skip_whitespace();
          return [TOKEN_STRING, $1, $is_raw];
      }
      $class->_syntax_error();
  }

  sub _tokenize_inline_table {
      my $class = shift;

      my $common_grammar_regexp = $class->grammar_regexp();
      my $grammar_regexp = $common_grammar_regexp->{value}->{inline};

      warn "[CALL] _tokenize_inline_table" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;

      my $need_sep = 0;

      my @tokens;
      while (1) {
          warn "[CONTEXT] _tokenize_inline_table [loop]" if DEBUG;

          $class->_skip_whitespace();
          if (/\G$common_grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              push @tokens => [TOKEN_COMMENT, $1 || ''];
              next;
          }
          elsif (/\G$grammar_regexp->{end}/mgc) {
              last;
          }

          if ($need_sep) {
              if (/\G$grammar_regexp->{sep}/smgc) {
                  $need_sep = 0;
                  next;
              }
          }
          else {
              if (my @t = $class->_tokenize_key_and_value()) {
                  push @tokens => @t;
                  $need_sep = 1;
                  next;
              }
          }

          $class->_syntax_error();
      }

      return @tokens;
  }

  sub _tokenize_array {
      my $class = shift;

      my $common_grammar_regexp = $class->grammar_regexp();
      my $grammar_regexp = $common_grammar_regexp->{value}->{array};

      warn "[CALL] _tokenize_array" if DEBUG;
      return if /\G(?:$grammar_regexp->{sep})?$grammar_regexp->{end}/smgc;

      my $need_sep = 0;

      my @tokens;
      while (1) {
          warn "[CONTEXT] _tokenize_inline_table [loop]" if DEBUG;

          $class->_skip_whitespace();
          if (/\G$common_grammar_regexp->{comment}/mgc) {
              warn "[TOKEN] COMMENT: $1" if DEBUG;
              push @tokens => [TOKEN_COMMENT, $1 || ''];
              next;
          }
          elsif (/\G$grammar_regexp->{end}/mgc) {
              last;
          }

          if ($need_sep) {
              if (/\G$grammar_regexp->{sep}/smgc) {
                  $need_sep = 0;
                  next;
              }
          }
          else {
              if (my @t = $class->_tokenize_value()) {
                  push @tokens => @t;
                  $need_sep = 1;
                  next;
              }
          }

          $class->_syntax_error();
      }

      return @tokens;
  }

  sub _skip_whitespace {
      my $class = shift;
      if (/\G\s+/smgco) {
          # pass through
          warn "[PASS] WHITESPACE" if DEBUG;
      }
  }

  sub _syntax_error { shift->_error('Syntax Error') }

  sub _error {
      my ($class, $msg) = @_;

      my $src   = $_;
      my $curr  = pos || 0;
      my $line  = 1;
      my $start = pos $src || 0;
      while ($src =~ /$/smgco and pos $src <= $curr) {
          $start = pos $src;
          $line++;
      }
      my $end = pos $src;
      my $len = $curr - $start;
      $len-- if $len > 0;

      my $trace = join "\n",
          "${msg}: line:$line",
          substr($src, $start || 0, $end - $start),
          (' ' x $len) . '^';
      die $trace, "\n";
  }

  1;
  __END__
TOML_PARSER_TOKENIZER

$fatpacked{"TOML/Parser/Tokenizer/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_TOKENIZER_STRICT';
  package TOML::Parser::Tokenizer::Strict;
  use 5.010000;
  use strict;
  use warnings;

  use parent qw/TOML::Parser::Tokenizer/;
  BEGIN { import TOML::Parser::Tokenizer qw/:constant/ }

  sub grammar_regexp {
      my $grammar_regexp = {%{ shift->SUPER::grammar_regexp() }};
      $grammar_regexp->{table}                 = {%{ $grammar_regexp->{table} }};
      $grammar_regexp->{array_of_table}        = {%{ $grammar_regexp->{array_of_table} }};
      $grammar_regexp->{table}->{key}          = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{array_of_table}->{key} = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))};
      $grammar_regexp->{key}                   = qr{(?:"(.*?)(?<!(?<!\\)\\)"|([A-Za-z0-9_-]+))\s*=};
      return $grammar_regexp;
  }

  1;
  __END__
TOML_PARSER_TOKENIZER_STRICT

$fatpacked{"TOML/Parser/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TOML_PARSER_UTIL';
  package TOML::Parser::Util;
  use 5.008005;
  use strict;
  use warnings;

  use Exporter 5.57 'import';
  our @EXPORT_OK = qw/unescape_str/;

  sub unescape_str {
      my $str = shift;

      $str =~ s!\\b !\x08!xmgo;      # backspace       (U+0008)
      $str =~ s!\\t !\x09!xmgo;      # tab             (U+0009)
      $str =~ s!\\n !\x0A!xmgo;      # linefeed        (U+000A)
      $str =~ s!\\f !\x0C!xmgo;      # form feed       (U+000C)
      $str =~ s!\\r !\x0D!xmgo;      # carriage return (U+000D)
      $str =~ s!\\" !\x22!xmgo;      # quote           (U+0022)
      $str =~ s!\\/ !\x2F!xmgo;      # slash           (U+002F)
      $str =~ s!\\\\!\x5C!xmgo;      # backslash       (U+005C)
      $str =~ s{\\u([0-9A-Fa-f]{4})}{# unicode         (U+XXXX)
          chr hex $1
      }xmgeo;
      $str =~ s{\\U([0-9A-Fa-f]{8})}{# unicode         (U+XXXXXXXX)
          chr hex $1
      }xmgeo;

      return $str;
  }

  1;
  __END__
TOML_PARSER_UTIL

$fatpacked{"Types/Serialiser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER';
  =head1 NAME

  Types::Serialiser - simple data types for common serialisation formats

  =encoding utf-8

  =head1 SYNOPSIS

  =head1 DESCRIPTION

  This module provides some extra datatypes that are used by common
  serialisation formats such as JSON or CBOR. The idea is to have a
  repository of simple/small constants and containers that can be shared by
  different implementations so they become interoperable between each other.

  =cut

  package Types::Serialiser;

  use common::sense; # required to suppress annoying warnings

  our $VERSION = '1.01';

  =head1 SIMPLE SCALAR CONSTANTS

  Simple scalar constants are values that are overloaded to act like simple
  Perl values, but have (class) type to differentiate them from normal Perl
  scalars. This is necessary because these have different representations in
  the serialisation formats.

  In the following, functions with zero or one arguments have a prototype of
  C<()> and C<($)>, respectively, so act as constants and unary operators.

  =head2 BOOLEANS (Types::Serialiser::Boolean class)

  This type has only two instances, true and false. A natural representation
  for these in Perl is C<1> and C<0>, but serialisation formats need to be
  able to differentiate between them and mere numbers.

  =over 4

  =item $Types::Serialiser::true, Types::Serialiser::true

  This value represents the "true" value. In most contexts is acts like
  the number C<1>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::true>) or the constant form (C<Types::Serialiser::true>).

  The constant is represented as a reference to a scalar containing C<1> -
  implementations are allowed to directly test for this.

  =item $Types::Serialiser::false, Types::Serialiser::false

  This value represents the "false" value. In most contexts is acts like
  the number C<0>. It is up to you whether you use the variable form
  (C<$Types::Serialiser::false>) or the constant form (C<Types::Serialiser::false>).

  The constant is represented as a reference to a scalar containing C<0> -
  implementations are allowed to directly test for this.

  =item Types::Serialiser::as_bool $value

  Converts a Perl scalar into a boolean, which is useful syntactic
  sugar. Strictly equivalent to:

     $value ? $Types::Serialiser::true : $Types::Serialiser::false

  =item $is_bool = Types::Serialiser::is_bool $value

  Returns true iff the C<$value> is either C<$Types::Serialiser::true> or
  C<$Types::Serialiser::false>.

  For example, you could differentiate between a perl true value and a
  C<Types::Serialiser::true> by using this:

     $value && Types::Serialiser::is_bool $value

  =item $is_true = Types::Serialiser::is_true $value

  Returns true iff C<$value> is C<$Types::Serialiser::true>.

  =item $is_false = Types::Serialiser::is_false $value

  Returns false iff C<$value> is C<$Types::Serialiser::false>.

  =back

  =head2 ERROR (Types::Serialiser::Error class)

  This class has only a single instance, C<error>. It is used to signal
  an encoding or decoding error. In CBOR for example, and object that
  couldn't be encoded will be represented by a CBOR undefined value, which
  is represented by the error value in Perl.

  =over 4

  =item $Types::Serialiser::error, Types::Serialiser::error

  This value represents the "error" value. Accessing values of this type
  will throw an exception.

  The constant is represented as a reference to a scalar containing C<undef>
  - implementations are allowed to directly test for this.

  =item $is_error = Types::Serialiser::is_error $value

  Returns false iff C<$value> is C<$Types::Serialiser::error>.

  =back

  =cut

  BEGIN {
     # for historical reasons, and to avoid extra dependencies in JSON::PP,
     # we alias *Types::Serialiser::Boolean with JSON::PP::Boolean.
     package JSON::PP::Boolean;

     *Types::Serialiser::Boolean:: = *JSON::PP::Boolean::;
  }

  {
     # this must done before blessing to work around bugs
     # in perl < 5.18 (it seems to be fixed in 5.18).
     package Types::Serialiser::BooleanBase;

     use overload
        "0+"     => sub { ${$_[0]} },
        "++"     => sub { $_[0] = ${$_[0]} + 1 },
        "--"     => sub { $_[0] = ${$_[0]} - 1 },
        fallback => 1;

     @Types::Serialiser::Boolean::ISA = Types::Serialiser::BooleanBase::;
  }

  our $true  = do { bless \(my $dummy = 1), Types::Serialiser::Boolean:: };
  our $false = do { bless \(my $dummy = 0), Types::Serialiser::Boolean:: };
  our $error = do { bless \(my $dummy    ), Types::Serialiser::Error::   };

  sub true  () { $true  }
  sub false () { $false }
  sub error () { $error }

  sub as_bool($) { $_[0] ? $true : $false }

  sub is_bool  ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_true  ($) {  $_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_false ($) { !$_[0] && UNIVERSAL::isa $_[0], Types::Serialiser::Boolean:: }
  sub is_error ($) {           UNIVERSAL::isa $_[0], Types::Serialiser::Error::   }

  package Types::Serialiser::Error;

  sub error {
     require Carp;
     Carp::croak ("caught attempt to use the Types::Serialiser::error value");
  };

  use overload
     "0+"     => \&error,
     "++"     => \&error,
     "--"     => \&error,
     fallback => 1;

  =head1 NOTES FOR XS USERS

  The recommended way to detect whether a scalar is one of these objects
  is to check whether the stash is the C<Types::Serialiser::Boolean> or
  C<Types::Serialiser::Error> stash, and then follow the scalar reference to
  see if it's C<1> (true), C<0> (false) or C<undef> (error).

  While it is possible to use an isa test, directly comparing stash pointers
  is faster and guaranteed to work.

  For historical reasons, the C<Types::Serialiser::Boolean> stash is
  just an alias for C<JSON::PP::Boolean>. When printed, the classname
  with usually be C<JSON::PP::Boolean>, but isa tests and stash pointer
  comparison will normally work correctly (i.e. Types::Serialiser::true ISA
  JSON::PP::Boolean, but also ISA Types::Serialiser::Boolean).

  =head1 A GENERIC OBJECT SERIALIATION PROTOCOL

  This section explains the object serialisation protocol used by
  L<CBOR::XS>. It is meant to be generic enough to support any kind of
  generic object serialiser.

  This protocol is called "the Types::Serialiser object serialisation
  protocol".

  =head2 ENCODING

  When the encoder encounters an object that it cannot otherwise encode (for
  example, L<CBOR::XS> can encode a few special types itself, and will first
  attempt to use the special C<TO_CBOR> serialisation protocol), it will
  look up the C<FREEZE> method on the object.

  Note that the C<FREEZE> method will normally be called I<during> encoding,
  and I<MUST NOT> change the data structure that is being encoded in any
  way, or it might cause memory corruption or worse.

  If it exists, it will call it with two arguments: the object to serialise,
  and a constant string that indicates the name of the data model. For
  example L<CBOR::XS> uses C<CBOR>, and the L<JSON> and L<JSON::XS> modules
  (or any other JSON serialiser), would use C<JSON> as second argument.

  The C<FREEZE> method can then return zero or more values to identify the
  object instance. The serialiser is then supposed to encode the class name
  and all of these return values (which must be encodable in the format)
  using the relevant form for Perl objects. In CBOR for example, there is a
  registered tag number for encoded perl objects.

  The values that C<FREEZE> returns must be serialisable with the serialiser
  that calls it. Therefore, it is recommended to use simple types such as
  strings and numbers, and maybe array references and hashes (basically, the
  JSON data model). You can always use a more complex format for a specific
  data model by checking the second argument, the data model.

  The "data model" is not the same as the "data format" - the data model
  indicates what types and kinds of return values can be returned from
  C<FREEZE>. For example, in C<CBOR> it is permissible to return tagged CBOR
  values, while JSON does not support these at all, so C<JSON> would be a
  valid (but too limited) data model name for C<CBOR::XS>. similarly, a
  serialising format that supports more or less the same data model as JSON
  could use C<JSON> as data model without losing anything.

  =head2 DECODING

  When the decoder then encounters such an encoded perl object, it should
  look up the C<THAW> method on the stored classname, and invoke it with the
  classname, the constant string to identify the data model/data format, and
  all the return values returned by C<FREEZE>.

  =head2 EXAMPLES

  See the C<OBJECT SERIALISATION> section in the L<CBOR::XS> manpage for
  more details, an example implementation, and code examples.

  Here is an example C<FREEZE>/C<THAW> method pair:

     sub My::Object::FREEZE {
        my ($self, $model) = @_;

        ($self->{type}, $self->{id}, $self->{variant})
     }

     sub My::Object::THAW {
        my ($class, $model, $type, $id, $variant) = @_;

        $class->new (type => $type, id => $id, variant => $variant)
     }

  =head1 BUGS

  The use of L<overload> makes this module much heavier than it should be
  (on my system, this module: 4kB RSS, overload: 260kB RSS).

  =head1 SEE ALSO

  Currently, L<JSON::XS> and L<CBOR::XS> use these types.

  =head1 AUTHOR

   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/

  =cut

  1

TYPES_SERIALISER

$fatpacked{"Types/Serialiser/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TYPES_SERIALISER_ERROR';
  =head1 NAME

  Types::Serialiser::Error - dummy module for Types::Serialiser

  =head1 SYNOPSIS

   # do not "use" yourself

  =head1 DESCRIPTION

  This module exists only to provide overload resolution for Storable and
  similar modules that assume that class name equals module name. See
  L<Types::Serialiser> for more info about this class.

  =cut

  use Types::Serialiser ();

  =head1 AUTHOR

   Marc Lehmann <schmorp@schmorp.de>
   http://home.schmorp.de/

  =cut

  1

TYPES_SERIALISER_ERROR

$fatpacked{"x86_64-linux/common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_COMMON_SENSE';
  package common::sense;

  our $VERSION = 3.75;

  # overload should be included

  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x03\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\xc0\x00\x00\x00\x00\x00\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x3c820fc0;
     @^H{qw(feature___SUB__ feature_bareword_filehandles feature_evalbytes feature_fc feature_indirect feature_multidimensional feature_say feature_state feature_switch feature_unicode)} = (1) x 10;
  }

  1
X86_64-LINUX_COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


# This script needs to be fatpacked when done.
# In order to do this, please use the pre-commit hook
# available in the tools/git-hooks directory, as such:
# ( cd .git/hooks && ln -s ../../tools/git-hooks/pre-commit )

use v5.22;
use strict;
use warnings;
use diagnostics;

use App::Seacan;
use English '-no_match_vars';
use Getopt::Long qw(:config no_ignore_case);
use IPC::Open3 qw(open3);
use Path::Tiny qw(path tempdir);

use constant {
    'DEFAULT_PERL_VERSION' => '5.38.0',
};

my $app_dir = path('.');
Getopt::Long::GetOptions(
    'perl=s'    => \(my $perl_version = DEFAULT_PERL_VERSION()),
    'app-dir=s' => \$app_dir,
    'files=s@'  => \my @additional_files,
    'help'      => \my $help,
);

$help and _print_help();

-d $app_dir or _print_help('--app-dir must point to a directory');

my $top_src_dir  = tempdir('CLEANUP' => 1);
my $top_dest_dir = tempdir('CLEANUP' => 1);
my $source_dir   = $top_src_dir->child('pakket');
my $dest_dir     = $top_dest_dir->child('pakket');

$dest_dir->mkpath();
$source_dir->mkpath();

my @directories = qw(bin lib share);
foreach my $dir (@directories) {
    path($dir)->visit(
        sub {
            my $next = shift;

            $next->is_file
                or return;

            my $next_dir  = $next->parent;
            my $next_path = $source_dir->child($next_dir);
            $next_path->mkpath();

            say "Copy $next -> $next_path";
            $next->copy($next_path);
        },
        {'recurse' => 1},
    );
}

# cpanfile must be there so "cpanm" would work on the app
foreach my $node (@additional_files, 'cpanfile') {
    my $file = path($node);
    say "Copy $file -> $source_dir";
    $file->copy($source_dir->child($file));
}

my $seacan = App::Seacan->new(
    'config' => {
        'seacan' => {
            'app_name' => 'pakket',
            'output'   => $dest_dir,
            'app'      => $source_dir,
        },

        'perl' => {
            'version'         => $perl_version,
            'installed_as'    => 'seacan',
            'notest'          => 1,
            'noman'           => 1,
            'relocatable_INC' => 1,
            'parallel'        => _detect_cores(),
        },
    },
);

$seacan->run;
say 'Seacan is finished';

say 'Packing...';
my @cmd = (
    'tar', '--create', '--gzip', '--exclude-vcs', "--directory=$top_dest_dir",
    '--file=' . path('pakket.tar.gz')->absolute, '.',
);
say join (' ', @cmd);
system (@cmd) == 0
    or die 'Unable to run command';

sub _print_help {
    my $error   = shift;
    my $min_ver = DEFAULT_PERL_VERSION();

    $error and say "[ERROR] $error\n";

    say << "_END_HELP";
$PROGRAM_NAME [--perl PERL_VER] --app-dir DIR

Options:

--perl        Perl version (default: $min_ver)
--app-dir     Application directory (default: .)
--files       Additional files for inclusion
              (Specify multiple times for each file)
_END_HELP

    exit 2;
}

sub _detect_cores {
    my $cores = 1;
    if ($OSNAME =~ /linux/xms) {
        local $SIG{'CHLD'} = 'IGNORE';
        my ($writer, $reader, $err);
        open3($writer, $reader, $err, 'nproc');
        chomp ($cores = <$reader>);
    }

    return $cores;
}
